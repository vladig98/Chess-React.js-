{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Vladi Gotsin\\\\Desktop\\\\react\\\\Chess-React.js-\\\\src\\\\HelperMethods.js\";\nimport React from 'react';\nimport Square from \"./Square.js\";\nimport * as GlobalVariables from './globalVariables';\n\n/**\r\n * Gets the piece from a square.\r\n * @param {object} square - The square to get the piece from.\r\n * @returns {string} - The piece.\r\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function getPiece(square) {\n  return square.props.piece.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_PIECE_INDEX];\n}\n\n/**\r\n * Checks if a square has a specific piece.\r\n * @param {object} square - The square to check.\r\n * @param {string} piece - The piece to check for.\r\n * @returns {boolean} - True if the square has the piece, false otherwise.\r\n */\nexport function doesTheSquareHasThePiece(square, piece) {\n  return getPiece(square) === piece;\n}\n\n/**\r\n * Checks if the piece on the square is a King.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the piece is a King, false otherwise.\r\n */\nexport function isKing(square) {\n  return doesTheSquareHasThePiece(square, GlobalVariables.PIECES.KING);\n}\n\n/**\r\n * Checks if the piece on the square is a Bishop.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the piece is a Bishop, false otherwise.\r\n */\nexport function isBishop(square) {\n  return doesTheSquareHasThePiece(square, GlobalVariables.PIECES.BISHOP);\n}\n\n/**\r\n * Checks if the piece on the square is a Queen.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the piece is a Queen, false otherwise.\r\n */\nexport function isQueen(square) {\n  return doesTheSquareHasThePiece(square, GlobalVariables.PIECES.QUEEN);\n}\n\n/**\r\n * Checks if the piece on the square is a Rook.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the piece is a Rook, false otherwise.\r\n */\nexport function isRook(square) {\n  return doesTheSquareHasThePiece(square, GlobalVariables.PIECES.ROOK);\n}\n\n/**\r\n * Checks if the piece on the square is a Pawn.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the piece is a Pawn, false otherwise.\r\n */\nexport function isPawn(square) {\n  return doesTheSquareHasThePiece(square, GlobalVariables.PIECES.PAWN);\n}\n\n/**\r\n * Checks if the piece on the square is a Knight.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the piece is a Knight, false otherwise.\r\n */\nexport function isKnight(square) {\n  return doesTheSquareHasThePiece(square, GlobalVariables.PIECES.KNIGHT);\n}\n\n/**\r\n * Checks if a character is Uppercase using the ASCII table.\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is uppercase, false otherwise.\r\n */\nexport function IsUpperCase(value) {\n  const firstChar = getFirstCharacter(value);\n  return firstChar >= GlobalVariables.ASCII_UPPERCASE_A && firstChar <= GlobalVariables.ASCII_UPPERCASE_Z;\n}\n\n/**\r\n * Returns the ASCII code of the first character of a string.\r\n * @param {string} value - The string from which to get the ASCII code.\r\n * @returns {number} - The ASCII code of the first character.\r\n */\n_c = IsUpperCase;\nexport function getFirstCharacter(value) {\n  return value.charCodeAt(0);\n}\n\n/**\r\n * Checks if a character is Lowercase using the ASCII table.\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is lowercase, false otherwise.\r\n */\nexport function IsLowerCase(value) {\n  const firstChar = getFirstCharacter(value);\n  return firstChar >= GlobalVariables.ASCII_LOWERCASE_A && firstChar <= GlobalVariables.ASCII_LOWERCASE_Z;\n}\n\n/**\r\n * Checks if a character is a Digit using the ASCII table.\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is a digit, false otherwise.\r\n */\n_c2 = IsLowerCase;\nexport function IsDigit(value) {\n  const firstChar = getFirstCharacter(value);\n  return firstChar >= GlobalVariables.ASCII_DIGIT_0 && firstChar <= GlobalVariables.ASCII_DIGIT_9;\n}\n\n/**\r\n * Parses a FEN string and returns its components.\r\n * @param {string} fen - The FEN string to parse.\r\n * @returns {object} - An object containing the FEN components.\r\n */\n_c3 = IsDigit;\nexport function ParseFEN(fen) {\n  const fenParts = fen.split(GlobalVariables.EMPTY_SPACE);\n  if (fenParts.length !== GlobalVariables.FEN_VALID_PARTS_NUMBER) {\n    throw new Error('Invalid FEN');\n  }\n  const [fenBoard, fenTurn, fenCastling, fenEnPassant, fenHalfMoves, fenFullMoves] = fenParts;\n  return {\n    fenBoard,\n    fenTurn,\n    fenCastling,\n    fenEnPassant,\n    fenHalfMoves: Number(fenHalfMoves),\n    fenFullMoves: Number(fenFullMoves)\n  };\n}\n\n/**\r\n * Converts FEN piece notation to an actual piece.\r\n * @param {string} letter - The FEN notation of the piece.\r\n * @returns {string} - The actual piece.\r\n */\n_c4 = ParseFEN;\nexport function ConvertFENtoPiece(letter) {\n  const FEN_PIECE_MAP = {\n    [GlobalVariables.FEN_PIECES_BLACK.PAWN]: GlobalVariables.PIECES.PAWN,\n    [GlobalVariables.FEN_PIECES_BLACK.KNIGHT]: GlobalVariables.PIECES.KNIGHT,\n    [GlobalVariables.FEN_PIECES_BLACK.KING]: GlobalVariables.PIECES.KING,\n    [GlobalVariables.FEN_PIECES_BLACK.QUEEN]: GlobalVariables.PIECES.QUEEN,\n    [GlobalVariables.FEN_PIECES_BLACK.ROOK]: GlobalVariables.PIECES.ROOK,\n    [GlobalVariables.FEN_PIECES_BLACK.BISHOP]: GlobalVariables.PIECES.BISHOP\n  };\n  return FEN_PIECE_MAP[letter.toLowerCase()] || GlobalVariables.EMPTY_STRING;\n}\n\n/**\r\n * Converts the FEN piece notation to a piece that we can use in the square component.\r\n * @param {string} value - The FEN notation of the piece.\r\n * @returns {string} - The piece in {color-piece} format.\r\n */\n_c5 = ConvertFENtoPiece;\nexport function ConvertFENPieceToPiece(value) {\n  if (IsUpperCase(value)) {\n    return `${GlobalVariables.COLORS.WHITE}${GlobalVariables.PIECE_DELIMITER}${ConvertFENtoPiece(value)}`;\n  }\n  if (IsLowerCase(value)) {\n    return `${GlobalVariables.COLORS.BLACK}${GlobalVariables.PIECE_DELIMITER}${ConvertFENtoPiece(value)}`;\n  }\n  return GlobalVariables.EMPTY_STRING;\n}\n\n/**\r\n * Converts a string in FEN format to a normal string.\r\n * @param {string} value - The FEN string.\r\n * @returns {string} - The normal string.\r\n */\n_c6 = ConvertFENPieceToPiece;\nexport function ConvertFenToString(value) {\n  return value.split(GlobalVariables.EMPTY_STRING).reduce((result, char) => {\n    if (IsDigit(char)) {\n      return result + GlobalVariables.EMPTY_SQUARE_PIECE.repeat(Number(char));\n    }\n    return result + char;\n  }, GlobalVariables.EMPTY_STRING);\n}\n\n/**\r\n * Checks if two squares are on the same row.\r\n * @param {object} square1 - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if the squares are on the same row, false otherwise.\r\n */\n_c7 = ConvertFenToString;\nexport function checkIfTwoSquaresAreOnTheSameRow(square1, square2) {\n  return square1.props.x === square2.props.x;\n}\n\n/**\r\n * Checks if two squares are on the same column.\r\n * @param {object} square1 - The first square to check.\r\n * @param {object} square2 - The second square to check.\r\n * @returns {boolean} - True if both squares are on the same column, false otherwise.\r\n */\nexport function checkIfTwoSquaresAreOnTheSameColumn(square1, square2) {\n  return square1.props.y === square2.props.y;\n}\n\n/**\r\n * Checks if the square is on the given row number.\r\n * @param {object} square - The square to check.\r\n * @param {number} rowNumber - The row number.\r\n * @returns {boolean} - True if the square is on the given row, false otherwise.\r\n */\nexport function isSquareOnRow(square, rowNumber) {\n  return square.props.x === rowNumber;\n}\n\n/**\r\n * Checks if the square is on the given column number.\r\n * @param {object} square - The square to check.\r\n * @param {number} columnNumber - The column number.\r\n * @returns {boolean} - True if the square is on the given column, false otherwise.\r\n */\nexport function isSquareOnColumn(square, columnNumber) {\n  return square.props.y === columnNumber;\n}\n\n/**\r\n * Gets the piece color from a square.\r\n * @param {object} square - The square to get the piece color from.\r\n * @returns {string} - The piece color.\r\n */\nexport function getPieceColor(square) {\n  return square.props.piece.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_COLOR_INDEX];\n}\n\n/**\r\n * Checks if a color is white.\r\n * @param {string} color - The color to check.\r\n * @returns {boolean} - True if the color is white, false otherwise.\r\n */\nexport function isColorWhite(color) {\n  return color === GlobalVariables.COLORS.WHITE;\n}\n\n/**\r\n * Checks if a color is black.\r\n * @param {string} color - The color to check.\r\n * @returns {boolean} - True if the color is black, false otherwise.\r\n */\nexport function isColorBlack(color) {\n  return color === GlobalVariables.COLORS.BLACK;\n}\n\n/**\r\n * Checks if two pieces are of the same color.\r\n * @param {string} piece1 - The first piece.\r\n * @param {string} piece2 - The second piece.\r\n * @returns {boolean} - True if the pieces are of the same color, false otherwise.\r\n */\nexport function areSameColor(piece1, piece2) {\n  return getPieceColor(piece1) === getPieceColor(piece2);\n}\n\n/**\r\n * Checks if a move is equal to the current selected square.\r\n * @param {object} move - The move to check.\r\n * @returns {boolean} - True if the move is equal to the current selected square, false otherwise.\r\n */\nexport function checkIfAMoveIsEqualToTheCurrentSelectedSquare(move) {\n  return isSquareOnRow(move, GlobalVariables.CurrentSquareSelection.x) && isSquareOnColumn(move, GlobalVariables.CurrentSquareSelection.y);\n}\n\n/**\r\n * Compares if two squares are the same.\r\n * @param {object} square1 - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if the squares are the same, false otherwise.\r\n */\nexport function compareIfTwoSquaresAreTheSame(square1, square2) {\n  if (square1 || square2) return false;\n  return checkIfTwoSquaresAreOnTheSameRow(square1, square2) && checkIfTwoSquaresAreOnTheSameColumn(square1, square2);\n}\n\n/**\r\n * Gets a target square by its location.\r\n * @param {number} x - The x coordinate of the target square.\r\n * @param {number} y - The y coordinate of the target square.\r\n * @param {array} squares - The board squares array.\r\n * @returns {object} - The target square.\r\n */\nexport function getATargetSquareByLocation(x, y, squares) {\n  return squares.find(s => isSquareOnRow(s, x) && isSquareOnColumn(s, y));\n}\n\n/**\r\n * Gets a target square by its piece.\r\n * @param {string} piece - The piece to search for.\r\n * @param {array} squares - The board squares array.\r\n * @returns {object} - The target square.\r\n */\nexport function getATargetSquareByPiece(piece, squares) {\n  return squares.find(s => s.props.piece == piece);\n}\n\n/**\r\n * Checks if castling is possible.\r\n * @param {string} castlingType - The type of castling (long or short).\r\n * @param {boolean} [withWhite=true] - True if checking for white's castling, false otherwise.\r\n * @returns {boolean} - True if castling is possible, false otherwise.\r\n */\nexport function isCastlingPossible(castlingType, withWhite = true) {\n  const row = withWhite ? GlobalVariables.CASTLE_ROW_WHITE : GlobalVariables.CASTLE_ROW_BLACK;\n  const pieces = withWhite ? GlobalVariables.FEN_PIECES_WHITE : GlobalVariables.FEN_PIECES_BLACK;\n  const [rookCol, kingCol, pathCols] = castlingType === GlobalVariables.CASTLING_TYPES.LONG ? [GlobalVariables.CASTLE_ROOK_INITIAL_COL_LONG, GlobalVariables.CASTLE_KING_INITIAL_COL, GlobalVariables.CASTLE_PATH_COLS_LONG] : [GlobalVariables.CASTLE_ROOK_INITIAL_COL_SHORT, GlobalVariables.CASTLE_KING_INITIAL_COL, GlobalVariables.CASTLE_PATH_COLS_SHORT];\n  return GlobalVariables.BoardPosition[row][rookCol] === pieces.ROOK && GlobalVariables.BoardPosition[row][kingCol] === pieces.KING && pathCols.every(col => GlobalVariables.BoardPosition[row][col] === GlobalVariables.EMPTY_SQUARE_PIECE);\n}\n\n/**\r\n * Checks if a pawn is on its starting square.\r\n * @param {object} pawn - The pawn to check.\r\n * @returns {boolean} - True if the pawn is on its starting square, false otherwise.\r\n */\nexport function isPawnOnStartingSquare(pawn) {\n  const isWhite = isColorWhite(getPieceColor(pawn));\n  return isWhite ? isSquareOnRow(pawn, GlobalVariables.WHITE_PAWN_STARTING_SQUARE) : isSquareOnRow(pawn, GlobalVariables.BLACK_PAWN_STARTING_SQUARE);\n}\n\n/**\r\n * Checks if a pawn is on an en passant square.\r\n * @param {object} pawn - The pawn to check.\r\n * @returns {boolean} - True if the pawn is on an en passant square, false otherwise.\r\n */\nexport function isPawnOnEnPassantSquare(pawn) {\n  const isWhite = isColorWhite(getPieceColor(pawn));\n  return isWhite ? isSquareOnRow(pawn, GlobalVariables.WHITE_EN_PASSANT_SQUARE) : isSquareOnRow(pawn, GlobalVariables.BLACK_EN_PASSANT_SQUARE);\n}\n\n/**\r\n * Checks if a square is available for a move.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the square is available, false otherwise.\r\n */\nexport function isSquareAvailable(square) {\n  return !square.props.piece;\n}\n\n/**\r\n * Updates a column on a row with a new value.\r\n * @param {Array} row - The row to update.\r\n * @param {number} colIndex - The column index.\r\n * @param {string} newValue - The new value.\r\n * @returns {Array} - The updated row.\r\n */\nexport function updateColumnOnARow(row, colIndex, newValue) {\n  row[colIndex] = newValue;\n  return row;\n}\n\n/**\r\n * Removes the current square's piece.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\nexport function handleSquareOnCurrentRow(currentSquare, targetSquare, row) {\n  return checkIfTwoSquaresAreOnTheSameRow(currentSquare, targetSquare) ? handleSquareAndTargetSquareOnTheSameRow(currentSquare, targetSquare, row) : updateColumnOnARow(row, currentSquare.props.y, GlobalVariables.EMPTY_SQUARE_PIECE);\n}\n\n/**\r\n * Updates the target square with the current square's piece.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\nexport function handleTargetSquareOnCurrentRow(currentSquare, targetSquare, row) {\n  return updateColumnOnARow(row, targetSquare.props.y, ConvertPieceToFENPiece(currentSquare.props.piece));\n}\n\n/**\r\n * Checks if castling is possible for either side.\r\n * @returns {boolean} - True if castling is possible for either side, false otherwise.\r\n */\nexport function canWeCastle() {\n  return Object.values(GlobalVariables.CastlingRights).some(s => s);\n}\n\n/**\r\n * Checks if we're making a move on the same row and performs castling if we want to castle.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\nexport function handleSquareAndTargetSquareOnTheSameRow(currentSquare, targetSquare, row) {\n  if (isKing(currentSquare) && canWeCastle() && Math.abs(currentSquare.props.y - targetSquare.props.y) == 2) {\n    return handleCastling(currentSquare, row);\n  }\n  return SidewaysCapture(row, Number(currentSquare.props.y), Number(targetSquare.props.y), currentSquare.props.piece);\n}\n\n/**\r\n * Performs castling by swapping the rook and the king.\r\n * @param {object} square - The square to update.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\nexport function handleCastling(square, row) {\n  const color = getPieceColor(square);\n  const isWhite = isColorWhite(color);\n  const kingPiece = isWhite ? GlobalVariables.FEN_PIECES_WHITE.KING : GlobalVariables.FEN_PIECES_BLACK.KING;\n  const rookPiece = isWhite ? GlobalVariables.FEN_PIECES_WHITE.ROOK : GlobalVariables.FEN_PIECES_BLACK.ROOK;\n  Object.values(GlobalVariables.CASTLING_TYPES).forEach(type => {\n    if (isCastlingPossible(type, isWhite)) {\n      const [emptySquares, kingFinalCol, rookFinalCol] = type === GlobalVariables.CASTLING_TYPES.LONG ? [GlobalVariables.EMPTY_SQUARES_AFTER_LONG_CASTLE, GlobalVariables.CASTLE_KING_FINAL_COL_LONG, GlobalVariables.CASTLE_ROOK_FINAL_COL_LONG] : [GlobalVariables.EMPTY_SQUARES_AFTER_SHORT_CASTLE, GlobalVariables.CASTLE_KING_FINAL_COL_SHORT, GlobalVariables.CASTLE_ROOK_FINAL_COL_SHORT];\n      emptySquares.forEach(col => row[col] = GlobalVariables.EMPTY_SQUARE_PIECE);\n      row[kingFinalCol] = kingPiece;\n      row[rookFinalCol] = rookPiece;\n    }\n  });\n  return row;\n}\n\n/**\r\n * Converts a row of squares to its FEN representation.\r\n * @param {Array} row - The row to convert.\r\n * @returns {string} - The FEN representation of the row.\r\n */\nexport function convertRowToFEN(row) {\n  return row.reduce((acc, column) => {\n    if (column === GlobalVariables.EMPTY_SQUARE_PIECE) {\n      const lastChar = acc.slice(-1);\n      if (IsDigit(lastChar)) {\n        return acc.slice(0, -1) + (Number(lastChar) + 1); //add 1 to the previous number if an empty space\n      } else {\n        return acc + '1'; //set the next piece as 1 (1 empty space)\n      }\n    } else {\n      return acc + column; //return the piece if no empty spaces\n    }\n  }, GlobalVariables.EMPTY_STRING);\n}\n\n/**\r\n * Gets the castling rules as a string.\r\n * @returns {string} - The castling rules.\r\n */\nexport function getCastlingRules() {\n  const sortedKeys = getSortedCastlingKeys();\n  const castlingMap = {\n    [sortedKeys[0]]: GlobalVariables.FEN_PIECES_BLACK.QUEEN,\n    // 'blackLongCastle'\n    [sortedKeys[1]]: GlobalVariables.FEN_PIECES_BLACK.KING,\n    // 'blackShortCastle'\n    [sortedKeys[2]]: GlobalVariables.FEN_PIECES_WHITE.QUEEN,\n    // 'whiteLongCastle'\n    [sortedKeys[3]]: GlobalVariables.FEN_PIECES_WHITE.KING // 'whiteShortCastle'\n  };\n  return sortedKeys.map(key => GlobalVariables.CastlingRights[key] ? castlingMap[key] : GlobalVariables.EMPTY_STRING).join(GlobalVariables.EMPTY_STRING) || GlobalVariables.PIECE_DELIMITER;\n}\n\n/**\r\n * Generates a new FEN string based on the current board state.\r\n * @returns {string} - The new FEN string.\r\n */\nexport function generateANewFen() {\n  const fenRows = GlobalVariables.BoardPosition.map(row => convertRowToFEN(row)).join(GlobalVariables.FEN_BOARD_DELIMITER);\n  const turn = GlobalVariables.IsWhiteToMove ? GlobalVariables.FEN_COLOR.WHITE : GlobalVariables.FEN_COLOR.BLACK;\n  const castling = getCastlingRules();\n  const enPassant = GlobalVariables.EnPassant.isPossible ? convertLocationToCoordinates(GlobalVariables.EnPassant.x, GlobalVariables.EnPassant.y) : GlobalVariables.PIECE_DELIMITER;\n  const halfMoves = GlobalVariables.HalfMoves;\n  const fullMoves = GlobalVariables.FullMoves;\n  return `${fenRows} ${turn} ${castling} ${enPassant} ${halfMoves} ${fullMoves}`;\n}\n\n/**\r\n * Returns the keys of the CastlingRights object in alphabetical order.\r\n * @returns {Array<string>} - The sorted keys of CastlingRights.\r\n */\nexport function getSortedCastlingKeys() {\n  return Object.keys(GlobalVariables.CastlingRights).sort();\n}\n\n/**\r\n * Updates castling rights based on the given castling string.\r\n * @param {string} castling - The castling rights string (e.g., 'KQkq').\r\n */\nexport function updateCastlingRights(castling) {\n  const sortedKeys = getSortedCastlingKeys();\n\n  // Create a map based on the sorted keys to ensure consistency\n  const castlingMap = {\n    [GlobalVariables.FEN_PIECES_BLACK.QUEEN]: sortedKeys[0],\n    // 'blackLongCastle'\n    [GlobalVariables.FEN_PIECES_BLACK.KING]: sortedKeys[1],\n    // 'blackShortCastle'\n    [GlobalVariables.FEN_PIECES_WHITE.QUEEN]: sortedKeys[2],\n    // 'whiteLongCastle'\n    [GlobalVariables.FEN_PIECES_WHITE.KING]: sortedKeys[3] // 'whiteShortCastle'\n  };\n\n  // Update castling rights using the castling map\n  Object.keys(castlingMap).forEach(key => {\n    GlobalVariables.CastlingRights[castlingMap[key]] = castling.includes(key);\n  });\n}\n\n/**\r\n * Updates en passant status based on the given en passant string.\r\n * @param {string} enPassant - The en passant target square (e.g., 'e3') or '-' if not available.\r\n */\nexport function updateEnPassant(enPassant) {\n  if (enPassant !== GlobalVariables.PIECE_DELIMITER) {\n    const {\n      x,\n      y\n    } = convertCoordinatesToLocation(enPassant);\n    Object.assign(GlobalVariables.EnPassant, {\n      isPossible: true,\n      x: x,\n      y: y\n    });\n  }\n}\n\n/**\r\n * Checks if the given coordinates are within the bounds of the chessboard.\r\n *\r\n * This function ensures that the coordinates (x, y) fall within the valid range\r\n * of the chessboard dimensions. It returns true if both x and y are greater than\r\n * or equal to 0 and less than the board dimension (DIM). This is useful for \r\n * validating moves and ensuring that they do not exceed the boundaries of the board.\r\n *\r\n * @param {number} x - The x-coordinate to check.\r\n * @param {number} y - The y-coordinate to check.\r\n * @returns {boolean} - True if the coordinates are within the bounds of the board, false otherwise.\r\n */\nexport function areCoordinatesInBounds(x, y) {\n  return x >= 0 && y >= 0 && x < GlobalVariables.DIM && y < GlobalVariables.DIM;\n}\n\n/**\r\n * Parses the FEN string to update the board state.\r\n * @param {string} fen - The FEN string representing the board state.\r\n * @param {Array} isPossibleMove - Array indicating possible moves.\r\n * @param {function} getPossibleMoves - Function to get possible moves.\r\n * @param {function} movePiece - Function to move a piece.\r\n * @param {function} resetPossibleMoves - Function to reset possible moves.\r\n * @param {boolean} [updateBoardPosition=true] - Whether to update the board position.\r\n * @returns {Array} - The generated square components.\r\n */\nexport function fenParser(fen, isPossibleMove, getPossibleMoves, movePiece, resetPossibleMoves, updateBoardPosition = true) {\n  const {\n    fenBoard,\n    fenTurn,\n    fenCastling,\n    fenEnPassant,\n    fenHalfMoves,\n    fenFullMoves\n  } = ParseFEN(fen);\n  const fenRows = fenBoard.split(GlobalVariables.FEN_BOARD_DELIMITER);\n  const boardArray = fenRows.map(row => ConvertFenToString(row).split(GlobalVariables.EMPTY_STRING));\n  const squares = generateSquareComponents(boardArray, isPossibleMove, getPossibleMoves, movePiece, resetPossibleMoves);\n  updateCastlingRights(fenCastling);\n  GlobalVariables.updateIsWhiteToMove(fenTurn === GlobalVariables.FEN_COLOR.WHITE);\n  GlobalVariables.updateHalfMoves(fenHalfMoves);\n  GlobalVariables.updateFullMoves(fenFullMoves);\n\n  // if (updateBoardPosition) {\n  GlobalVariables.BoardPosition.splice(0, GlobalVariables.BoardPosition.length, ...boardArray);\n  //}\n\n  updateEnPassant(fenEnPassant);\n  return squares;\n}\n\n/**\r\n * Updates the board position after making a move.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @returns {Array} - The updated board position.\r\n */\nexport function updateBoardPosition(currentSquare, targetSquare) {\n  return GlobalVariables.BoardPosition.map((row, rowIndex) => {\n    if (isSquareOnRow(currentSquare, rowIndex)) {\n      row = handleSquareOnCurrentRow(currentSquare, targetSquare, row);\n    }\n    if (isSquareOnRow(targetSquare, rowIndex)) {\n      row = handleTargetSquareOnCurrentRow(currentSquare, targetSquare, row);\n    }\n    return row;\n  });\n}\n\n/**\r\n * Modifies the row to capture pieces sideways.\r\n * @param {Array} row - The row to update.\r\n * @param {number} colIndex - The column index of the current square.\r\n * @param {number} targetColIndex - The column index of the target square.\r\n * @param {string} value - The piece value.\r\n * @returns {Array} - The updated row.\r\n */\nexport function SidewaysCapture(row, colIndex, targetColIndex, value) {\n  return row.map((col, index) => {\n    if (index === colIndex) return GlobalVariables.EMPTY_SQUARE_PIECE;\n    if (index === targetColIndex) return ConvertPieceToFENPiece(value);\n    return col;\n  });\n}\n\n/**\r\n * Converts the piece from {color-piece} format to FEN format (a single letter).\r\n * @param {string} value - The piece value.\r\n * @returns {string} - The FEN notation of the piece.\r\n */\n_c8 = SidewaysCapture;\nexport function ConvertPieceToFENPiece(value) {\n  const [color, piece] = value.split(GlobalVariables.PIECE_DELIMITER);\n  const pieceMapping = {\n    [GlobalVariables.PIECES.PAWN]: GlobalVariables.FEN_PIECES_BLACK.PAWN,\n    [GlobalVariables.PIECES.KNIGHT]: GlobalVariables.FEN_PIECES_BLACK.KNIGHT,\n    [GlobalVariables.PIECES.BISHOP]: GlobalVariables.FEN_PIECES_BLACK.BISHOP,\n    [GlobalVariables.PIECES.ROOK]: GlobalVariables.FEN_PIECES_BLACK.ROOK,\n    [GlobalVariables.PIECES.QUEEN]: GlobalVariables.FEN_PIECES_BLACK.QUEEN,\n    [GlobalVariables.PIECES.KING]: GlobalVariables.FEN_PIECES_BLACK.KING\n  };\n  const fenPiece = pieceMapping[piece];\n  return isColorWhite(color) ? fenPiece.toUpperCase() : fenPiece;\n}\n\n/**\r\n * Generates Square components for the given board state.\r\n * @param {Array} boardSquares - The 2D array representing the board squares.\r\n * @param {Array} isPossibleMove - The array of possible move states.\r\n * @param {Function} getPossibleMoves - The function to get possible moves.\r\n * @param {Function} movePiece - The function to move a piece.\r\n * @param {Function} resetPossibleMoves - The function to reset possible moves.\r\n * @returns {Array} - The array of Square components.\r\n */\n_c9 = ConvertPieceToFENPiece;\nexport function generateSquareComponents(boardSquares, isPossibleMove, getPossibleMoves, movePiece, resetPossibleMoves) {\n  let squareColorIsWhite = true;\n  const squares = boardSquares.flatMap((row, rowIndex) => {\n    const rowSquares = row.map((square, colIndex) => {\n      const color = squareColorIsWhite ? GlobalVariables.EMPTY_STRING : GlobalVariables.DARK_SQUARES_COLOR;\n      const possibleMoveStatus = isPossibleMove.find(item => item.key === `${rowIndex}${GlobalVariables.PIECE_DELIMITER}${colIndex}`);\n      const squareComponent = /*#__PURE__*/_jsxDEV(Square, {\n        x: rowIndex,\n        y: colIndex,\n        piece: ConvertFENPieceToPiece(square),\n        color: color,\n        getPossibleMoves: getPossibleMoves,\n        movePiece: movePiece,\n        isPossibleMove: possibleMoveStatus ? possibleMoveStatus.value : false,\n        resetPossibleMoves: resetPossibleMoves\n      }, `${rowIndex}${GlobalVariables.PIECE_DELIMITER}${colIndex}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 662,\n        columnNumber: 17\n      }, this);\n      squareColorIsWhite = !squareColorIsWhite;\n      return squareComponent;\n    });\n    squareColorIsWhite = !squareColorIsWhite; // Reset color for the next row\n    return rowSquares;\n  });\n  return squares;\n}\n\n/**\r\n * Converts board coordinates to X and Y position on the board, e.g., a8 = 0, 0\r\n * @param {string} coordinates - The board coordinates to convert.\r\n * @returns {object} - Returns an object with x and y properties.\r\n */\nexport function convertCoordinatesToLocation(coordinates) {\n  let tokens = coordinates.split(GlobalVariables.EMPTY_STRING);\n\n  //skip invalid coordinates\n  if (tokens.length != 2) {\n    return;\n  }\n  let letter = tokens[0].toString().toUpperCase();\n  let number = tokens[1];\n\n  //65 is the ASCII code for capital A which will give us 0 if we have A as a coordinate; A-F will give us 0-7 for y (columns)\n  //reverse the numbers since we draw the board top down for x (rows)\n  return {\n    x: GlobalVariables.DIM - Number(number),\n    y: getFirstCharacter(letter) - GlobalVariables.ASCII_UPPERCASE_A\n  };\n}\n\n/**\r\n * Converts a piece location to board coordinate, e.g., 0, 0 to a8\r\n * @param {string} x - The X position.\r\n * @param {string} y - The Y position.\r\n * @returns {string} - Returns a string containing the board coordinates.\r\n */\nexport function convertLocationToCoordinates(x, y) {\n  //maps y (column) to the letter coordinate; add 65 (capital A code) to the ASCII code for the location we have and we get a letter between A and F\n  //reverses the x (rows) coordinate because we drop the board top down, while coordinates go down up\n  return `${String.fromCharCode(y + GlobalVariables.ASCII_UPPERCASE_A)}${GlobalVariables.DIM - x}`.toLowerCase();\n}\n\n/**\r\n * Determines if the king is in check.\r\n * @param {object} kingSquare - The square where the king is located.\r\n * @param {array} boardSquares - The board squares array.\r\n * @returns {boolean} - True if the king is in check, false otherwise.\r\n */\nexport function isKingInCheck(kingSquare, boardSquares) {\n  const squares = boardSquares;\n  const color = getPieceColor(kingSquare);\n  const knightMoves = [[-2, -1], [-2, 1], [2, -1], [2, 1], [-1, 2], [1, 2], [-1, -2], [1, -2]];\n  const linearDirections = [[1, 0], [-1, 0], [0, 1], [0, -1] // Right, Left, Up, Down\n  ];\n  const diagonalDirections = [[1, 1], [-1, -1], [1, -1], [-1, 1] // Diagonals\n  ];\n  const checkDirections = directions => {\n    let isInCheck = false;\n    for (const [dx, dy] of directions) {\n      //only a queen and a bishop can check diagonally (+ a pawn)\n      //only a queen and a rook can check linearly\n      const piecesTypes = Math.abs(dx) == Math.abs(dy) ? [GlobalVariables.PIECES.QUEEN, GlobalVariables.PIECES.BISHOP] : [GlobalVariables.PIECES.QUEEN, GlobalVariables.PIECES.ROOK];\n      for (let i = 1; i < GlobalVariables.DIM; i++) {\n        // Get the king and the square that is offset by the given distance\n        const piece = getATargetSquareByLocation((kingSquare === null || kingSquare === void 0 ? void 0 : kingSquare.props.x) + dx * i, (kingSquare === null || kingSquare === void 0 ? void 0 : kingSquare.props.y) + dy * i, squares);\n\n        // Don't check anything if we go out of bounds\n        if (!piece) {\n          break;\n        }\n\n        // Get the square data (color and piece type)\n        const pieceColor = getPieceColor(piece);\n        const pieceType = getPiece(piece);\n\n        // Move to the next square if this one is empty\n        if (!pieceType) {\n          continue;\n        }\n\n        // If the piece is the same color, it can't give us a check, so break\n        if (pieceColor === color) {\n          break;\n        }\n\n        // Check if the piece is a queen, rook, or bishop,\n        // or if it's a pawn and we are exactly 1 square away (pawns can't check from more than 1 square away)\n        if (piecesTypes.includes(pieceType) || pieceType == GlobalVariables.PIECES.PAWN && i === 1 && Math.abs(dx) == Math.abs(dy)) {\n          return true;\n        }\n        isInCheck = false;\n        break;\n      }\n    }\n    return isInCheck;\n  };\n  if (checkDirections(linearDirections) || checkDirections(diagonalDirections)) {\n    return true;\n  }\n  for (const [dx, dy] of knightMoves) {\n    const piece = squares.find(s => isSquareOnRow(s, kingSquare.props.x + dx) && isSquareOnColumn(s, kingSquare.props.y + dy));\n\n    // If we're not out of bounds\n    // If the the piece is a different color than the king\n    // If the piece is a knight\n    if (piece && getPieceColor(piece) !== color && getPiece(piece) === GlobalVariables.PIECES.KNIGHT) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\r\n * Determines if a move is legal by checking if the king would be in check after the move.\r\n * \r\n * @param {object} kingSquare - The square where the king is currently located.\r\n * @param {Array} boardSquares - The current state of the board as an array of squares.\r\n * @param {object} currentPiece - The piece that is being moved.\r\n * @param {object} targetLocation - The square where the piece is being moved to.\r\n * \r\n * @returns {boolean} - True if the move is legal (i.e., does not put the king in check), false otherwise.\r\n */\nexport function isMoveLegal(kingSquare, boardSquares, currentPiece, targetLocation) {\n  const squares = boardSquares;\n  const updatedSquares = squares.map(s => {\n    if (currentPiece && compareIfTwoSquaresAreTheSame(s, currentPiece)) {\n      return /*#__PURE__*/React.cloneElement(s, {\n        piece: GlobalVariables.EMPTY_STRING\n      });\n    } else if (targetLocation && compareIfTwoSquaresAreTheSame(s, targetLocation)) {\n      return /*#__PURE__*/React.cloneElement(s, {\n        piece: currentPiece.props.piece\n      });\n    } else {\n      return s;\n    }\n  });\n\n  // Handles legal moves for the king\n  const king = compareIfTwoSquaresAreTheSame(kingSquare, currentPiece) ? getATargetSquareByLocation(targetLocation.props.x, targetLocation.props.y, updatedSquares) : kingSquare;\n  return !isKingInCheck(king, updatedSquares);\n}\n\n/**\r\n * Converts the first character of a string to uppercase and the rest to lowercase.\r\n * @param {string} value - The string to convert.\r\n * @returns {string} - The converted string with the first character in uppercase and the rest in lowercase.\r\n */\nexport function turnSentenceCase(value) {\n  if (typeof value !== 'string' || value.trim().length === 0) {\n    return GlobalVariables.EMPTY_STRING;\n  }\n  const trimmedValue = value.trim();\n  return trimmedValue.charAt(0).toUpperCase() + trimmedValue.slice(1).toLowerCase();\n}\n\n/**\r\n * Disables castling rights if the king or a rook moves.\r\n * @param {object} square - The square containing the piece that moved.\r\n */\nexport function disableCastlingIfKingOrRookMoves(square) {\n  const color = getPieceColor(square);\n  const piece = getPiece(square);\n  const isWhite = isColorWhite(color);\n  const updateCastlingRights = (color, type, value) => {\n    const castle = 'Castle';\n    const normalizedType = turnSentenceCase(type);\n    GlobalVariables.CastlingRights[`${color}${normalizedType}${castle}`] = value;\n  };\n  if (piece === GlobalVariables.PIECES.KING) {\n    const castleColor = isWhite ? GlobalVariables.COLORS.WHITE : GlobalVariables.COLORS.BLACK;\n    updateCastlingRights(castleColor, GlobalVariables.CASTLING_TYPES.LONG, false);\n    updateCastlingRights(castleColor, GlobalVariables.CASTLING_TYPES.SHORT, false);\n  }\n  if (piece === GlobalVariables.PIECES.ROOK) {\n    const {\n      x,\n      y\n    } = square.props;\n    const isRookInStartingPosition = (row, col, type, color) => {\n      return x === row && y === col && updateCastlingRights(color, type, false);\n    };\n    isRookInStartingPosition(GlobalVariables.CASTLE_ROW_WHITE, GlobalVariables.CASTLE_ROOK_INITIAL_COL_SHORT, GlobalVariables.CASTLING_TYPES.SHORT, GlobalVariables.COLORS.WHITE);\n    isRookInStartingPosition(GlobalVariables.CASTLE_ROW_BLACK, GlobalVariables.CASTLE_ROOK_INITIAL_COL_SHORT, GlobalVariables.CASTLING_TYPES.SHORT, GlobalVariables.COLORS.BLACK);\n    isRookInStartingPosition(GlobalVariables.CASTLE_ROW_WHITE, GlobalVariables.CASTLE_ROOK_INITIAL_COL_LONG, GlobalVariables.CASTLING_TYPES.LONG, GlobalVariables.COLORS.WHITE);\n    isRookInStartingPosition(GlobalVariables.CASTLE_ROW_BLACK, GlobalVariables.CASTLE_ROOK_INITIAL_COL_LONG, GlobalVariables.CASTLING_TYPES.LONG, GlobalVariables.COLORS.BLACK);\n  }\n}\n\n/**\r\n * Enables or disables en passant based on the move.\r\n * @param {object} square - The square containing the piece that moved.\r\n * @param {object} targetSquare - The square to which the piece is moving.\r\n */\nexport function enableEnPassant(square, targetSquare) {\n  const color = getPieceColor(square);\n  const isWhite = isColorWhite(color);\n  const offset = isWhite ? -1 : 1;\n  const isThePieceAPawn = isPawn(square);\n  const isTwoSquareMove = Math.abs(square.props.x - targetSquare.props.x) === 2;\n  const updateEnPassant = (isPossible, x, y) => {\n    GlobalVariables.EnPassant.isPossible = isPossible;\n    GlobalVariables.EnPassant.x = x;\n    GlobalVariables.EnPassant.y = y;\n  };\n  if (isThePieceAPawn && isTwoSquareMove) {\n    updateEnPassant(true, square.props.x + offset, square.props.y);\n  } else {\n    updateEnPassant(false, -1, -1);\n  }\n}\n\n/**\r\n * Checks if there are any pawns that can capture en passant from the given square.\r\n *\r\n * This function checks the neighboring squares to the left and right of the given square\r\n * to see if they contain pawns of the opposite color that can potentially capture en passant.\r\n *\r\n * @param {object} square - The square to check from.\r\n * @param {array} squares - The array representing the board squares.\r\n * @returns {boolean} - True if there is at least one pawn that can capture en passant, false otherwise.\r\n */\nexport function areTherePawnsThatCanCaptureEnPassant(square, squares) {\n  const neighborsOffset = [1, -1];\n  const checkNeighbor = n => {\n    const x = square.props.x;\n    const y = square.props.y + n;\n\n    // Check if the coordinates are within bounds\n    if (!areCoordinatesInBounds(x, y)) {\n      return false;\n    }\n    const piece = getATargetSquareByLocation(x, y, squares);\n\n    // Check if the neighboring piece is a pawn and of the opposite color\n    const isThePieceAPawn = isPawn(piece);\n    const areTheyDifferentColor = !areSameColor(square, piece);\n    return isThePieceAPawn && areTheyDifferentColor;\n  };\n\n  // Return true if any neighboring square contains a pawn that can capture en passant\n  return neighborsOffset.some(n => checkNeighbor(n));\n}\n\n/**\r\n * Handles the en passant capture logic.\r\n * \r\n * This function updates the board position if an en passant capture is possible. \r\n * It checks if there are pawns that can perform an en passant capture, updates the \r\n * board position accordingly, and inverts the piece color for the en passant capture.\r\n * \r\n * @param {object} square - The square containing the piece that moved.\r\n * @param {object} targetSquare - The square to which the piece is moving.\r\n * @param {array} position - The current board position.\r\n * @param {array} squares - The array representing the board squares.\r\n * @returns {array} - The updated board position after en passant capture.\r\n */\nexport function captureEnPassant(square, targetSquare, position, squares) {\n  const color = getPieceColor(square);\n  const isWhite = isColorWhite(color);\n  const offset = isWhite ? 1 : -1;\n  const {\n    isPossible\n  } = GlobalVariables.EnPassant;\n  const enPassantTargetSquare = getATargetSquareByLocation(targetSquare.props.x + offset, targetSquare.props.y, squares);\n  if (!compareIfTwoSquaresAreTheSame(targetSquare, enPassantTargetSquare)) {\n    return position;\n  }\n  if (isPossible && areTherePawnsThatCanCaptureEnPassant(square, squares)) {\n    if (enPassantTargetSquare) {\n      // Perform en passant capture\n      position = updateBoardPosition(square, enPassantTargetSquare);\n      // Invert the color of the piece being captured\n      const pseudoSquare = /*#__PURE__*/_jsxDEV(Square, {\n        x: enPassantTargetSquare.props.x,\n        y: enPassantTargetSquare.props.y,\n        piece: invertPieceColor(enPassantTargetSquare.props.piece)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 969,\n        columnNumber: 34\n      }, this);\n      // Update the board position again after inverting the piece color\n      position = updateBoardPosition(pseudoSquare, targetSquare);\n    }\n  }\n  return position;\n}\n\n/**\r\n * Inverts the color of a piece.\r\n * \r\n * @param {string} pseudo - The pseudo representation of the piece in {color-piece} format.\r\n * @returns {string} - The piece with inverted color.\r\n */\nfunction invertPieceColor(pseudo) {\n  const [color, piece] = pseudo.split(GlobalVariables.PIECE_DELIMITER);\n  const newColor = isColorWhite(color) ? GlobalVariables.COLORS.BLACK : GlobalVariables.COLORS.WHITE;\n  return `${newColor}${GlobalVariables.PIECE_DELIMITER}${piece}`;\n}\n\n/**\r\n * Updates the global board state with the new position.\r\n * @param {Array} updatedPosition - The updated board position after the move.\r\n */\nexport function updateBoardState(updatedPosition) {\n  const newPosition = updatedPosition.map(row => [...row]);\n  GlobalVariables.BoardPosition.splice(0, GlobalVariables.BoardPosition.length, ...newPosition);\n}\n\n/**\r\n * Updates the move counters for the game.\r\n */\nexport function updateMoveCounters() {\n  GlobalVariables.updateFullMoves(GlobalVariables.FullMoves + 1);\n}\n\n/**\r\n * Resets the possible moves array and toggles the player's turn.\r\n */\nexport function resetPossibleMovesAndToggleTurn() {\n  GlobalVariables.PossibleMoves.splice(0, GlobalVariables.PossibleMoves.length);\n  GlobalVariables.updateIsWhiteToMove(!GlobalVariables.IsWhiteToMove);\n}\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9;\n$RefreshReg$(_c, \"IsUpperCase\");\n$RefreshReg$(_c2, \"IsLowerCase\");\n$RefreshReg$(_c3, \"IsDigit\");\n$RefreshReg$(_c4, \"ParseFEN\");\n$RefreshReg$(_c5, \"ConvertFENtoPiece\");\n$RefreshReg$(_c6, \"ConvertFENPieceToPiece\");\n$RefreshReg$(_c7, \"ConvertFenToString\");\n$RefreshReg$(_c8, \"SidewaysCapture\");\n$RefreshReg$(_c9, \"ConvertPieceToFENPiece\");","map":{"version":3,"names":["React","Square","GlobalVariables","jsxDEV","_jsxDEV","getPiece","square","props","piece","split","PIECE_DELIMITER","PIECE_PIECE_INDEX","doesTheSquareHasThePiece","isKing","PIECES","KING","isBishop","BISHOP","isQueen","QUEEN","isRook","ROOK","isPawn","PAWN","isKnight","KNIGHT","IsUpperCase","value","firstChar","getFirstCharacter","ASCII_UPPERCASE_A","ASCII_UPPERCASE_Z","_c","charCodeAt","IsLowerCase","ASCII_LOWERCASE_A","ASCII_LOWERCASE_Z","_c2","IsDigit","ASCII_DIGIT_0","ASCII_DIGIT_9","_c3","ParseFEN","fen","fenParts","EMPTY_SPACE","length","FEN_VALID_PARTS_NUMBER","Error","fenBoard","fenTurn","fenCastling","fenEnPassant","fenHalfMoves","fenFullMoves","Number","_c4","ConvertFENtoPiece","letter","FEN_PIECE_MAP","FEN_PIECES_BLACK","toLowerCase","EMPTY_STRING","_c5","ConvertFENPieceToPiece","COLORS","WHITE","BLACK","_c6","ConvertFenToString","reduce","result","char","EMPTY_SQUARE_PIECE","repeat","_c7","checkIfTwoSquaresAreOnTheSameRow","square1","square2","x","checkIfTwoSquaresAreOnTheSameColumn","y","isSquareOnRow","rowNumber","isSquareOnColumn","columnNumber","getPieceColor","PIECE_COLOR_INDEX","isColorWhite","color","isColorBlack","areSameColor","piece1","piece2","checkIfAMoveIsEqualToTheCurrentSelectedSquare","move","CurrentSquareSelection","compareIfTwoSquaresAreTheSame","getATargetSquareByLocation","squares","find","s","getATargetSquareByPiece","isCastlingPossible","castlingType","withWhite","row","CASTLE_ROW_WHITE","CASTLE_ROW_BLACK","pieces","FEN_PIECES_WHITE","rookCol","kingCol","pathCols","CASTLING_TYPES","LONG","CASTLE_ROOK_INITIAL_COL_LONG","CASTLE_KING_INITIAL_COL","CASTLE_PATH_COLS_LONG","CASTLE_ROOK_INITIAL_COL_SHORT","CASTLE_PATH_COLS_SHORT","BoardPosition","every","col","isPawnOnStartingSquare","pawn","isWhite","WHITE_PAWN_STARTING_SQUARE","BLACK_PAWN_STARTING_SQUARE","isPawnOnEnPassantSquare","WHITE_EN_PASSANT_SQUARE","BLACK_EN_PASSANT_SQUARE","isSquareAvailable","updateColumnOnARow","colIndex","newValue","handleSquareOnCurrentRow","currentSquare","targetSquare","handleSquareAndTargetSquareOnTheSameRow","handleTargetSquareOnCurrentRow","ConvertPieceToFENPiece","canWeCastle","Object","values","CastlingRights","some","Math","abs","handleCastling","SidewaysCapture","kingPiece","rookPiece","forEach","type","emptySquares","kingFinalCol","rookFinalCol","EMPTY_SQUARES_AFTER_LONG_CASTLE","CASTLE_KING_FINAL_COL_LONG","CASTLE_ROOK_FINAL_COL_LONG","EMPTY_SQUARES_AFTER_SHORT_CASTLE","CASTLE_KING_FINAL_COL_SHORT","CASTLE_ROOK_FINAL_COL_SHORT","convertRowToFEN","acc","column","lastChar","slice","getCastlingRules","sortedKeys","getSortedCastlingKeys","castlingMap","map","key","join","generateANewFen","fenRows","FEN_BOARD_DELIMITER","turn","IsWhiteToMove","FEN_COLOR","castling","enPassant","EnPassant","isPossible","convertLocationToCoordinates","halfMoves","HalfMoves","fullMoves","FullMoves","keys","sort","updateCastlingRights","includes","updateEnPassant","convertCoordinatesToLocation","assign","areCoordinatesInBounds","DIM","fenParser","isPossibleMove","getPossibleMoves","movePiece","resetPossibleMoves","updateBoardPosition","boardArray","generateSquareComponents","updateIsWhiteToMove","updateHalfMoves","updateFullMoves","splice","rowIndex","targetColIndex","index","_c8","pieceMapping","fenPiece","toUpperCase","_c9","boardSquares","squareColorIsWhite","flatMap","rowSquares","DARK_SQUARES_COLOR","possibleMoveStatus","item","squareComponent","fileName","_jsxFileName","lineNumber","coordinates","tokens","toString","number","String","fromCharCode","isKingInCheck","kingSquare","knightMoves","linearDirections","diagonalDirections","checkDirections","directions","isInCheck","dx","dy","piecesTypes","i","pieceColor","pieceType","isMoveLegal","currentPiece","targetLocation","updatedSquares","cloneElement","king","turnSentenceCase","trim","trimmedValue","charAt","disableCastlingIfKingOrRookMoves","castle","normalizedType","castleColor","SHORT","isRookInStartingPosition","enableEnPassant","offset","isThePieceAPawn","isTwoSquareMove","areTherePawnsThatCanCaptureEnPassant","neighborsOffset","checkNeighbor","n","areTheyDifferentColor","captureEnPassant","position","enPassantTargetSquare","pseudoSquare","invertPieceColor","pseudo","newColor","updateBoardState","updatedPosition","newPosition","updateMoveCounters","resetPossibleMovesAndToggleTurn","PossibleMoves","$RefreshReg$"],"sources":["C:/Users/Vladi Gotsin/Desktop/react/Chess-React.js-/src/HelperMethods.js"],"sourcesContent":["import React from 'react';\r\nimport Square from \"./Square.js\"\r\nimport * as GlobalVariables from './globalVariables';\r\n\r\n/**\r\n * Gets the piece from a square.\r\n * @param {object} square - The square to get the piece from.\r\n * @returns {string} - The piece.\r\n */\r\nexport function getPiece(square) {\r\n    return square.props.piece.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_PIECE_INDEX];\r\n}\r\n\r\n/**\r\n * Checks if a square has a specific piece.\r\n * @param {object} square - The square to check.\r\n * @param {string} piece - The piece to check for.\r\n * @returns {boolean} - True if the square has the piece, false otherwise.\r\n */\r\nexport function doesTheSquareHasThePiece(square, piece) {\r\n    return getPiece(square) === piece;\r\n}\r\n\r\n/**\r\n * Checks if the piece on the square is a King.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the piece is a King, false otherwise.\r\n */\r\nexport function isKing(square) {\r\n    return doesTheSquareHasThePiece(square, GlobalVariables.PIECES.KING);\r\n}\r\n\r\n/**\r\n * Checks if the piece on the square is a Bishop.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the piece is a Bishop, false otherwise.\r\n */\r\nexport function isBishop(square) {\r\n    return doesTheSquareHasThePiece(square, GlobalVariables.PIECES.BISHOP);\r\n}\r\n\r\n/**\r\n * Checks if the piece on the square is a Queen.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the piece is a Queen, false otherwise.\r\n */\r\nexport function isQueen(square) {\r\n    return doesTheSquareHasThePiece(square, GlobalVariables.PIECES.QUEEN);\r\n}\r\n\r\n/**\r\n * Checks if the piece on the square is a Rook.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the piece is a Rook, false otherwise.\r\n */\r\nexport function isRook(square) {\r\n    return doesTheSquareHasThePiece(square, GlobalVariables.PIECES.ROOK);\r\n}\r\n\r\n/**\r\n * Checks if the piece on the square is a Pawn.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the piece is a Pawn, false otherwise.\r\n */\r\nexport function isPawn(square) {\r\n    return doesTheSquareHasThePiece(square, GlobalVariables.PIECES.PAWN);\r\n}\r\n\r\n/**\r\n * Checks if the piece on the square is a Knight.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the piece is a Knight, false otherwise.\r\n */\r\nexport function isKnight(square) {\r\n    return doesTheSquareHasThePiece(square, GlobalVariables.PIECES.KNIGHT);\r\n}\r\n\r\n/**\r\n * Checks if a character is Uppercase using the ASCII table.\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is uppercase, false otherwise.\r\n */\r\nexport function IsUpperCase(value) {\r\n    const firstChar = getFirstCharacter(value)\r\n    return firstChar >= GlobalVariables.ASCII_UPPERCASE_A && firstChar <= GlobalVariables.ASCII_UPPERCASE_Z;\r\n}\r\n\r\n/**\r\n * Returns the ASCII code of the first character of a string.\r\n * @param {string} value - The string from which to get the ASCII code.\r\n * @returns {number} - The ASCII code of the first character.\r\n */\r\nexport function getFirstCharacter(value) {\r\n    return value.charCodeAt(0);\r\n}\r\n\r\n/**\r\n * Checks if a character is Lowercase using the ASCII table.\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is lowercase, false otherwise.\r\n */\r\nexport function IsLowerCase(value) {\r\n    const firstChar = getFirstCharacter(value)\r\n    return firstChar >= GlobalVariables.ASCII_LOWERCASE_A && firstChar <= GlobalVariables.ASCII_LOWERCASE_Z;\r\n}\r\n\r\n/**\r\n * Checks if a character is a Digit using the ASCII table.\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is a digit, false otherwise.\r\n */\r\nexport function IsDigit(value) {\r\n    const firstChar = getFirstCharacter(value)\r\n    return firstChar >= GlobalVariables.ASCII_DIGIT_0 && firstChar <= GlobalVariables.ASCII_DIGIT_9;\r\n}\r\n\r\n/**\r\n * Parses a FEN string and returns its components.\r\n * @param {string} fen - The FEN string to parse.\r\n * @returns {object} - An object containing the FEN components.\r\n */\r\nexport function ParseFEN(fen) {\r\n    const fenParts = fen.split(GlobalVariables.EMPTY_SPACE);\r\n    if (fenParts.length !== GlobalVariables.FEN_VALID_PARTS_NUMBER) {\r\n        throw new Error('Invalid FEN');\r\n    }\r\n    const [fenBoard, fenTurn, fenCastling, fenEnPassant, fenHalfMoves, fenFullMoves] = fenParts;\r\n    return {\r\n        fenBoard,\r\n        fenTurn,\r\n        fenCastling,\r\n        fenEnPassant,\r\n        fenHalfMoves: Number(fenHalfMoves),\r\n        fenFullMoves: Number(fenFullMoves)\r\n    };\r\n}\r\n\r\n/**\r\n * Converts FEN piece notation to an actual piece.\r\n * @param {string} letter - The FEN notation of the piece.\r\n * @returns {string} - The actual piece.\r\n */\r\nexport function ConvertFENtoPiece(letter) {\r\n    const FEN_PIECE_MAP = {\r\n        [GlobalVariables.FEN_PIECES_BLACK.PAWN]: GlobalVariables.PIECES.PAWN,\r\n        [GlobalVariables.FEN_PIECES_BLACK.KNIGHT]: GlobalVariables.PIECES.KNIGHT,\r\n        [GlobalVariables.FEN_PIECES_BLACK.KING]: GlobalVariables.PIECES.KING,\r\n        [GlobalVariables.FEN_PIECES_BLACK.QUEEN]: GlobalVariables.PIECES.QUEEN,\r\n        [GlobalVariables.FEN_PIECES_BLACK.ROOK]: GlobalVariables.PIECES.ROOK,\r\n        [GlobalVariables.FEN_PIECES_BLACK.BISHOP]: GlobalVariables.PIECES.BISHOP,\r\n    };\r\n\r\n    return FEN_PIECE_MAP[letter.toLowerCase()] || GlobalVariables.EMPTY_STRING;\r\n}\r\n\r\n/**\r\n * Converts the FEN piece notation to a piece that we can use in the square component.\r\n * @param {string} value - The FEN notation of the piece.\r\n * @returns {string} - The piece in {color-piece} format.\r\n */\r\nexport function ConvertFENPieceToPiece(value) {\r\n    if (IsUpperCase(value)) {\r\n        return `${GlobalVariables.COLORS.WHITE}${GlobalVariables.PIECE_DELIMITER}${ConvertFENtoPiece(value)}`;\r\n    }\r\n\r\n    if (IsLowerCase(value)) {\r\n        return `${GlobalVariables.COLORS.BLACK}${GlobalVariables.PIECE_DELIMITER}${ConvertFENtoPiece(value)}`;\r\n    }\r\n\r\n    return GlobalVariables.EMPTY_STRING;\r\n}\r\n\r\n/**\r\n * Converts a string in FEN format to a normal string.\r\n * @param {string} value - The FEN string.\r\n * @returns {string} - The normal string.\r\n */\r\nexport function ConvertFenToString(value) {\r\n    return value.split(GlobalVariables.EMPTY_STRING).reduce((result, char) => {\r\n        if (IsDigit(char)) {\r\n            return result + GlobalVariables.EMPTY_SQUARE_PIECE.repeat(Number(char));\r\n        }\r\n        return result + char;\r\n    }, GlobalVariables.EMPTY_STRING);\r\n}\r\n\r\n/**\r\n * Checks if two squares are on the same row.\r\n * @param {object} square1 - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if the squares are on the same row, false otherwise.\r\n */\r\nexport function checkIfTwoSquaresAreOnTheSameRow(square1, square2) {\r\n    return square1.props.x === square2.props.x;\r\n}\r\n\r\n/**\r\n * Checks if two squares are on the same column.\r\n * @param {object} square1 - The first square to check.\r\n * @param {object} square2 - The second square to check.\r\n * @returns {boolean} - True if both squares are on the same column, false otherwise.\r\n */\r\nexport function checkIfTwoSquaresAreOnTheSameColumn(square1, square2) {\r\n    return square1.props.y === square2.props.y;\r\n}\r\n\r\n/**\r\n * Checks if the square is on the given row number.\r\n * @param {object} square - The square to check.\r\n * @param {number} rowNumber - The row number.\r\n * @returns {boolean} - True if the square is on the given row, false otherwise.\r\n */\r\nexport function isSquareOnRow(square, rowNumber) {\r\n    return square.props.x === rowNumber;\r\n}\r\n\r\n/**\r\n * Checks if the square is on the given column number.\r\n * @param {object} square - The square to check.\r\n * @param {number} columnNumber - The column number.\r\n * @returns {boolean} - True if the square is on the given column, false otherwise.\r\n */\r\nexport function isSquareOnColumn(square, columnNumber) {\r\n    return square.props.y === columnNumber;\r\n}\r\n\r\n/**\r\n * Gets the piece color from a square.\r\n * @param {object} square - The square to get the piece color from.\r\n * @returns {string} - The piece color.\r\n */\r\nexport function getPieceColor(square) {\r\n    return square.props.piece.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_COLOR_INDEX];\r\n}\r\n\r\n/**\r\n * Checks if a color is white.\r\n * @param {string} color - The color to check.\r\n * @returns {boolean} - True if the color is white, false otherwise.\r\n */\r\nexport function isColorWhite(color) {\r\n    return color === GlobalVariables.COLORS.WHITE;\r\n}\r\n\r\n/**\r\n * Checks if a color is black.\r\n * @param {string} color - The color to check.\r\n * @returns {boolean} - True if the color is black, false otherwise.\r\n */\r\nexport function isColorBlack(color) {\r\n    return color === GlobalVariables.COLORS.BLACK;\r\n}\r\n\r\n/**\r\n * Checks if two pieces are of the same color.\r\n * @param {string} piece1 - The first piece.\r\n * @param {string} piece2 - The second piece.\r\n * @returns {boolean} - True if the pieces are of the same color, false otherwise.\r\n */\r\nexport function areSameColor(piece1, piece2) {\r\n    return getPieceColor(piece1) === getPieceColor(piece2);\r\n}\r\n\r\n/**\r\n * Checks if a move is equal to the current selected square.\r\n * @param {object} move - The move to check.\r\n * @returns {boolean} - True if the move is equal to the current selected square, false otherwise.\r\n */\r\nexport function checkIfAMoveIsEqualToTheCurrentSelectedSquare(move) {\r\n    return isSquareOnRow(move, GlobalVariables.CurrentSquareSelection.x) && isSquareOnColumn(move, GlobalVariables.CurrentSquareSelection.y)\r\n}\r\n\r\n/**\r\n * Compares if two squares are the same.\r\n * @param {object} square1 - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if the squares are the same, false otherwise.\r\n */\r\nexport function compareIfTwoSquaresAreTheSame(square1, square2) {\r\n    if (square1 || square2) return false\r\n    return checkIfTwoSquaresAreOnTheSameRow(square1, square2) && checkIfTwoSquaresAreOnTheSameColumn(square1, square2);\r\n}\r\n\r\n/**\r\n * Gets a target square by its location.\r\n * @param {number} x - The x coordinate of the target square.\r\n * @param {number} y - The y coordinate of the target square.\r\n * @param {array} squares - The board squares array.\r\n * @returns {object} - The target square.\r\n */\r\nexport function getATargetSquareByLocation(x, y, squares) {\r\n    return squares.find(s => isSquareOnRow(s, x) && isSquareOnColumn(s, y))\r\n}\r\n\r\n/**\r\n * Gets a target square by its piece.\r\n * @param {string} piece - The piece to search for.\r\n * @param {array} squares - The board squares array.\r\n * @returns {object} - The target square.\r\n */\r\nexport function getATargetSquareByPiece(piece, squares) {\r\n    return squares.find(s => s.props.piece == piece)\r\n}\r\n\r\n/**\r\n * Checks if castling is possible.\r\n * @param {string} castlingType - The type of castling (long or short).\r\n * @param {boolean} [withWhite=true] - True if checking for white's castling, false otherwise.\r\n * @returns {boolean} - True if castling is possible, false otherwise.\r\n */\r\nexport function isCastlingPossible(castlingType, withWhite = true) {\r\n    const row = withWhite ? GlobalVariables.CASTLE_ROW_WHITE : GlobalVariables.CASTLE_ROW_BLACK;\r\n    const pieces = withWhite ? GlobalVariables.FEN_PIECES_WHITE : GlobalVariables.FEN_PIECES_BLACK;\r\n    const [rookCol, kingCol, pathCols] = castlingType === GlobalVariables.CASTLING_TYPES.LONG ?\r\n        [GlobalVariables.CASTLE_ROOK_INITIAL_COL_LONG, GlobalVariables.CASTLE_KING_INITIAL_COL, GlobalVariables.CASTLE_PATH_COLS_LONG] :\r\n        [GlobalVariables.CASTLE_ROOK_INITIAL_COL_SHORT, GlobalVariables.CASTLE_KING_INITIAL_COL, GlobalVariables.CASTLE_PATH_COLS_SHORT];\r\n\r\n    return GlobalVariables.BoardPosition[row][rookCol] === pieces.ROOK &&\r\n        GlobalVariables.BoardPosition[row][kingCol] === pieces.KING &&\r\n        pathCols.every(col => GlobalVariables.BoardPosition[row][col] === GlobalVariables.EMPTY_SQUARE_PIECE);\r\n}\r\n\r\n/**\r\n * Checks if a pawn is on its starting square.\r\n * @param {object} pawn - The pawn to check.\r\n * @returns {boolean} - True if the pawn is on its starting square, false otherwise.\r\n */\r\nexport function isPawnOnStartingSquare(pawn) {\r\n    const isWhite = isColorWhite(getPieceColor(pawn));\r\n    return isWhite ? isSquareOnRow(pawn, GlobalVariables.WHITE_PAWN_STARTING_SQUARE) : isSquareOnRow(pawn, GlobalVariables.BLACK_PAWN_STARTING_SQUARE);\r\n}\r\n\r\n/**\r\n * Checks if a pawn is on an en passant square.\r\n * @param {object} pawn - The pawn to check.\r\n * @returns {boolean} - True if the pawn is on an en passant square, false otherwise.\r\n */\r\nexport function isPawnOnEnPassantSquare(pawn) {\r\n    const isWhite = isColorWhite(getPieceColor(pawn));\r\n    return isWhite ? isSquareOnRow(pawn, GlobalVariables.WHITE_EN_PASSANT_SQUARE) : isSquareOnRow(pawn, GlobalVariables.BLACK_EN_PASSANT_SQUARE);\r\n}\r\n\r\n/**\r\n * Checks if a square is available for a move.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the square is available, false otherwise.\r\n */\r\nexport function isSquareAvailable(square) {\r\n    return !square.props.piece;\r\n}\r\n\r\n/**\r\n * Updates a column on a row with a new value.\r\n * @param {Array} row - The row to update.\r\n * @param {number} colIndex - The column index.\r\n * @param {string} newValue - The new value.\r\n * @returns {Array} - The updated row.\r\n */\r\nexport function updateColumnOnARow(row, colIndex, newValue) {\r\n    row[colIndex] = newValue;\r\n    return row;\r\n}\r\n\r\n/**\r\n * Removes the current square's piece.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\r\nexport function handleSquareOnCurrentRow(currentSquare, targetSquare, row) {\r\n    return checkIfTwoSquaresAreOnTheSameRow(currentSquare, targetSquare) ?\r\n        handleSquareAndTargetSquareOnTheSameRow(currentSquare, targetSquare, row) :\r\n        updateColumnOnARow(row, currentSquare.props.y, GlobalVariables.EMPTY_SQUARE_PIECE);\r\n}\r\n\r\n/**\r\n * Updates the target square with the current square's piece.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\r\nexport function handleTargetSquareOnCurrentRow(currentSquare, targetSquare, row) {\r\n    return updateColumnOnARow(row, targetSquare.props.y, ConvertPieceToFENPiece(currentSquare.props.piece));\r\n}\r\n\r\n/**\r\n * Checks if castling is possible for either side.\r\n * @returns {boolean} - True if castling is possible for either side, false otherwise.\r\n */\r\nexport function canWeCastle() {\r\n    return Object.values(GlobalVariables.CastlingRights).some(s => s);\r\n}\r\n\r\n/**\r\n * Checks if we're making a move on the same row and performs castling if we want to castle.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\r\nexport function handleSquareAndTargetSquareOnTheSameRow(currentSquare, targetSquare, row) {\r\n    if (isKing(currentSquare) && canWeCastle() && Math.abs(currentSquare.props.y - targetSquare.props.y) == 2) {\r\n        return handleCastling(currentSquare, row);\r\n    }\r\n    return SidewaysCapture(row, Number(currentSquare.props.y), Number(targetSquare.props.y), currentSquare.props.piece);\r\n}\r\n\r\n/**\r\n * Performs castling by swapping the rook and the king.\r\n * @param {object} square - The square to update.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\r\nexport function handleCastling(square, row) {\r\n    const color = getPieceColor(square);\r\n    const isWhite = isColorWhite(color);\r\n    const kingPiece = isWhite ? GlobalVariables.FEN_PIECES_WHITE.KING : GlobalVariables.FEN_PIECES_BLACK.KING;\r\n    const rookPiece = isWhite ? GlobalVariables.FEN_PIECES_WHITE.ROOK : GlobalVariables.FEN_PIECES_BLACK.ROOK;\r\n\r\n    Object.values(GlobalVariables.CASTLING_TYPES).forEach(type => {\r\n        if (isCastlingPossible(type, isWhite)) {\r\n            const [emptySquares, kingFinalCol, rookFinalCol] = type === GlobalVariables.CASTLING_TYPES.LONG ?\r\n                [GlobalVariables.EMPTY_SQUARES_AFTER_LONG_CASTLE, GlobalVariables.CASTLE_KING_FINAL_COL_LONG, GlobalVariables.CASTLE_ROOK_FINAL_COL_LONG] :\r\n                [GlobalVariables.EMPTY_SQUARES_AFTER_SHORT_CASTLE, GlobalVariables.CASTLE_KING_FINAL_COL_SHORT, GlobalVariables.CASTLE_ROOK_FINAL_COL_SHORT];\r\n            emptySquares.forEach(col => row[col] = GlobalVariables.EMPTY_SQUARE_PIECE);\r\n            row[kingFinalCol] = kingPiece;\r\n            row[rookFinalCol] = rookPiece;\r\n        }\r\n    });\r\n\r\n    return row;\r\n}\r\n\r\n/**\r\n * Converts a row of squares to its FEN representation.\r\n * @param {Array} row - The row to convert.\r\n * @returns {string} - The FEN representation of the row.\r\n */\r\nexport function convertRowToFEN(row) {\r\n    return row.reduce((acc, column) => {\r\n        if (column === GlobalVariables.EMPTY_SQUARE_PIECE) {\r\n            const lastChar = acc.slice(-1);\r\n            if (IsDigit(lastChar)) {\r\n                return acc.slice(0, -1) + (Number(lastChar) + 1); //add 1 to the previous number if an empty space\r\n            } else {\r\n                return acc + '1'; //set the next piece as 1 (1 empty space)\r\n            }\r\n        } else {\r\n            return acc + column; //return the piece if no empty spaces\r\n        }\r\n    }, GlobalVariables.EMPTY_STRING);\r\n}\r\n\r\n/**\r\n * Gets the castling rules as a string.\r\n * @returns {string} - The castling rules.\r\n */\r\nexport function getCastlingRules() {\r\n    const sortedKeys = getSortedCastlingKeys();\r\n\r\n    const castlingMap = {\r\n        [sortedKeys[0]]: GlobalVariables.FEN_PIECES_BLACK.QUEEN, // 'blackLongCastle'\r\n        [sortedKeys[1]]: GlobalVariables.FEN_PIECES_BLACK.KING, // 'blackShortCastle'\r\n        [sortedKeys[2]]: GlobalVariables.FEN_PIECES_WHITE.QUEEN, // 'whiteLongCastle'\r\n        [sortedKeys[3]]: GlobalVariables.FEN_PIECES_WHITE.KING  // 'whiteShortCastle'\r\n    };\r\n\r\n    return sortedKeys.map(key => GlobalVariables.CastlingRights[key] ? castlingMap[key] :\r\n        GlobalVariables.EMPTY_STRING).join(GlobalVariables.EMPTY_STRING) || GlobalVariables.PIECE_DELIMITER\r\n}\r\n\r\n/**\r\n * Generates a new FEN string based on the current board state.\r\n * @returns {string} - The new FEN string.\r\n */\r\nexport function generateANewFen() {\r\n    const fenRows = GlobalVariables.BoardPosition.map(row => convertRowToFEN(row)).join(GlobalVariables.FEN_BOARD_DELIMITER);\r\n    const turn = GlobalVariables.IsWhiteToMove ? GlobalVariables.FEN_COLOR.WHITE : GlobalVariables.FEN_COLOR.BLACK;\r\n    const castling = getCastlingRules();\r\n    const enPassant = GlobalVariables.EnPassant.isPossible\r\n        ? convertLocationToCoordinates(GlobalVariables.EnPassant.x, GlobalVariables.EnPassant.y)\r\n        : GlobalVariables.PIECE_DELIMITER;\r\n    const halfMoves = GlobalVariables.HalfMoves;\r\n    const fullMoves = GlobalVariables.FullMoves;\r\n\r\n    return `${fenRows} ${turn} ${castling} ${enPassant} ${halfMoves} ${fullMoves}`;\r\n}\r\n\r\n/**\r\n * Returns the keys of the CastlingRights object in alphabetical order.\r\n * @returns {Array<string>} - The sorted keys of CastlingRights.\r\n */\r\nexport function getSortedCastlingKeys() {\r\n    return Object.keys(GlobalVariables.CastlingRights).sort();\r\n}\r\n\r\n/**\r\n * Updates castling rights based on the given castling string.\r\n * @param {string} castling - The castling rights string (e.g., 'KQkq').\r\n */\r\nexport function updateCastlingRights(castling) {\r\n    const sortedKeys = getSortedCastlingKeys();\r\n\r\n    // Create a map based on the sorted keys to ensure consistency\r\n    const castlingMap = {\r\n        [GlobalVariables.FEN_PIECES_BLACK.QUEEN]: sortedKeys[0], // 'blackLongCastle'\r\n        [GlobalVariables.FEN_PIECES_BLACK.KING]: sortedKeys[1], // 'blackShortCastle'\r\n        [GlobalVariables.FEN_PIECES_WHITE.QUEEN]: sortedKeys[2], // 'whiteLongCastle'\r\n        [GlobalVariables.FEN_PIECES_WHITE.KING]: sortedKeys[3]  // 'whiteShortCastle'\r\n    };\r\n\r\n    // Update castling rights using the castling map\r\n    Object.keys(castlingMap).forEach(key => {\r\n        GlobalVariables.CastlingRights[castlingMap[key]] = castling.includes(key);\r\n    });\r\n}\r\n\r\n/**\r\n * Updates en passant status based on the given en passant string.\r\n * @param {string} enPassant - The en passant target square (e.g., 'e3') or '-' if not available.\r\n */\r\nexport function updateEnPassant(enPassant) {\r\n    if (enPassant !== GlobalVariables.PIECE_DELIMITER) {\r\n        const { x, y } = convertCoordinatesToLocation(enPassant);\r\n        Object.assign(GlobalVariables.EnPassant, {\r\n            isPossible: true,\r\n            x: x,\r\n            y: y\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if the given coordinates are within the bounds of the chessboard.\r\n *\r\n * This function ensures that the coordinates (x, y) fall within the valid range\r\n * of the chessboard dimensions. It returns true if both x and y are greater than\r\n * or equal to 0 and less than the board dimension (DIM). This is useful for \r\n * validating moves and ensuring that they do not exceed the boundaries of the board.\r\n *\r\n * @param {number} x - The x-coordinate to check.\r\n * @param {number} y - The y-coordinate to check.\r\n * @returns {boolean} - True if the coordinates are within the bounds of the board, false otherwise.\r\n */\r\nexport function areCoordinatesInBounds(x, y) {\r\n    return x >= 0 && y >= 0 && x < GlobalVariables.DIM && y < GlobalVariables.DIM\r\n}\r\n\r\n/**\r\n * Parses the FEN string to update the board state.\r\n * @param {string} fen - The FEN string representing the board state.\r\n * @param {Array} isPossibleMove - Array indicating possible moves.\r\n * @param {function} getPossibleMoves - Function to get possible moves.\r\n * @param {function} movePiece - Function to move a piece.\r\n * @param {function} resetPossibleMoves - Function to reset possible moves.\r\n * @param {boolean} [updateBoardPosition=true] - Whether to update the board position.\r\n * @returns {Array} - The generated square components.\r\n */\r\nexport function fenParser(fen, isPossibleMove, getPossibleMoves, movePiece, resetPossibleMoves, updateBoardPosition = true) {\r\n    const {\r\n        fenBoard,\r\n        fenTurn,\r\n        fenCastling,\r\n        fenEnPassant,\r\n        fenHalfMoves,\r\n        fenFullMoves\r\n    } = ParseFEN(fen);\r\n\r\n    const fenRows = fenBoard.split(GlobalVariables.FEN_BOARD_DELIMITER);\r\n    const boardArray = fenRows.map(row => ConvertFenToString(row).split(GlobalVariables.EMPTY_STRING));\r\n\r\n    const squares = generateSquareComponents(boardArray, isPossibleMove, getPossibleMoves, movePiece, resetPossibleMoves);\r\n\r\n    updateCastlingRights(fenCastling);\r\n\r\n    GlobalVariables.updateIsWhiteToMove(fenTurn === GlobalVariables.FEN_COLOR.WHITE);\r\n    GlobalVariables.updateHalfMoves(fenHalfMoves);\r\n    GlobalVariables.updateFullMoves(fenFullMoves);\r\n\r\n    // if (updateBoardPosition) {\r\n    GlobalVariables.BoardPosition.splice(0, GlobalVariables.BoardPosition.length, ...boardArray);\r\n    //}\r\n\r\n    updateEnPassant(fenEnPassant);\r\n\r\n    return squares;\r\n}\r\n\r\n/**\r\n * Updates the board position after making a move.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @returns {Array} - The updated board position.\r\n */\r\nexport function updateBoardPosition(currentSquare, targetSquare) {\r\n    return GlobalVariables.BoardPosition.map((row, rowIndex) => {\r\n        if (isSquareOnRow(currentSquare, rowIndex)) {\r\n            row = handleSquareOnCurrentRow(currentSquare, targetSquare, row);\r\n        }\r\n        if (isSquareOnRow(targetSquare, rowIndex)) {\r\n            row = handleTargetSquareOnCurrentRow(currentSquare, targetSquare, row);\r\n        }\r\n        return row;\r\n    });\r\n}\r\n\r\n/**\r\n * Modifies the row to capture pieces sideways.\r\n * @param {Array} row - The row to update.\r\n * @param {number} colIndex - The column index of the current square.\r\n * @param {number} targetColIndex - The column index of the target square.\r\n * @param {string} value - The piece value.\r\n * @returns {Array} - The updated row.\r\n */\r\nexport function SidewaysCapture(row, colIndex, targetColIndex, value) {\r\n    return row.map((col, index) => {\r\n        if (index === colIndex) return GlobalVariables.EMPTY_SQUARE_PIECE;\r\n        if (index === targetColIndex) return ConvertPieceToFENPiece(value);\r\n        return col;\r\n    });\r\n}\r\n\r\n/**\r\n * Converts the piece from {color-piece} format to FEN format (a single letter).\r\n * @param {string} value - The piece value.\r\n * @returns {string} - The FEN notation of the piece.\r\n */\r\nexport function ConvertPieceToFENPiece(value) {\r\n    const [color, piece] = value.split(GlobalVariables.PIECE_DELIMITER);\r\n    const pieceMapping = {\r\n        [GlobalVariables.PIECES.PAWN]: GlobalVariables.FEN_PIECES_BLACK.PAWN,\r\n        [GlobalVariables.PIECES.KNIGHT]: GlobalVariables.FEN_PIECES_BLACK.KNIGHT,\r\n        [GlobalVariables.PIECES.BISHOP]: GlobalVariables.FEN_PIECES_BLACK.BISHOP,\r\n        [GlobalVariables.PIECES.ROOK]: GlobalVariables.FEN_PIECES_BLACK.ROOK,\r\n        [GlobalVariables.PIECES.QUEEN]: GlobalVariables.FEN_PIECES_BLACK.QUEEN,\r\n        [GlobalVariables.PIECES.KING]: GlobalVariables.FEN_PIECES_BLACK.KING,\r\n    };\r\n\r\n    const fenPiece = pieceMapping[piece];\r\n    return isColorWhite(color) ? fenPiece.toUpperCase() : fenPiece;\r\n}\r\n\r\n/**\r\n * Generates Square components for the given board state.\r\n * @param {Array} boardSquares - The 2D array representing the board squares.\r\n * @param {Array} isPossibleMove - The array of possible move states.\r\n * @param {Function} getPossibleMoves - The function to get possible moves.\r\n * @param {Function} movePiece - The function to move a piece.\r\n * @param {Function} resetPossibleMoves - The function to reset possible moves.\r\n * @returns {Array} - The array of Square components.\r\n */\r\nexport function generateSquareComponents(boardSquares, isPossibleMove, getPossibleMoves, movePiece, resetPossibleMoves) {\r\n    let squareColorIsWhite = true;\r\n\r\n    const squares = boardSquares.flatMap((row, rowIndex) => {\r\n        const rowSquares = row.map((square, colIndex) => {\r\n            const color = squareColorIsWhite ? GlobalVariables.EMPTY_STRING : GlobalVariables.DARK_SQUARES_COLOR;\r\n            const possibleMoveStatus = isPossibleMove.find(item => item.key === `${rowIndex}${GlobalVariables.PIECE_DELIMITER}${colIndex}`);\r\n            const squareComponent = (\r\n                <Square\r\n                    key={`${rowIndex}${GlobalVariables.PIECE_DELIMITER}${colIndex}`}\r\n                    x={rowIndex}\r\n                    y={colIndex}\r\n                    piece={ConvertFENPieceToPiece(square)}\r\n                    color={color}\r\n                    getPossibleMoves={getPossibleMoves}\r\n                    movePiece={movePiece}\r\n                    isPossibleMove={possibleMoveStatus ? possibleMoveStatus.value : false}\r\n                    resetPossibleMoves={resetPossibleMoves}\r\n                />\r\n            );\r\n            squareColorIsWhite = !squareColorIsWhite;\r\n            return squareComponent;\r\n        });\r\n        squareColorIsWhite = !squareColorIsWhite; // Reset color for the next row\r\n        return rowSquares;\r\n    });\r\n\r\n    return squares;\r\n}\r\n\r\n/**\r\n * Converts board coordinates to X and Y position on the board, e.g., a8 = 0, 0\r\n * @param {string} coordinates - The board coordinates to convert.\r\n * @returns {object} - Returns an object with x and y properties.\r\n */\r\nexport function convertCoordinatesToLocation(coordinates) {\r\n    let tokens = coordinates.split(GlobalVariables.EMPTY_STRING)\r\n\r\n    //skip invalid coordinates\r\n    if (tokens.length != 2) {\r\n        return\r\n    }\r\n\r\n    let letter = tokens[0].toString().toUpperCase()\r\n    let number = tokens[1]\r\n\r\n    //65 is the ASCII code for capital A which will give us 0 if we have A as a coordinate; A-F will give us 0-7 for y (columns)\r\n    //reverse the numbers since we draw the board top down for x (rows)\r\n    return { x: GlobalVariables.DIM - Number(number), y: getFirstCharacter(letter) - GlobalVariables.ASCII_UPPERCASE_A }\r\n}\r\n\r\n/**\r\n * Converts a piece location to board coordinate, e.g., 0, 0 to a8\r\n * @param {string} x - The X position.\r\n * @param {string} y - The Y position.\r\n * @returns {string} - Returns a string containing the board coordinates.\r\n */\r\nexport function convertLocationToCoordinates(x, y) {\r\n    //maps y (column) to the letter coordinate; add 65 (capital A code) to the ASCII code for the location we have and we get a letter between A and F\r\n    //reverses the x (rows) coordinate because we drop the board top down, while coordinates go down up\r\n    return `${String.fromCharCode(y + GlobalVariables.ASCII_UPPERCASE_A)}${GlobalVariables.DIM - x}`.toLowerCase()\r\n}\r\n\r\n/**\r\n * Determines if the king is in check.\r\n * @param {object} kingSquare - The square where the king is located.\r\n * @param {array} boardSquares - The board squares array.\r\n * @returns {boolean} - True if the king is in check, false otherwise.\r\n */\r\nexport function isKingInCheck(kingSquare, boardSquares) {\r\n    const squares = boardSquares\r\n    const color = getPieceColor(kingSquare)\r\n\r\n    const knightMoves = [\r\n        [-2, -1], [-2, 1], [2, -1], [2, 1],\r\n        [-1, 2], [1, 2], [-1, -2], [1, -2]\r\n    ];\r\n\r\n    const linearDirections = [\r\n        [1, 0], [-1, 0], [0, 1], [0, -1]  // Right, Left, Up, Down\r\n    ];\r\n\r\n    const diagonalDirections = [\r\n        [1, 1], [-1, -1], [1, -1], [-1, 1]  // Diagonals\r\n    ];\r\n\r\n    const checkDirections = (directions) => {\r\n        let isInCheck = false;\r\n        for (const [dx, dy] of directions) {\r\n            //only a queen and a bishop can check diagonally (+ a pawn)\r\n            //only a queen and a rook can check linearly\r\n            const piecesTypes = Math.abs(dx) == Math.abs(dy) ?\r\n                [GlobalVariables.PIECES.QUEEN, GlobalVariables.PIECES.BISHOP] :\r\n                [GlobalVariables.PIECES.QUEEN, GlobalVariables.PIECES.ROOK]\r\n\r\n            for (let i = 1; i < GlobalVariables.DIM; i++) {\r\n                // Get the king and the square that is offset by the given distance\r\n                const piece = getATargetSquareByLocation(kingSquare?.props.x + dx * i, kingSquare?.props.y + dy * i, squares)\r\n\r\n                // Don't check anything if we go out of bounds\r\n                if (!piece) {\r\n                    break;\r\n                }\r\n\r\n                // Get the square data (color and piece type)\r\n                const pieceColor = getPieceColor(piece);\r\n                const pieceType = getPiece(piece);\r\n\r\n                // Move to the next square if this one is empty\r\n                if (!pieceType) {\r\n                    continue;\r\n                }\r\n\r\n                // If the piece is the same color, it can't give us a check, so break\r\n                if (pieceColor === color) {\r\n                    break;\r\n                }\r\n\r\n                // Check if the piece is a queen, rook, or bishop,\r\n                // or if it's a pawn and we are exactly 1 square away (pawns can't check from more than 1 square away)\r\n                if (piecesTypes.includes(pieceType) || (pieceType == GlobalVariables.PIECES.PAWN && i === 1 && Math.abs(dx) == Math.abs(dy))) {\r\n                    return true;\r\n                }\r\n\r\n                isInCheck = false;\r\n                break;\r\n            }\r\n        }\r\n        return isInCheck;\r\n    };\r\n\r\n    if (checkDirections(linearDirections) || checkDirections(diagonalDirections)) {\r\n        return true;\r\n    }\r\n\r\n    for (const [dx, dy] of knightMoves) {\r\n        const piece = squares.find(s => isSquareOnRow(s, kingSquare.props.x + dx) && isSquareOnColumn(s, kingSquare.props.y + dy));\r\n\r\n        // If we're not out of bounds\r\n        // If the the piece is a different color than the king\r\n        // If the piece is a knight\r\n        if (piece && getPieceColor(piece) !== color && getPiece(piece) === GlobalVariables.PIECES.KNIGHT) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Determines if a move is legal by checking if the king would be in check after the move.\r\n * \r\n * @param {object} kingSquare - The square where the king is currently located.\r\n * @param {Array} boardSquares - The current state of the board as an array of squares.\r\n * @param {object} currentPiece - The piece that is being moved.\r\n * @param {object} targetLocation - The square where the piece is being moved to.\r\n * \r\n * @returns {boolean} - True if the move is legal (i.e., does not put the king in check), false otherwise.\r\n */\r\nexport function isMoveLegal(kingSquare, boardSquares, currentPiece, targetLocation) {\r\n    const squares = boardSquares;\r\n\r\n    const updatedSquares = squares.map(s => {\r\n        if (currentPiece && compareIfTwoSquaresAreTheSame(s, currentPiece)) {\r\n            return React.cloneElement(s, { piece: GlobalVariables.EMPTY_STRING });\r\n        } else if (targetLocation && compareIfTwoSquaresAreTheSame(s, targetLocation)) {\r\n            return React.cloneElement(s, { piece: currentPiece.props.piece });\r\n        } else {\r\n            return s;\r\n        }\r\n    });\r\n\r\n    // Handles legal moves for the king\r\n    const king = compareIfTwoSquaresAreTheSame(kingSquare, currentPiece) ? getATargetSquareByLocation(targetLocation.props.x, targetLocation.props.y, updatedSquares) : kingSquare\r\n\r\n    return !isKingInCheck(king, updatedSquares)\r\n}\r\n\r\n/**\r\n * Converts the first character of a string to uppercase and the rest to lowercase.\r\n * @param {string} value - The string to convert.\r\n * @returns {string} - The converted string with the first character in uppercase and the rest in lowercase.\r\n */\r\nexport function turnSentenceCase(value) {\r\n    if (typeof value !== 'string' || value.trim().length === 0) {\r\n        return GlobalVariables.EMPTY_STRING;\r\n    }\r\n    const trimmedValue = value.trim();\r\n    return trimmedValue.charAt(0).toUpperCase() + trimmedValue.slice(1).toLowerCase();\r\n}\r\n\r\n/**\r\n * Disables castling rights if the king or a rook moves.\r\n * @param {object} square - The square containing the piece that moved.\r\n */\r\nexport function disableCastlingIfKingOrRookMoves(square) {\r\n    const color = getPieceColor(square);\r\n    const piece = getPiece(square);\r\n    const isWhite = isColorWhite(color);\r\n\r\n    const updateCastlingRights = (color, type, value) => {\r\n        const castle = 'Castle';\r\n        const normalizedType = turnSentenceCase(type)\r\n        GlobalVariables.CastlingRights[`${color}${normalizedType}${castle}`] = value;\r\n    };\r\n\r\n    if (piece === GlobalVariables.PIECES.KING) {\r\n        const castleColor = isWhite ? GlobalVariables.COLORS.WHITE : GlobalVariables.COLORS.BLACK;\r\n        updateCastlingRights(castleColor, GlobalVariables.CASTLING_TYPES.LONG, false);\r\n        updateCastlingRights(castleColor, GlobalVariables.CASTLING_TYPES.SHORT, false);\r\n    }\r\n\r\n    if (piece === GlobalVariables.PIECES.ROOK) {\r\n        const { x, y } = square.props;\r\n\r\n        const isRookInStartingPosition = (row, col, type, color) => {\r\n            return x === row && y === col && updateCastlingRights(color, type, false);\r\n        };\r\n\r\n        isRookInStartingPosition(GlobalVariables.CASTLE_ROW_WHITE, GlobalVariables.CASTLE_ROOK_INITIAL_COL_SHORT, GlobalVariables.CASTLING_TYPES.SHORT, GlobalVariables.COLORS.WHITE);\r\n        isRookInStartingPosition(GlobalVariables.CASTLE_ROW_BLACK, GlobalVariables.CASTLE_ROOK_INITIAL_COL_SHORT, GlobalVariables.CASTLING_TYPES.SHORT, GlobalVariables.COLORS.BLACK);\r\n        isRookInStartingPosition(GlobalVariables.CASTLE_ROW_WHITE, GlobalVariables.CASTLE_ROOK_INITIAL_COL_LONG, GlobalVariables.CASTLING_TYPES.LONG, GlobalVariables.COLORS.WHITE);\r\n        isRookInStartingPosition(GlobalVariables.CASTLE_ROW_BLACK, GlobalVariables.CASTLE_ROOK_INITIAL_COL_LONG, GlobalVariables.CASTLING_TYPES.LONG, GlobalVariables.COLORS.BLACK);\r\n    }\r\n}\r\n\r\n/**\r\n * Enables or disables en passant based on the move.\r\n * @param {object} square - The square containing the piece that moved.\r\n * @param {object} targetSquare - The square to which the piece is moving.\r\n */\r\nexport function enableEnPassant(square, targetSquare) {\r\n    const color = getPieceColor(square);\r\n    const isWhite = isColorWhite(color);\r\n    const offset = isWhite ? -1 : 1;\r\n    const isThePieceAPawn = isPawn(square);\r\n    const isTwoSquareMove = Math.abs(square.props.x - targetSquare.props.x) === 2;\r\n\r\n    const updateEnPassant = (isPossible, x, y) => {\r\n        GlobalVariables.EnPassant.isPossible = isPossible;\r\n        GlobalVariables.EnPassant.x = x;\r\n        GlobalVariables.EnPassant.y = y;\r\n    };\r\n\r\n    if (isThePieceAPawn && isTwoSquareMove) {\r\n        updateEnPassant(true, square.props.x + offset, square.props.y);\r\n    } else {\r\n        updateEnPassant(false, -1, -1);\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if there are any pawns that can capture en passant from the given square.\r\n *\r\n * This function checks the neighboring squares to the left and right of the given square\r\n * to see if they contain pawns of the opposite color that can potentially capture en passant.\r\n *\r\n * @param {object} square - The square to check from.\r\n * @param {array} squares - The array representing the board squares.\r\n * @returns {boolean} - True if there is at least one pawn that can capture en passant, false otherwise.\r\n */\r\nexport function areTherePawnsThatCanCaptureEnPassant(square, squares) {\r\n    const neighborsOffset = [1, -1];\r\n\r\n    const checkNeighbor = (n) => {\r\n        const x = square.props.x;\r\n        const y = square.props.y + n;\r\n\r\n        // Check if the coordinates are within bounds\r\n        if (!areCoordinatesInBounds(x, y)) {\r\n            return false;\r\n        }\r\n\r\n        const piece = getATargetSquareByLocation(x, y, squares);\r\n\r\n        // Check if the neighboring piece is a pawn and of the opposite color\r\n        const isThePieceAPawn = isPawn(piece);\r\n        const areTheyDifferentColor = !areSameColor(square, piece);\r\n\r\n        return isThePieceAPawn && areTheyDifferentColor;\r\n    };\r\n\r\n    // Return true if any neighboring square contains a pawn that can capture en passant\r\n    return neighborsOffset.some(n => checkNeighbor(n));\r\n}\r\n\r\n/**\r\n * Handles the en passant capture logic.\r\n * \r\n * This function updates the board position if an en passant capture is possible. \r\n * It checks if there are pawns that can perform an en passant capture, updates the \r\n * board position accordingly, and inverts the piece color for the en passant capture.\r\n * \r\n * @param {object} square - The square containing the piece that moved.\r\n * @param {object} targetSquare - The square to which the piece is moving.\r\n * @param {array} position - The current board position.\r\n * @param {array} squares - The array representing the board squares.\r\n * @returns {array} - The updated board position after en passant capture.\r\n */\r\nexport function captureEnPassant(square, targetSquare, position, squares) {\r\n    const color = getPieceColor(square);\r\n    const isWhite = isColorWhite(color);\r\n    const offset = isWhite ? 1 : -1;\r\n    const { isPossible } = GlobalVariables.EnPassant;\r\n    const enPassantTargetSquare = getATargetSquareByLocation(targetSquare.props.x + offset, targetSquare.props.y, squares);\r\n\r\n    if (!compareIfTwoSquaresAreTheSame(targetSquare, enPassantTargetSquare)) {\r\n        return position;\r\n    }\r\n\r\n    if (isPossible && areTherePawnsThatCanCaptureEnPassant(square, squares)) {\r\n        if (enPassantTargetSquare) {\r\n            // Perform en passant capture\r\n            position = updateBoardPosition(square, enPassantTargetSquare);\r\n            // Invert the color of the piece being captured\r\n            const pseudoSquare = <Square x={enPassantTargetSquare.props.x} y={enPassantTargetSquare.props.y} piece={invertPieceColor(enPassantTargetSquare.props.piece)} />;\r\n            // Update the board position again after inverting the piece color\r\n            position = updateBoardPosition(pseudoSquare, targetSquare);\r\n        }\r\n    }\r\n\r\n    return position;\r\n}\r\n\r\n/**\r\n * Inverts the color of a piece.\r\n * \r\n * @param {string} pseudo - The pseudo representation of the piece in {color-piece} format.\r\n * @returns {string} - The piece with inverted color.\r\n */\r\nfunction invertPieceColor(pseudo) {\r\n    const [color, piece] = pseudo.split(GlobalVariables.PIECE_DELIMITER);\r\n    const newColor = isColorWhite(color) ? GlobalVariables.COLORS.BLACK : GlobalVariables.COLORS.WHITE;\r\n    return `${newColor}${GlobalVariables.PIECE_DELIMITER}${piece}`;\r\n}\r\n\r\n/**\r\n * Updates the global board state with the new position.\r\n * @param {Array} updatedPosition - The updated board position after the move.\r\n */\r\nexport function updateBoardState(updatedPosition) {\r\n    const newPosition = updatedPosition.map(row => [...row]);\r\n    GlobalVariables.BoardPosition.splice(0, GlobalVariables.BoardPosition.length, ...newPosition);\r\n}\r\n\r\n/**\r\n * Updates the move counters for the game.\r\n */\r\nexport function updateMoveCounters() {\r\n    GlobalVariables.updateFullMoves(GlobalVariables.FullMoves + 1);\r\n}\r\n\r\n/**\r\n * Resets the possible moves array and toggles the player's turn.\r\n */\r\nexport function resetPossibleMovesAndToggleTurn() {\r\n    GlobalVariables.PossibleMoves.splice(0, GlobalVariables.PossibleMoves.length);\r\n    GlobalVariables.updateIsWhiteToMove(!GlobalVariables.IsWhiteToMove);\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}