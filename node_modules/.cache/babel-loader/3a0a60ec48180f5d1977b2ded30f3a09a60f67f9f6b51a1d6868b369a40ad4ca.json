{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Vladi Gotsin\\\\Desktop\\\\react\\\\Chess-React.js-\\\\src\\\\MoveHandler.js\";\nimport * as GlobalVariables from './globalVariables';\nimport * as HelperMethods from './HelperMethods';\nimport Square from \"./Square.js\";\n\n/**\r\n * Gets all possible moves for a piece.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible moves array.\r\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function getAllPossibleMoves(square, boardSquares) {\n  const pieceColor = HelperMethods.getPieceColor(square);\n  const possibleMoves = [];\n  if (HelperMethods.isPawn(square)) {\n    possibleMoves.push(getPawnMoves(square, boardSquares, pieceColor));\n  }\n  if (HelperMethods.isRook(square)) {\n    possibleMoves.push(getRookMoves(square, boardSquares, pieceColor));\n  }\n  if (HelperMethods.isKnight(square)) {\n    possibleMoves.push(getKingMoves(square, boardSquares, pieceColor));\n  }\n  if (HelperMethods.isBishop(square)) {\n    possibleMoves.push(getPawnMoves(square, boardSquares, pieceColor));\n  }\n  if (HelperMethods.isQueen(square)) {\n    possibleMoves.push(getPawnMoves(square, boardSquares, pieceColor));\n  }\n  if (HelperMethods.isKing(square)) {\n    possibleMoves.push(getPawnMoves(square, boardSquares, pieceColor));\n  }\n  switch (piece) {\n    case GlobalVariables.PIECES.PAWN:\n      possibleMoves.push(getPawnMoves(square, boardSquares, pieceColor));\n    case GlobalVariables.PIECES.ROOK:\n      possibleMoves.push(getRookMoves(square, boardSquares, pieceColor));\n    case GlobalVariables.PIECES.KNIGHT:\n      possibleMoves.push(getKnightMoves(square, boardSquares, pieceColor));\n    case GlobalVariables.PIECES.BISHOP:\n      possibleMoves.push(getBishopMoves(square, boardSquares, pieceColor));\n    case GlobalVariables.PIECES.QUEEN:\n      possibleMoves.push(getQueenMoves(square, boardSquares, pieceColor));\n    case GlobalVariables.PIECES.KING:\n      possibleMoves.push(getKingMoves(square, boardSquares, pieceColor));\n    default:\n      possibleMoves.push([]);\n  }\n  return possibleMoves;\n}\n\n/**\r\n * Gets possible moves for a piece based on specified offsets.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {Array} offsets - An array of [dx, dy] offsets to check for possible moves.\r\n * @returns {Array} - The possible moves array.\r\n */\nfunction getMovesForOffsets(square, boardSquares, offsets) {\n  const moves = [];\n  offsets.forEach(([dx, dy]) => {\n    const targetX = square.props.x + dx;\n    const targetY = square.props.y + dy;\n    const target = HelperMethods.getATargetSquareByLocation(targetX, targetY, boardSquares);\n    if (target) {\n      if (HelperMethods.isSquareAvailable(target)) {\n        moves.push(target);\n      } else if (!HelperMethods.areSameColor(square, target)) {\n        moves.push(target);\n      }\n    }\n  });\n  return moves;\n}\n\n/**\r\n * Gets all possible moves in a given direction for a piece.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {Array} direction - The direction to move in [xIncrement, yIncrement].\r\n * @returns {Array} - The possible moves array in the given direction.\r\n */\nfunction getMovesInDirection(square, boardSquares, [xIncrement, yIncrement]) {\n  const moves = [];\n  let x = square.props.x + xIncrement;\n  let y = square.props.y + yIncrement;\n  while (x >= 0 && x < GlobalVariables.DIM && y >= 0 && y < GlobalVariables.DIM) {\n    const targetSquare = HelperMethods.getATargetSquareByLocation(x, y, boardSquares);\n    if (HelperMethods.isSquareAvailable(targetSquare)) {\n      moves.push(targetSquare);\n    } else {\n      if (!HelperMethods.areSameColor(square, targetSquare)) {\n        moves.push(targetSquare);\n      }\n      break;\n    }\n    x += xIncrement;\n    y += yIncrement;\n  }\n  return moves;\n}\n\n/**\r\n * Gets possible moves for a pawn.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {string} pieceColor - The color of the piece.\r\n * @returns {Array} - The possible moves array.\r\n */\nfunction getPawnMoves(square, boardSquares) {\n  const moves = [];\n  const pieceColor = HelperMethods.getPieceColor(square);\n  const isWhite = HelperMethods.isColorWhite(pieceColor);\n  const direction = isWhite ? -1 : 1;\n\n  // Forward move offsets\n  const forwardOne = direction;\n  const forwardTwo = direction * 2;\n\n  // Helper function to get target square\n  const getTargetSquare = (x, y) => HelperMethods.getATargetSquareByLocation(x, y, boardSquares);\n\n  // Calculate potential forward moves\n  const addForwardMoves = () => {\n    const target1X = square.props.x + forwardOne;\n    const target2X = square.props.x + forwardTwo;\n    const target1 = getTargetSquare(target1X, square.props.y);\n    const target2 = getTargetSquare(target2X, square.props.y);\n    if (HelperMethods.isSquareAvailable(target1)) {\n      moves.push(target1);\n      if (HelperMethods.isSquareAvailable(target2) && HelperMethods.isPawnOnStartingSquare(square)) {\n        moves.push(target2);\n      }\n    }\n  };\n\n  // Calculate potential capture moves\n  const addCaptureMoves = () => {\n    const captureOffsets = [[forwardOne, 1], [forwardOne, -1]];\n    captureOffsets.forEach(([xOffset, yOffset]) => {\n      const targetX = square.props.x + xOffset;\n      const targetY = square.props.y + yOffset;\n      const targetSquare = getTargetSquare(targetX, targetY);\n      if (targetSquare && !HelperMethods.isSquareAvailable(targetSquare) && !HelperMethods.areSameColor(targetSquare, square)) {\n        moves.push(targetSquare);\n      }\n    });\n  };\n\n  // Check for en passant capture\n  const addEnPassantMove = () => {\n    if (!GlobalVariables.EnPassant.isPossible) return;\n    const enPassantSquare = getTargetSquare(GlobalVariables.EnPassant.x, GlobalVariables.EnPassant.y);\n    const validEnPassantOffsets = [[square.props.x + forwardOne, square.props.y + 1], [square.props.x + forwardOne, square.props.y - 1]];\n    if (enPassantSquare && validEnPassantOffsets.some(([x, y]) => HelperMethods.compareIfTwoSquaresAreTheSame(enPassantSquare, getTargetSquare(x, y)))) {\n      moves.push(enPassantSquare);\n    }\n  };\n\n  // Add all possible moves\n  addForwardMoves();\n  addCaptureMoves();\n  addEnPassantMove();\n  return {\n    piece: square,\n    moves: moves\n  };\n}\n\n/**\r\n * Gets possible moves for a rook.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {string} _pieceColor - The color of the piece.\r\n * @returns {Array} - The possible moves array.\r\n */\nfunction getRookMoves(square, boardSquares) {\n  const directions = [[1, 0],\n  // Right\n  [-1, 0],\n  // Left\n  [0, 1],\n  // Up\n  [0, -1] // Down\n  ];\n  const moves = directions.flatMap(direction => getMovesInDirection(square, boardSquares, direction));\n  return {\n    piece: square,\n    moves\n  };\n}\n\n/**\r\n * Gets possible moves for a knight.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {string} _pieceColor - The color of the piece.\r\n * @returns {Array} - The possible moves array.\r\n */\nfunction getKnightMoves(square, boardSquares) {\n  const knightMoves = [[2, 1], [1, 2], [-1, 2], [-2, 1], [-2, -1], [-1, -2], [1, -2], [2, -1]];\n  const moves = getMovesForOffsets(square, boardSquares, knightMoves);\n  return {\n    piece: square,\n    moves\n  };\n}\n\n/**\r\n * Gets possible moves for a bishop.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {string} _pieceColor - The color of the piece.\r\n * @returns {Array} - The possible moves array.\r\n */\nfunction getBishopMoves(square, boardSquares) {\n  const directions = [[-1, -1],\n  // Top-left diagonal\n  [-1, 1],\n  // Bottom-left diagonal\n  [1, 1],\n  // Bottom-right diagonal\n  [1, -1] // Top-right diagonal\n  ];\n  const moves = directions.flatMap(direction => getMovesInDirection(square, boardSquares, direction));\n  return {\n    piece: square,\n    moves\n  };\n}\n\n/**\r\n * Gets possible moves for a queen.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {string} _pieceColor - The color of the piece.\r\n * @returns {Array} - The possible moves array.\r\n */\nfunction getQueenMoves(square, boardSquares) {\n  const directions = [[1, 0], [-1, 0], [0, 1], [0, -1],\n  // Rook directions\n  [1, 1], [1, -1], [-1, 1], [-1, -1] // Bishop directions\n  ];\n  const moves = directions.flatMap(direction => getMovesInDirection(square, boardSquares, direction));\n  return {\n    piece: square,\n    moves\n  };\n}\n\n/**\r\n * Gets possible moves for a king.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {string} _pieceColor - The color of the piece.\r\n * @returns {Array} - The possible moves array.\r\n */\nfunction getKingMoves(square, boardSquares) {\n  const directions = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]];\n  const moves = getMovesForOffsets(square, boardSquares, directions);\n  const color = HelperMethods.getPieceColor(square);\n\n  // Castling logic\n  const castlingMoves = getCastlingMoves(square, color, boardSquares);\n  moves.push(...castlingMoves);\n  return {\n    piece: square,\n    moves\n  };\n}\n\n/**\r\n * Gets castling moves for a king.\r\n * @param {object} square - The current square.\r\n * @param {string} color - The color of the piece.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible castling moves array.\r\n */\nfunction getCastlingMoves(square, color, boardSquares) {\n  const moves = [];\n  const longCastleSquare = HelperMethods.getATargetSquareByLocation(square.props.x, square.props.y - 2, boardSquares);\n  const shortCastleSquare = HelperMethods.getATargetSquareByLocation(square.props.x, square.props.y + 2, boardSquares);\n  const isWhite = HelperMethods.isColorWhite(color);\n\n  // Check and add long castling move\n  if (HelperMethods.isCastlingPossible(GlobalVariables.CASTLING_TYPES.LONG, isWhite)) {\n    moves.push(longCastleSquare);\n  }\n\n  // Check and add short castling move\n  if (HelperMethods.isCastlingPossible(GlobalVariables.CASTLING_TYPES.SHORT, isWhite)) {\n    moves.push(shortCastleSquare);\n  }\n  return moves;\n}\n\n/**\r\n * Filters out moves that do not deal with a check.\r\n * @param {Array} possibleMoves - The array of possible moves.\r\n * @returns {Array} - The filtered array of possible moves.\r\n */\nexport function filterMovesIfInCheck(possibleMoves, boardSquares) {\n  const blackKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.BLACK_KING, boardSquares);\n  const whiteKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.WHITE_KING, boardSquares);\n  const king = GlobalVariables.IsWhiteToMove ? whiteKing : blackKing;\n  const isKingInCheck = (king, move, piece) => {\n    const pseudoMove = /*#__PURE__*/_jsxDEV(Square, {\n      x: king.props.x,\n      y: king.props.y,\n      piece: \"\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 325,\n      columnNumber: 28\n    }, this);\n    if (piece === GlobalVariables.KINGS.BLACK_KING) {\n      return HelperMethods.isBlackInCheck(piece, move, pseudoMove, boardSquares);\n    } else if (piece === GlobalVariables.KINGS.WHITE_KING) {\n      return HelperMethods.isWhiteInCheck(piece, move, pseudoMove, boardSquares);\n    } else {\n      return GlobalVariables.IsWhiteToMove && HelperMethods.isWhiteInCheck(whiteKing, move, pseudoMove, boardSquares) || !GlobalVariables.IsWhiteToMove && HelperMethods.isBlackInCheck(blackKing, move, pseudoMove, boardSquares);\n    }\n  };\n  const filterMoves = (moves, piece) => {\n    return moves.filter(move => {\n      const moveSquare = /*#__PURE__*/_jsxDEV(Square, {\n        x: move.props.x,\n        y: move.props.y,\n        piece: piece\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 338,\n        columnNumber: 32\n      }, this);\n      return !isKingInCheck(king, moveSquare, null, boardSquares);\n    });\n  };\n  return possibleMoves.map(moveSet => {\n    const filteredMoves = filterMoves(moveSet.moves, moveSet.piece.props.piece);\n    return {\n      ...moveSet,\n      moves: filteredMoves\n    };\n  });\n}\n\n/**\r\n * Filters out moves that allow illegal castling (castling through check).\r\n * @param {Array} possibleMoves - The array of possible moves.\r\n * @returns {Array} - The filtered array of possible moves.\r\n */\nexport function filterMovesThatAllowIllegalCastling(possibleMoves, boardSquares) {\n  const blackKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.BLACK_KING, boardSquares);\n  const whiteKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.WHITE_KING, boardSquares);\n  const removeCastlingMove = (moves, x, y) => {\n    const index = moves.findIndex(m => m.props.x === x && m.props.y === y);\n    if (index !== -1) {\n      moves.splice(index, 1);\n    }\n  };\n  const isIllegalCastling = (king, castle1, castle2, across1, across2) => {\n    if (king && (castle1 || castle2)) {\n      if (castle1 && !across1) {\n        removeCastlingMove(king.moves, castle1.props.x, castle1.props.y);\n      }\n      if (castle2 && !across2) {\n        removeCastlingMove(king.moves, castle2.props.x, castle2.props.y);\n      }\n    }\n  };\n  return possibleMoves.map(moveSet => {\n    const piece = moveSet.piece;\n    const moves = moveSet.moves;\n    const whiteCastle1 = moves.find(m => m.props.x === 7 && m.props.y === 6);\n    const whiteCastle2 = moves.find(m => m.props.x === 7 && m.props.y === 2);\n    const blackCastle1 = moves.find(m => m.props.x === 0 && m.props.y === 6);\n    const blackCastle2 = moves.find(m => m.props.x === 0 && m.props.y === 2);\n    if (piece === blackKing || piece === whiteKing) {\n      isIllegalCastling(moveSet, whiteCastle1, whiteCastle2, moves.find(m => m.props.x === 7 && m.props.y === 5), moves.find(m => m.props.x === 7 && m.props.y === 3));\n      isIllegalCastling(moveSet, blackCastle1, blackCastle2, moves.find(m => m.props.x === 0 && m.props.y === 5), moves.find(m => m.props.x === 0 && m.props.y === 3));\n    }\n    if (piece === blackKing && HelperMethods.isBlackInCheck(blackKing, piece, null, boardSquares)) {\n      removeCastlingMove(moves, 0, 6);\n      removeCastlingMove(moves, 0, 2);\n    }\n    if (piece === whiteKing && HelperMethods.isWhiteInCheck(whiteKing, piece, null, boardSquares)) {\n      removeCastlingMove(moves, 7, 6);\n      removeCastlingMove(moves, 7, 2);\n    }\n    return moveSet;\n  });\n}\n\n/**\r\n * Removes empty or undefined moves from the possible moves array.\r\n * @param {Array} possibleMoves - The array of possible moves.\r\n * @returns {Array} - The cleaned array of possible moves.\r\n */\nexport function removeEmptyMoves(possibleMoves) {\n  return possibleMoves.filter(moveSet => moveSet && moveSet.moves && moveSet.moves.length > 0).map(moveSet => ({\n    ...moveSet,\n    moves: moveSet.moves.filter(move => move)\n  }));\n}","map":{"version":3,"names":["GlobalVariables","HelperMethods","Square","jsxDEV","_jsxDEV","getAllPossibleMoves","square","boardSquares","pieceColor","getPieceColor","possibleMoves","isPawn","push","getPawnMoves","isRook","getRookMoves","isKnight","getKingMoves","isBishop","isQueen","isKing","piece","PIECES","PAWN","ROOK","KNIGHT","getKnightMoves","BISHOP","getBishopMoves","QUEEN","getQueenMoves","KING","getMovesForOffsets","offsets","moves","forEach","dx","dy","targetX","props","x","targetY","y","target","getATargetSquareByLocation","isSquareAvailable","areSameColor","getMovesInDirection","xIncrement","yIncrement","DIM","targetSquare","isWhite","isColorWhite","direction","forwardOne","forwardTwo","getTargetSquare","addForwardMoves","target1X","target2X","target1","target2","isPawnOnStartingSquare","addCaptureMoves","captureOffsets","xOffset","yOffset","addEnPassantMove","EnPassant","isPossible","enPassantSquare","validEnPassantOffsets","some","compareIfTwoSquaresAreTheSame","directions","flatMap","knightMoves","color","castlingMoves","getCastlingMoves","longCastleSquare","shortCastleSquare","isCastlingPossible","CASTLING_TYPES","LONG","SHORT","filterMovesIfInCheck","blackKing","getATargetSquareByPiece","KINGS","BLACK_KING","whiteKing","WHITE_KING","king","IsWhiteToMove","isKingInCheck","move","pseudoMove","fileName","_jsxFileName","lineNumber","columnNumber","isBlackInCheck","isWhiteInCheck","filterMoves","filter","moveSquare","map","moveSet","filteredMoves","filterMovesThatAllowIllegalCastling","removeCastlingMove","index","findIndex","m","splice","isIllegalCastling","castle1","castle2","across1","across2","whiteCastle1","find","whiteCastle2","blackCastle1","blackCastle2","removeEmptyMoves","length"],"sources":["C:/Users/Vladi Gotsin/Desktop/react/Chess-React.js-/src/MoveHandler.js"],"sourcesContent":["import * as GlobalVariables from './globalVariables';\r\nimport * as HelperMethods from './HelperMethods';\r\nimport Square from \"./Square.js\"\r\n\r\n/**\r\n * Gets all possible moves for a piece.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nexport function getAllPossibleMoves(square, boardSquares) {\r\n    const pieceColor = HelperMethods.getPieceColor(square);\r\n    const possibleMoves = []\r\n\r\n    if (HelperMethods.isPawn(square)) {\r\n        possibleMoves.push(getPawnMoves(square, boardSquares, pieceColor))\r\n    }\r\n\r\n    if (HelperMethods.isRook(square)) {\r\n        possibleMoves.push(getRookMoves(square, boardSquares, pieceColor))\r\n    }\r\n\r\n    if (HelperMethods.isKnight(square)) {\r\n        possibleMoves.push(getKingMoves(square, boardSquares, pieceColor))\r\n    }\r\n\r\n    if (HelperMethods.isBishop(square)) {\r\n        possibleMoves.push(getPawnMoves(square, boardSquares, pieceColor))\r\n    }\r\n\r\n    if (HelperMethods.isQueen(square)) {\r\n        possibleMoves.push(getPawnMoves(square, boardSquares, pieceColor))\r\n    }\r\n\r\n    if (HelperMethods.isKing(square)) {\r\n        possibleMoves.push(getPawnMoves(square, boardSquares, pieceColor))\r\n    }\r\n\r\n    switch (piece) {\r\n        case GlobalVariables.PIECES.PAWN:\r\n            possibleMoves.push(getPawnMoves(square, boardSquares, pieceColor));\r\n        case GlobalVariables.PIECES.ROOK:\r\n            possibleMoves.push(getRookMoves(square, boardSquares, pieceColor));\r\n        case GlobalVariables.PIECES.KNIGHT:\r\n            possibleMoves.push(getKnightMoves(square, boardSquares, pieceColor));\r\n        case GlobalVariables.PIECES.BISHOP:\r\n            possibleMoves.push(getBishopMoves(square, boardSquares, pieceColor));\r\n        case GlobalVariables.PIECES.QUEEN:\r\n            possibleMoves.push(getQueenMoves(square, boardSquares, pieceColor));\r\n        case GlobalVariables.PIECES.KING:\r\n            possibleMoves.push(getKingMoves(square, boardSquares, pieceColor));\r\n        default:\r\n            possibleMoves.push([]);\r\n    }\r\n\r\n    return possibleMoves\r\n}\r\n\r\n/**\r\n * Gets possible moves for a piece based on specified offsets.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {Array} offsets - An array of [dx, dy] offsets to check for possible moves.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nfunction getMovesForOffsets(square, boardSquares, offsets) {\r\n    const moves = [];\r\n    offsets.forEach(([dx, dy]) => {\r\n        const targetX = square.props.x + dx;\r\n        const targetY = square.props.y + dy;\r\n        const target = HelperMethods.getATargetSquareByLocation(targetX, targetY, boardSquares);\r\n\r\n        if (target) {\r\n            if (HelperMethods.isSquareAvailable(target)) {\r\n                moves.push(target);\r\n            } else if (!HelperMethods.areSameColor(square, target)) {\r\n                moves.push(target);\r\n            }\r\n        }\r\n    });\r\n    return moves;\r\n}\r\n\r\n/**\r\n * Gets all possible moves in a given direction for a piece.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {Array} direction - The direction to move in [xIncrement, yIncrement].\r\n * @returns {Array} - The possible moves array in the given direction.\r\n */\r\nfunction getMovesInDirection(square, boardSquares, [xIncrement, yIncrement]) {\r\n    const moves = [];\r\n    let x = square.props.x + xIncrement;\r\n    let y = square.props.y + yIncrement;\r\n    while (x >= 0 && x < GlobalVariables.DIM && y >= 0 && y < GlobalVariables.DIM) {\r\n        const targetSquare = HelperMethods.getATargetSquareByLocation(x, y, boardSquares);\r\n        if (HelperMethods.isSquareAvailable(targetSquare)) {\r\n            moves.push(targetSquare);\r\n        } else {\r\n            if (!HelperMethods.areSameColor(square, targetSquare)) {\r\n                moves.push(targetSquare);\r\n            }\r\n            break;\r\n        }\r\n        x += xIncrement;\r\n        y += yIncrement;\r\n    }\r\n    return moves;\r\n}\r\n\r\n/**\r\n * Gets possible moves for a pawn.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {string} pieceColor - The color of the piece.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nfunction getPawnMoves(square, boardSquares) {\r\n    const moves = []\r\n    const pieceColor = HelperMethods.getPieceColor(square)\r\n    const isWhite = HelperMethods.isColorWhite(pieceColor);\r\n    const direction = isWhite ? -1 : 1;\r\n\r\n    // Forward move offsets\r\n    const forwardOne = direction;\r\n    const forwardTwo = direction * 2;\r\n\r\n    // Helper function to get target square\r\n    const getTargetSquare = (x, y) => HelperMethods.getATargetSquareByLocation(x, y, boardSquares);\r\n\r\n    // Calculate potential forward moves\r\n    const addForwardMoves = () => {\r\n        const target1X = square.props.x + forwardOne;\r\n        const target2X = square.props.x + forwardTwo;\r\n\r\n        const target1 = getTargetSquare(target1X, square.props.y);\r\n        const target2 = getTargetSquare(target2X, square.props.y);\r\n\r\n        if (HelperMethods.isSquareAvailable(target1)) {\r\n            moves.push(target1);\r\n            if (HelperMethods.isSquareAvailable(target2) && HelperMethods.isPawnOnStartingSquare(square)) {\r\n                moves.push(target2);\r\n            }\r\n        }\r\n    };\r\n\r\n    // Calculate potential capture moves\r\n    const addCaptureMoves = () => {\r\n        const captureOffsets = [\r\n            [forwardOne, 1],\r\n            [forwardOne, -1]\r\n        ];\r\n\r\n        captureOffsets.forEach(([xOffset, yOffset]) => {\r\n            const targetX = square.props.x + xOffset;\r\n            const targetY = square.props.y + yOffset;\r\n            const targetSquare = getTargetSquare(targetX, targetY);\r\n\r\n            if (targetSquare && !HelperMethods.isSquareAvailable(targetSquare) && !HelperMethods.areSameColor(targetSquare, square)) {\r\n                moves.push(targetSquare);\r\n            }\r\n        });\r\n    };\r\n\r\n    // Check for en passant capture\r\n    const addEnPassantMove = () => {\r\n        if (!GlobalVariables.EnPassant.isPossible) return;\r\n        const enPassantSquare = getTargetSquare(GlobalVariables.EnPassant.x, GlobalVariables.EnPassant.y);\r\n        const validEnPassantOffsets = [\r\n            [square.props.x + forwardOne, square.props.y + 1],\r\n            [square.props.x + forwardOne, square.props.y - 1]\r\n        ];\r\n\r\n        if (enPassantSquare && validEnPassantOffsets.some(([x, y]) => HelperMethods.compareIfTwoSquaresAreTheSame(enPassantSquare, getTargetSquare(x, y)))) {\r\n            moves.push(enPassantSquare);\r\n        }\r\n    };\r\n\r\n    // Add all possible moves\r\n    addForwardMoves();\r\n    addCaptureMoves();\r\n    addEnPassantMove();\r\n\r\n    return { piece: square, moves: moves }\r\n}\r\n\r\n/**\r\n * Gets possible moves for a rook.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {string} _pieceColor - The color of the piece.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nfunction getRookMoves(square, boardSquares) {\r\n    const directions = [\r\n        [1, 0],  // Right\r\n        [-1, 0], // Left\r\n        [0, 1],  // Up\r\n        [0, -1]  // Down\r\n    ];\r\n\r\n    const moves = directions.flatMap(direction => getMovesInDirection(square, boardSquares, direction));\r\n\r\n    return { piece: square, moves };\r\n}\r\n\r\n/**\r\n * Gets possible moves for a knight.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {string} _pieceColor - The color of the piece.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nfunction getKnightMoves(square, boardSquares) {\r\n    const knightMoves = [\r\n        [2, 1], [1, 2], [-1, 2], [-2, 1],\r\n        [-2, -1], [-1, -2], [1, -2], [2, -1]\r\n    ];\r\n\r\n    const moves = getMovesForOffsets(square, boardSquares, knightMoves);\r\n    return { piece: square, moves };\r\n}\r\n\r\n/**\r\n * Gets possible moves for a bishop.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {string} _pieceColor - The color of the piece.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nfunction getBishopMoves(square, boardSquares) {\r\n    const directions = [\r\n        [-1, -1], // Top-left diagonal\r\n        [-1, 1],  // Bottom-left diagonal\r\n        [1, 1],   // Bottom-right diagonal\r\n        [1, -1]   // Top-right diagonal\r\n    ];\r\n\r\n    const moves = directions.flatMap(direction => getMovesInDirection(square, boardSquares, direction));\r\n\r\n    return { piece: square, moves };\r\n}\r\n\r\n/**\r\n * Gets possible moves for a queen.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {string} _pieceColor - The color of the piece.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nfunction getQueenMoves(square, boardSquares) {\r\n    const directions = [\r\n        [1, 0], [-1, 0], [0, 1], [0, -1], // Rook directions\r\n        [1, 1], [1, -1], [-1, 1], [-1, -1] // Bishop directions\r\n    ];\r\n\r\n    const moves = directions.flatMap(direction => getMovesInDirection(square, boardSquares, direction));\r\n\r\n    return { piece: square, moves };\r\n}\r\n\r\n/**\r\n * Gets possible moves for a king.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {string} _pieceColor - The color of the piece.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nfunction getKingMoves(square, boardSquares) {\r\n    const directions = [\r\n        [1, 0], [-1, 0], [0, 1], [0, -1],\r\n        [1, 1], [1, -1], [-1, 1], [-1, -1]\r\n    ];\r\n\r\n    const moves = getMovesForOffsets(square, boardSquares, directions);\r\n\r\n    const color = HelperMethods.getPieceColor(square);\r\n\r\n    // Castling logic\r\n    const castlingMoves = getCastlingMoves(square, color, boardSquares);\r\n    moves.push(...castlingMoves);\r\n\r\n    return { piece: square, moves };\r\n}\r\n\r\n/**\r\n * Gets castling moves for a king.\r\n * @param {object} square - The current square.\r\n * @param {string} color - The color of the piece.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible castling moves array.\r\n */\r\nfunction getCastlingMoves(square, color, boardSquares) {\r\n    const moves = [];\r\n\r\n    const longCastleSquare = HelperMethods.getATargetSquareByLocation(square.props.x, square.props.y - 2, boardSquares);\r\n    const shortCastleSquare = HelperMethods.getATargetSquareByLocation(square.props.x, square.props.y + 2, boardSquares);\r\n\r\n    const isWhite = HelperMethods.isColorWhite(color);\r\n\r\n    // Check and add long castling move\r\n    if (HelperMethods.isCastlingPossible(GlobalVariables.CASTLING_TYPES.LONG, isWhite)) {\r\n        moves.push(longCastleSquare);\r\n    }\r\n\r\n    // Check and add short castling move\r\n    if (HelperMethods.isCastlingPossible(GlobalVariables.CASTLING_TYPES.SHORT, isWhite)) {\r\n        moves.push(shortCastleSquare);\r\n    }\r\n\r\n    return moves;\r\n}\r\n\r\n/**\r\n * Filters out moves that do not deal with a check.\r\n * @param {Array} possibleMoves - The array of possible moves.\r\n * @returns {Array} - The filtered array of possible moves.\r\n */\r\nexport function filterMovesIfInCheck(possibleMoves, boardSquares) {\r\n    const blackKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.BLACK_KING, boardSquares);\r\n    const whiteKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.WHITE_KING, boardSquares);\r\n    const king = GlobalVariables.IsWhiteToMove ? whiteKing : blackKing\r\n\r\n    const isKingInCheck = (king, move, piece) => {\r\n        const pseudoMove = <Square x={king.props.x} y={king.props.y} piece={\"\"} />\r\n        if (piece === GlobalVariables.KINGS.BLACK_KING) {\r\n            return HelperMethods.isBlackInCheck(piece, move, pseudoMove, boardSquares);\r\n        } else if (piece === GlobalVariables.KINGS.WHITE_KING) {\r\n            return HelperMethods.isWhiteInCheck(piece, move, pseudoMove, boardSquares);\r\n        } else {\r\n            return (GlobalVariables.IsWhiteToMove && HelperMethods.isWhiteInCheck(whiteKing, move, pseudoMove, boardSquares)) ||\r\n                (!GlobalVariables.IsWhiteToMove && HelperMethods.isBlackInCheck(blackKing, move, pseudoMove, boardSquares));\r\n        }\r\n    };\r\n\r\n    const filterMoves = (moves, piece) => {\r\n        return moves.filter(move => {\r\n            const moveSquare = <Square x={move.props.x} y={move.props.y} piece={piece} />;\r\n            return !isKingInCheck(king, moveSquare, null, boardSquares);\r\n        });\r\n    };\r\n\r\n    return possibleMoves.map(moveSet => {\r\n        const filteredMoves = filterMoves(moveSet.moves, moveSet.piece.props.piece);\r\n        return { ...moveSet, moves: filteredMoves };\r\n    });\r\n}\r\n\r\n/**\r\n * Filters out moves that allow illegal castling (castling through check).\r\n * @param {Array} possibleMoves - The array of possible moves.\r\n * @returns {Array} - The filtered array of possible moves.\r\n */\r\nexport function filterMovesThatAllowIllegalCastling(possibleMoves, boardSquares) {\r\n    const blackKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.BLACK_KING, boardSquares);\r\n    const whiteKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.WHITE_KING, boardSquares);\r\n\r\n    const removeCastlingMove = (moves, x, y) => {\r\n        const index = moves.findIndex(m => m.props.x === x && m.props.y === y);\r\n        if (index !== -1) {\r\n            moves.splice(index, 1);\r\n        }\r\n    };\r\n\r\n    const isIllegalCastling = (king, castle1, castle2, across1, across2) => {\r\n        if (king && (castle1 || castle2)) {\r\n            if (castle1 && !across1) {\r\n                removeCastlingMove(king.moves, castle1.props.x, castle1.props.y);\r\n            }\r\n            if (castle2 && !across2) {\r\n                removeCastlingMove(king.moves, castle2.props.x, castle2.props.y);\r\n            }\r\n        }\r\n    };\r\n\r\n    return possibleMoves.map(moveSet => {\r\n        const piece = moveSet.piece;\r\n        const moves = moveSet.moves;\r\n\r\n        const whiteCastle1 = moves.find(m => m.props.x === 7 && m.props.y === 6);\r\n        const whiteCastle2 = moves.find(m => m.props.x === 7 && m.props.y === 2);\r\n        const blackCastle1 = moves.find(m => m.props.x === 0 && m.props.y === 6);\r\n        const blackCastle2 = moves.find(m => m.props.x === 0 && m.props.y === 2);\r\n\r\n        if (piece === blackKing || piece === whiteKing) {\r\n            isIllegalCastling(moveSet, whiteCastle1, whiteCastle2,\r\n                moves.find(m => m.props.x === 7 && m.props.y === 5),\r\n                moves.find(m => m.props.x === 7 && m.props.y === 3));\r\n\r\n            isIllegalCastling(moveSet, blackCastle1, blackCastle2,\r\n                moves.find(m => m.props.x === 0 && m.props.y === 5),\r\n                moves.find(m => m.props.x === 0 && m.props.y === 3));\r\n        }\r\n\r\n        if (piece === blackKing && HelperMethods.isBlackInCheck(blackKing, piece, null, boardSquares)) {\r\n            removeCastlingMove(moves, 0, 6);\r\n            removeCastlingMove(moves, 0, 2);\r\n        }\r\n\r\n        if (piece === whiteKing && HelperMethods.isWhiteInCheck(whiteKing, piece, null, boardSquares)) {\r\n            removeCastlingMove(moves, 7, 6);\r\n            removeCastlingMove(moves, 7, 2);\r\n        }\r\n\r\n        return moveSet;\r\n    });\r\n}\r\n\r\n/**\r\n * Removes empty or undefined moves from the possible moves array.\r\n * @param {Array} possibleMoves - The array of possible moves.\r\n * @returns {Array} - The cleaned array of possible moves.\r\n */\r\nexport function removeEmptyMoves(possibleMoves) {\r\n    return possibleMoves.filter(moveSet =>\r\n        moveSet && moveSet.moves && moveSet.moves.length > 0\r\n    ).map(moveSet => ({\r\n        ...moveSet,\r\n        moves: moveSet.moves.filter(move => move)\r\n    }));\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}