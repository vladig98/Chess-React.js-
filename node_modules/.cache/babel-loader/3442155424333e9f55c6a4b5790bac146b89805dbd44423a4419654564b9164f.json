{"ast":null,"code":"import { PIECES, FEN_PIECES_BLACK, COLORS, CASTLE_ROW_WHITE, CASTLE_ROW_BLACK, CASTLE_KING_INITIAL_COL, CASTLE_ROOK_INITIAL_COL_LONG, CASTLE_ROOK_INITIAL_COL_SHORT, CASTLE_PATH_COLS_LONG, CASTLE_PATH_COLS_SHORT, PIECE_COLOR_INDEX, PIECE_PIECE_INDEX, FEN_PIECES_WHITE, EMPTY_SQUARE_PIECE, CASTLE_ROOK_FINAL_COL_LONG, CASTLE_ROOK_FINAL_COL_SHORT, CASTLE_KING_FINAL_COL_LONG, CASTLE_KING_FINAL_COL_SHORT, EMPTY_SQUARES_AFTER_LONG_CASTLE, EMPTY_SQUARES_AFTER_SHORT_CASTLE, BoardPosition, PIECE_DELIMITER } from './globalVariables';\nconst FEN_PIECE_MAP = {\n  [FEN_PIECES_BLACK.PAWN]: PIECES.PAWN,\n  [FEN_PIECES_BLACK.KNIGHT]: PIECES.KNIGHT,\n  [FEN_PIECES_BLACK.KING]: PIECES.KING,\n  [FEN_PIECES_BLACK.QUEEN]: PIECES.QUEEN,\n  [FEN_PIECES_BLACK.ROOK]: PIECES.ROOK,\n  [FEN_PIECES_BLACK.BISHOP]: PIECES.BISHOP\n};\n\n//Checks if a character is Uppercase using the ASCII table; 65 (A); 90 (Z)\nexport function IsUpperCase(value) {\n  return value.charCodeAt(0) >= 65 && value.charCodeAt(0) <= 90;\n}\n\n//Checks if a character is Lowercase using the ASCII table; 97 (a); 122 (z)\n_c = IsUpperCase;\nexport function IsLowerCase(value) {\n  return value.charCodeAt(0) >= 97 && value.charCodeAt(0) <= 122;\n}\n\n//Checks if a character is a Digit using the ASCII table; 48 (0); 57 (9)\n_c2 = IsLowerCase;\nexport function IsDigit(value) {\n  return value.charCodeAt(0) >= 48 && value.charCodeAt(0) <= 57;\n}\n\n//splits the FEN string to each individual part that makes it\n_c3 = IsDigit;\nexport function ParseFEN(fen) {\n  const fenParts = fen.split(' ');\n  if (fenParts.length != 6) {\n    console.log('Invalid FEN');\n    return;\n  }\n  const fenBoard = fenParts[0];\n  const fenTurn = fenParts[1];\n  const fenCastling = fenParts[2];\n  const fenEnPassant = fenParts[3];\n  const fenHalfMoves = Number(fenParts[4]);\n  const fenFullMoves = Number(fenParts[5]);\n  return {\n    fenBoard,\n    fenTurn,\n    fenCastling,\n    fenEnPassant,\n    fenHalfMoves,\n    fenFullMoves\n  };\n}\n\n//converts FEN piece notation to an actual piece\n_c4 = ParseFEN;\nexport function ConvertFENtoPiece(letter) {\n  return FEN_PIECE_MAP[letter.toLowerCase()] || \"\";\n}\n\n//converts the FEN piece notation to a piece that we can use in the square component\n_c5 = ConvertFENtoPiece;\nexport function ConvertFENPieceToPiece(value) {\n  if (IsUpperCase(value)) {\n    return `${COLORS.WHITE}-${ConvertFENtoPiece(value)}`;\n  }\n  if (IsLowerCase(value)) {\n    return `${COLORS.BLACK}-${ConvertFENtoPiece(value)}`;\n  }\n  return \"\";\n}\n_c6 = ConvertFENPieceToPiece;\nexport function ConvertFenToString(value) {\n  let result = [];\n  for (let i = 0; i < value.length; i++) {\n    if (IsDigit(value.charAt(i))) {\n      for (let j = 0; j < Number(value.charAt(i)); j++) {\n        result.push(EMPTY_SQUARE_PIECE);\n      }\n    } else {\n      result.push(value.charAt(i));\n    }\n  }\n  return result.join('');\n}\n_c7 = ConvertFenToString;\nfunction checkIfTwoSquaresAreOnTheSameRow(square1, square2) {\n  return square1.props.x == square2.props.x;\n}\nfunction isSquareOnRow(square, rowNumber) {\n  return square.props.x == rowNumber;\n}\n\n//gets the piece\nexport function getPiece(square) {\n  return square.props.piece.split(PIECE_DELIMITER)[PIECE_PIECE_INDEX];\n}\n\n//checks if piece is positioned on a certain square\nexport function doesTheSquareHasThePiece(square, piece) {\n  let p = getPiece(square);\n  return p == piece;\n}\n\n//gets the piece color\nexport function getPieceColor(square) {\n  return square.props.piece.split(PIECE_DELIMITER)[PIECE_COLOR_INDEX];\n}\n\n//checks if a color is white\nexport function isColorWhite(color) {\n  return color == COLORS.WHITE;\n}\nfunction areWeCastling(square1, square2) {\n  return Math.abs(square1.props.y - square2.props.y) == 2;\n}\nfunction areWeShortCastling(castlingType, withWhite = true) {\n  const piecesCastling = withWhite ? CASTLE_ROW_WHITE : CASTLE_ROW_BLACK;\n  const pieces = withWhite ? [...FEN_PIECES_WHITE] : [...FEN_PIECES_BLACK];\n  const [rookCol, kingCol, pathCols] = castlingType === \"long\" ? [CASTLE_ROOK_INITIAL_COL_LONG, CASTLE_KING_INITIAL_COL, CASTLE_PATH_COLS_LONG] : [CASTLE_ROOK_INITIAL_COL_SHORT, CASTLE_KING_INITIAL_COL, CASTLE_PATH_COLS_SHORT];\n  return BoardPosition[piecesCastling][rookCol] == pieces.ROOK && BoardPosition[piecesCastling][kingCol] == pieces.KING && pathCols.every(col => BoardPosition[piecesCastling][col] == EMPTY_SQUARE_PIECE);\n}\nfunction areWeLongCastling(withWhite = true) {\n  const piecesCastling = withWhite ? CASTLE_ROW_WHITE : CASTLE_ROW_BLACK;\n  const pieces = withWhite ? [...FEN_PIECES_WHITE] : [...FEN_PIECES_BLACK];\n  return BoardPosition[piecesCastling][CASTLE_ROOK_INITIAL_COL_LONG] == pieces.ROOK && BoardPosition[piecesCastling][CASTLE_KING_INITIAL_COL] == pieces.KING && CASTLE_PATH_COLS_LONG.every(col => BoardPosition[piecesCastling][col] == EMPTY_SQUARE_PIECE);\n}\nfunction updateColumnOnARow(row, colIndex, newValue) {\n  row[colIndex] = newValue;\n  return row;\n}\nfunction handleSquareOnCurrentRow(square, targetSquare, row) {\n  if (checkIfTwoSquaresAreOnTheSameRow(square, targetSquare)) {\n    return handleSquareAndTargetSquareOnTheSameRow(square, targetSquare, row);\n  }\n  return updateColumnOnARow(row, square.props.y, EMPTY_SQUARE_PIECE);\n}\nfunction handleTargetSquareOnCurrentRow(square, targetSquare, row) {\n  return updateColumnOnARow(row, targetSquare.props.y, ConvertPieceToFENPiece(square.props.piece));\n}\nfunction handleSquareAndTargetSquareOnTheSameRow(square, targetSquare, row) {\n  if (doesTheSquareHasThePiece(square, PIECES.KING) && areWeCastling(square, targetSquare)) {\n    row = handleCastling(square, row);\n  }\n  return SidewaysCapture(row, Number(square.props.y), Number(targetSquare.props.y), square.props.piece);\n}\nfunction handleCastling(square, row) {\n  const color = getPieceColor(square);\n  const isWhite = isColorWhite(color);\n  const kingPiece = isWhite ? FEN_PIECES_WHITE.KING : FEN_PIECES_BLACK.KING;\n  const rookPiece = isWhite ? FEN_PIECES_WHITE.ROOK : FEN_PIECES_BLACK.ROOK;\n  if (areWeLongCastling() || areWeLongCastling(false)) {\n    EMPTY_SQUARES_AFTER_LONG_CASTLE.forEach(col => row[col] = EMPTY_SQUARE_PIECE);\n    row[CASTLE_KING_FINAL_COL_LONG] = kingPiece;\n    row[CASTLE_ROOK_FINAL_COL_LONG] = rookPiece;\n  }\n  if (areWeShortCastling() || areWeShortCastling(false)) {\n    EMPTY_SQUARES_AFTER_SHORT_CASTLE.forEach(col => row[col] = EMPTY_SQUARE_PIECE);\n    row[CASTLE_KING_FINAL_COL_SHORT] = kingPiece;\n    row[CASTLE_ROOK_FINAL_COL_SHORT] = rookPiece;\n  }\n}\nexport function UpdatePosition(square, targetSquare, position) {\n  return position.map((row, rowIndex) => {\n    if (isSquareOnRow(square, rowIndex)) {\n      row = handleSquareOnCurrentRow(square, targetSquare, row);\n    }\n    if (isSquareOnRow(targetSquare, rowIndex)) {\n      row = handleTargetSquareOnCurrentRow(square, targetSquare, row);\n    }\n    return row;\n  });\n}\n_c8 = UpdatePosition;\nfunction SidewaysCapture(row, colIndex, targetColIndex, value) {\n  let result = [];\n  for (let i = 0; i < row.length; i++) {\n    if (i == colIndex) {\n      result.push(EMPTY_SQUARE_PIECE);\n    } else if (i == targetColIndex) {\n      result.push(ConvertPieceToFENPiece(value));\n    } else {\n      result.push(row[i]);\n    }\n  }\n  return result;\n}\n_c9 = SidewaysCapture;\nfunction ConvertPieceToFENPiece(value) {\n  const tokens = value.split(PIECE_DELIMITER);\n  const color = tokens[0];\n  const piece = tokens[1];\n  let p;\n  switch (piece) {\n    case PIECES.PAWN:\n      p = FEN_PIECES_BLACK.PAWN;\n      break;\n    case PIECES.KNIGHT:\n      p = FEN_PIECES_BLACK.KNIGHT;\n      break;\n    case PIECES.BISHOP:\n      p = FEN_PIECES_BLACK.BISHOP;\n      break;\n    case PIECES.ROOK:\n      p = FEN_PIECES_BLACK.ROOK;\n      break;\n    case PIECES.QUEEN:\n      p = FEN_PIECES_BLACK.QUEEN;\n      break;\n    case PIECES.KING:\n      p = FEN_PIECES_BLACK.KING;\n      break;\n    default:\n      break;\n  }\n  return isColorWhite(color) ? p.toString().toUpperCase() : p.toString();\n}\n_c10 = ConvertPieceToFENPiece;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10;\n$RefreshReg$(_c, \"IsUpperCase\");\n$RefreshReg$(_c2, \"IsLowerCase\");\n$RefreshReg$(_c3, \"IsDigit\");\n$RefreshReg$(_c4, \"ParseFEN\");\n$RefreshReg$(_c5, \"ConvertFENtoPiece\");\n$RefreshReg$(_c6, \"ConvertFENPieceToPiece\");\n$RefreshReg$(_c7, \"ConvertFenToString\");\n$RefreshReg$(_c8, \"UpdatePosition\");\n$RefreshReg$(_c9, \"SidewaysCapture\");\n$RefreshReg$(_c10, \"ConvertPieceToFENPiece\");","map":{"version":3,"names":["PIECES","FEN_PIECES_BLACK","COLORS","CASTLE_ROW_WHITE","CASTLE_ROW_BLACK","CASTLE_KING_INITIAL_COL","CASTLE_ROOK_INITIAL_COL_LONG","CASTLE_ROOK_INITIAL_COL_SHORT","CASTLE_PATH_COLS_LONG","CASTLE_PATH_COLS_SHORT","PIECE_COLOR_INDEX","PIECE_PIECE_INDEX","FEN_PIECES_WHITE","EMPTY_SQUARE_PIECE","CASTLE_ROOK_FINAL_COL_LONG","CASTLE_ROOK_FINAL_COL_SHORT","CASTLE_KING_FINAL_COL_LONG","CASTLE_KING_FINAL_COL_SHORT","EMPTY_SQUARES_AFTER_LONG_CASTLE","EMPTY_SQUARES_AFTER_SHORT_CASTLE","BoardPosition","PIECE_DELIMITER","FEN_PIECE_MAP","PAWN","KNIGHT","KING","QUEEN","ROOK","BISHOP","IsUpperCase","value","charCodeAt","_c","IsLowerCase","_c2","IsDigit","_c3","ParseFEN","fen","fenParts","split","length","console","log","fenBoard","fenTurn","fenCastling","fenEnPassant","fenHalfMoves","Number","fenFullMoves","_c4","ConvertFENtoPiece","letter","toLowerCase","_c5","ConvertFENPieceToPiece","WHITE","BLACK","_c6","ConvertFenToString","result","i","charAt","j","push","join","_c7","checkIfTwoSquaresAreOnTheSameRow","square1","square2","props","x","isSquareOnRow","square","rowNumber","getPiece","piece","doesTheSquareHasThePiece","p","getPieceColor","isColorWhite","color","areWeCastling","Math","abs","y","areWeShortCastling","castlingType","withWhite","piecesCastling","pieces","rookCol","kingCol","pathCols","every","col","areWeLongCastling","updateColumnOnARow","row","colIndex","newValue","handleSquareOnCurrentRow","targetSquare","handleSquareAndTargetSquareOnTheSameRow","handleTargetSquareOnCurrentRow","ConvertPieceToFENPiece","handleCastling","SidewaysCapture","isWhite","kingPiece","rookPiece","forEach","UpdatePosition","position","map","rowIndex","_c8","targetColIndex","_c9","tokens","toString","toUpperCase","_c10","$RefreshReg$"],"sources":["C:/Users/Vladi Gotsin/Desktop/react/Chess-React.js-/src/HelperMethods.js"],"sourcesContent":["import {\r\n    PIECES, FEN_PIECES_BLACK, COLORS, CASTLE_ROW_WHITE, CASTLE_ROW_BLACK, CASTLE_KING_INITIAL_COL, CASTLE_ROOK_INITIAL_COL_LONG, CASTLE_ROOK_INITIAL_COL_SHORT,\r\n    CASTLE_PATH_COLS_LONG, CASTLE_PATH_COLS_SHORT, PIECE_COLOR_INDEX, PIECE_PIECE_INDEX, FEN_PIECES_WHITE, EMPTY_SQUARE_PIECE, CASTLE_ROOK_FINAL_COL_LONG,\r\n    CASTLE_ROOK_FINAL_COL_SHORT, CASTLE_KING_FINAL_COL_LONG, CASTLE_KING_FINAL_COL_SHORT, EMPTY_SQUARES_AFTER_LONG_CASTLE, EMPTY_SQUARES_AFTER_SHORT_CASTLE,\r\n    BoardPosition, PIECE_DELIMITER\r\n} from './globalVariables'\r\n\r\nconst FEN_PIECE_MAP = {\r\n    [FEN_PIECES_BLACK.PAWN]: PIECES.PAWN,\r\n    [FEN_PIECES_BLACK.KNIGHT]: PIECES.KNIGHT,\r\n    [FEN_PIECES_BLACK.KING]: PIECES.KING,\r\n    [FEN_PIECES_BLACK.QUEEN]: PIECES.QUEEN,\r\n    [FEN_PIECES_BLACK.ROOK]: PIECES.ROOK,\r\n    [FEN_PIECES_BLACK.BISHOP]: PIECES.BISHOP,\r\n};\r\n\r\n//Checks if a character is Uppercase using the ASCII table; 65 (A); 90 (Z)\r\nexport function IsUpperCase(value) {\r\n    return value.charCodeAt(0) >= 65 && value.charCodeAt(0) <= 90\r\n}\r\n\r\n//Checks if a character is Lowercase using the ASCII table; 97 (a); 122 (z)\r\nexport function IsLowerCase(value) {\r\n    return value.charCodeAt(0) >= 97 && value.charCodeAt(0) <= 122\r\n}\r\n\r\n//Checks if a character is a Digit using the ASCII table; 48 (0); 57 (9)\r\nexport function IsDigit(value) {\r\n    return value.charCodeAt(0) >= 48 && value.charCodeAt(0) <= 57\r\n}\r\n\r\n//splits the FEN string to each individual part that makes it\r\nexport function ParseFEN(fen) {\r\n    const fenParts = fen.split(' ');\r\n\r\n    if (fenParts.length != 6) {\r\n        console.log('Invalid FEN')\r\n        return;\r\n    }\r\n\r\n    const fenBoard = fenParts[0];\r\n    const fenTurn = fenParts[1];\r\n    const fenCastling = fenParts[2];\r\n    const fenEnPassant = fenParts[3];\r\n    const fenHalfMoves = Number(fenParts[4])\r\n    const fenFullMoves = Number(fenParts[5])\r\n\r\n    return { fenBoard, fenTurn, fenCastling, fenEnPassant, fenHalfMoves, fenFullMoves }\r\n}\r\n\r\n//converts FEN piece notation to an actual piece\r\nexport function ConvertFENtoPiece(letter) {\r\n    return FEN_PIECE_MAP[letter.toLowerCase()] || \"\";\r\n}\r\n\r\n//converts the FEN piece notation to a piece that we can use in the square component\r\nexport function ConvertFENPieceToPiece(value) {\r\n    if (IsUpperCase(value)) {\r\n        return `${COLORS.WHITE}-${ConvertFENtoPiece(value)}`;\r\n    }\r\n\r\n    if (IsLowerCase(value)) {\r\n        return `${COLORS.BLACK}-${ConvertFENtoPiece(value)}`;\r\n    }\r\n\r\n    return \"\";\r\n}\r\n\r\nexport function ConvertFenToString(value) {\r\n    let result = [];\r\n\r\n    for (let i = 0; i < value.length; i++) {\r\n        if (IsDigit(value.charAt(i))) {\r\n            for (let j = 0; j < Number(value.charAt(i)); j++) {\r\n                result.push(EMPTY_SQUARE_PIECE)\r\n            }\r\n        } else {\r\n            result.push(value.charAt(i))\r\n        }\r\n    }\r\n\r\n    return result.join('');\r\n}\r\n\r\nfunction checkIfTwoSquaresAreOnTheSameRow(square1, square2) {\r\n    return square1.props.x == square2.props.x\r\n}\r\n\r\nfunction isSquareOnRow(square, rowNumber) {\r\n    return square.props.x == rowNumber\r\n}\r\n\r\n//gets the piece\r\nexport function getPiece(square) {\r\n    return square.props.piece.split(PIECE_DELIMITER)[PIECE_PIECE_INDEX]\r\n}\r\n\r\n//checks if piece is positioned on a certain square\r\nexport function doesTheSquareHasThePiece(square, piece) {\r\n    let p = getPiece(square)\r\n\r\n    return p == piece\r\n}\r\n\r\n//gets the piece color\r\nexport function getPieceColor(square) {\r\n    return square.props.piece.split(PIECE_DELIMITER)[PIECE_COLOR_INDEX]\r\n}\r\n\r\n//checks if a color is white\r\nexport function isColorWhite(color) {\r\n    return color == COLORS.WHITE\r\n}\r\n\r\nfunction areWeCastling(square1, square2) {\r\n    return Math.abs(square1.props.y - square2.props.y) == 2\r\n}\r\n\r\nfunction areWeShortCastling(castlingType, withWhite = true) {\r\n    const piecesCastling = withWhite ? CASTLE_ROW_WHITE : CASTLE_ROW_BLACK\r\n    const pieces = withWhite ? [...FEN_PIECES_WHITE] : [...FEN_PIECES_BLACK]\r\n    const [rookCol, kingCol, pathCols] = castlingType === \"long\" ?\r\n        [CASTLE_ROOK_INITIAL_COL_LONG, CASTLE_KING_INITIAL_COL, CASTLE_PATH_COLS_LONG] :\r\n        [CASTLE_ROOK_INITIAL_COL_SHORT, CASTLE_KING_INITIAL_COL, CASTLE_PATH_COLS_SHORT];\r\n\r\n\r\n    return BoardPosition[piecesCastling][rookCol] == pieces.ROOK &&\r\n        BoardPosition[piecesCastling][kingCol] == pieces.KING &&\r\n        pathCols.every(col => BoardPosition[piecesCastling][col] == EMPTY_SQUARE_PIECE);\r\n}\r\n\r\nfunction areWeLongCastling(withWhite = true) {\r\n    const piecesCastling = withWhite ? CASTLE_ROW_WHITE : CASTLE_ROW_BLACK\r\n    const pieces = withWhite ? [...FEN_PIECES_WHITE] : [...FEN_PIECES_BLACK]\r\n\r\n    return BoardPosition[piecesCastling][CASTLE_ROOK_INITIAL_COL_LONG] == pieces.ROOK &&\r\n        BoardPosition[piecesCastling][CASTLE_KING_INITIAL_COL] == pieces.KING &&\r\n        CASTLE_PATH_COLS_LONG.every(col => BoardPosition[piecesCastling][col] == EMPTY_SQUARE_PIECE);\r\n}\r\n\r\nfunction updateColumnOnARow(row, colIndex, newValue) {\r\n    row[colIndex] = newValue\r\n    return row\r\n}\r\n\r\nfunction handleSquareOnCurrentRow(square, targetSquare, row) {\r\n    if (checkIfTwoSquaresAreOnTheSameRow(square, targetSquare)) {\r\n        return handleSquareAndTargetSquareOnTheSameRow(square, targetSquare, row);\r\n    }\r\n\r\n    return updateColumnOnARow(row, square.props.y, EMPTY_SQUARE_PIECE)\r\n}\r\n\r\nfunction handleTargetSquareOnCurrentRow(square, targetSquare, row) {\r\n    return updateColumnOnARow(row, targetSquare.props.y, ConvertPieceToFENPiece(square.props.piece))\r\n}\r\n\r\nfunction handleSquareAndTargetSquareOnTheSameRow(square, targetSquare, row) {\r\n    if (doesTheSquareHasThePiece(square, PIECES.KING) && areWeCastling(square, targetSquare)) {\r\n        row = handleCastling(square, row)\r\n    }\r\n\r\n    return SidewaysCapture(row, Number(square.props.y), Number(targetSquare.props.y), square.props.piece)\r\n}\r\n\r\nfunction handleCastling(square, row) {\r\n    const color = getPieceColor(square)\r\n    const isWhite = isColorWhite(color);\r\n    const kingPiece = isWhite ? FEN_PIECES_WHITE.KING : FEN_PIECES_BLACK.KING;\r\n    const rookPiece = isWhite ? FEN_PIECES_WHITE.ROOK : FEN_PIECES_BLACK.ROOK;\r\n\r\n    if (areWeLongCastling() || areWeLongCastling(false)) {\r\n        EMPTY_SQUARES_AFTER_LONG_CASTLE.forEach(col => row[col] = EMPTY_SQUARE_PIECE);\r\n        row[CASTLE_KING_FINAL_COL_LONG] = kingPiece\r\n        row[CASTLE_ROOK_FINAL_COL_LONG] = rookPiece\r\n    }\r\n\r\n    if (areWeShortCastling() || areWeShortCastling(false)) {\r\n        EMPTY_SQUARES_AFTER_SHORT_CASTLE.forEach(col => row[col] = EMPTY_SQUARE_PIECE);\r\n        row[CASTLE_KING_FINAL_COL_SHORT] = kingPiece\r\n        row[CASTLE_ROOK_FINAL_COL_SHORT] = rookPiece\r\n    }\r\n}\r\n\r\nexport function UpdatePosition(square, targetSquare, position) {\r\n    return position.map((row, rowIndex) => {\r\n        if (isSquareOnRow(square, rowIndex)) {\r\n            row = handleSquareOnCurrentRow(square, targetSquare, row);\r\n        }\r\n        if (isSquareOnRow(targetSquare, rowIndex)) {\r\n            row = handleTargetSquareOnCurrentRow(square, targetSquare, row);\r\n        }\r\n        return row;\r\n    });\r\n}\r\n\r\nfunction SidewaysCapture(row, colIndex, targetColIndex, value) {\r\n    let result = []\r\n\r\n    for (let i = 0; i < row.length; i++) {\r\n        if (i == colIndex) {\r\n            result.push(EMPTY_SQUARE_PIECE)\r\n        } else if (i == targetColIndex) {\r\n            result.push(ConvertPieceToFENPiece(value))\r\n        } else {\r\n            result.push(row[i])\r\n        }\r\n    }\r\n\r\n    return result\r\n}\r\n\r\nfunction ConvertPieceToFENPiece(value) {\r\n    const tokens = value.split(PIECE_DELIMITER)\r\n    const color = tokens[0]\r\n    const piece = tokens[1]\r\n\r\n    let p;\r\n\r\n    switch (piece) {\r\n        case PIECES.PAWN:\r\n            p = FEN_PIECES_BLACK.PAWN;\r\n            break;\r\n        case PIECES.KNIGHT:\r\n            p = FEN_PIECES_BLACK.KNIGHT;\r\n            break;\r\n        case PIECES.BISHOP:\r\n            p = FEN_PIECES_BLACK.BISHOP;\r\n            break;\r\n        case PIECES.ROOK:\r\n            p = FEN_PIECES_BLACK.ROOK;\r\n            break;\r\n        case PIECES.QUEEN:\r\n            p = FEN_PIECES_BLACK.QUEEN;\r\n            break;\r\n        case PIECES.KING:\r\n            p = FEN_PIECES_BLACK.KING;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    return isColorWhite(color) ? p.toString().toUpperCase() : p.toString()\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}