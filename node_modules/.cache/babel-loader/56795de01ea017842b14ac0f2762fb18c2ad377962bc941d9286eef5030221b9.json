{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Vladi Gotsin\\\\Desktop\\\\react\\\\Chess-React.js-\\\\src\\\\HelperMethods.js\";\nimport React from 'react';\nimport Square from \"./Square.js\";\nimport * as GlobalVariables from './globalVariables';\n\n/**\r\n * <summary>\r\n * This module provides various helper functions for handling chess board state, \r\n * manipulating FEN strings, and generating square components for the chess board.\r\n * </summary>\r\n * \r\n * <function name=\"IsUpperCase\">\r\n * <description>Checks if a character is Uppercase using the ASCII table.</description>\r\n * <param name=\"value\" type=\"string\">The character to check.</param>\r\n * <returns type=\"boolean\">True if the character is uppercase, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"IsLowerCase\">\r\n * <description>Checks if a character is Lowercase using the ASCII table.</description>\r\n * <param name=\"value\" type=\"string\">The character to check.</param>\r\n * <returns type=\"boolean\">True if the character is lowercase, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"IsDigit\">\r\n * <description>Checks if a character is a Digit using the ASCII table.</description>\r\n * <param name=\"value\" type=\"string\">The character to check.</param>\r\n * <returns type=\"boolean\">True if the character is a digit, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"ParseFEN\">\r\n * <description>Parses a FEN string and returns its components.</description>\r\n * <param name=\"fen\" type=\"string\">The FEN string to parse.</param>\r\n * <returns type=\"object\">An object containing the FEN components.</returns>\r\n * </function>\r\n * \r\n * <function name=\"ConvertFENtoPiece\">\r\n * <description>Converts FEN piece notation to an actual piece.</description>\r\n * <param name=\"letter\" type=\"string\">The FEN notation of the piece.</param>\r\n * <returns type=\"string\">The actual piece.</returns>\r\n * </function>\r\n * \r\n * <function name=\"ConvertFENPieceToPiece\">\r\n * <description>Converts the FEN piece notation to a piece that can be used in the square component.</description>\r\n * <param name=\"value\" type=\"string\">The FEN notation of the piece.</param>\r\n * <returns type=\"string\">The piece in {color-piece} format.</returns>\r\n * </function>\r\n * \r\n * <function name=\"ConvertFenToString\">\r\n * <description>Converts a string in FEN format to a normal string.</description>\r\n * <param name=\"value\" type=\"string\">The FEN string.</param>\r\n * <returns type=\"string\">The normal string.</returns>\r\n * </function>\r\n * \r\n * <function name=\"checkIfTwoSquaresAreOnTheSameRow\">\r\n * <description>Checks if two squares are on the same row.</description>\r\n * <param name=\"square1\" type=\"object\">The first square.</param>\r\n * <param name=\"square2\" type=\"object\">The second square.</param>\r\n * <returns type=\"boolean\">True if the squares are on the same row, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isSquareOnRow\">\r\n * <description>Checks if the square is on the given row number.</description>\r\n * <param name=\"square\" type=\"object\">The square to check.</param>\r\n * <param name=\"rowNumber\" type=\"number\">The row number.</param>\r\n * <returns type=\"boolean\">True if the square is on the given row, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"getPiece\">\r\n * <description>Gets the piece from a square.</description>\r\n * <param name=\"square\" type=\"object\">The square to get the piece from.</param>\r\n * <returns type=\"string\">The piece.</returns>\r\n * </function>\r\n * \r\n * <function name=\"doesTheSquareHasThePiece\">\r\n * <description>Checks if a square has a specific piece.</description>\r\n * <param name=\"square\" type=\"object\">The square to check.</param>\r\n * <param name=\"piece\" type=\"string\">The piece to check for.</param>\r\n * <returns type=\"boolean\">True if the square has the piece, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"getPieceColor\">\r\n * <description>Gets the piece color from a square.</description>\r\n * <param name=\"square\" type=\"object\">The square to get the piece color from.</param>\r\n * <returns type=\"string\">The piece color.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isColorWhite\">\r\n * <description>Checks if a color is white.</description>\r\n * <param name=\"color\" type=\"string\">The color to check.</param>\r\n * <returns type=\"boolean\">True if the color is white, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isColorBlack\">\r\n * <description>Checks if a color is black.</description>\r\n * <param name=\"color\" type=\"string\">The color to check.</param>\r\n * <returns type=\"boolean\">True if the color is black, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"areSameColor\">\r\n * <description>Checks if two pieces are of the same color.</description>\r\n * <param name=\"piece1\" type=\"string\">The first piece.</param>\r\n * <param name=\"piece2\" type=\"string\">The second piece.</param>\r\n * <returns type=\"boolean\">True if the pieces are of the same color, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"checkIfAMoveIsEqualToTheCurrentSelectedSquare\">\r\n * <description>Checks if a move is equal to the current selected square.</description>\r\n * <param name=\"move\" type=\"object\">The move to check.</param>\r\n * <returns type=\"boolean\">True if the move is equal to the current selected square, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"compareIfTwoSquaresAreTheSame\">\r\n * <description>Compares if two squares are the same.</description>\r\n * <param name=\"square1\" type=\"object\">The first square.</param>\r\n * <param name=\"square2\" type=\"object\">The second square.</param>\r\n * <returns type=\"boolean\">True if the squares are the same, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"getATargetSquareByLocation\">\r\n * <description>Gets a target square by its location.</description>\r\n * <param name=\"x\" type=\"number\">The x coordinate of the target square.</param>\r\n * <param name=\"y\" type=\"number\">The y coordinate of the target square.</param>\r\n * <returns type=\"object\">The target square.</returns>\r\n * </function>\r\n * \r\n * <function name=\"getATargetSquareByPiece\">\r\n * <description>Gets a target square by its piece.</description>\r\n * <param name=\"piece\" type=\"string\">The piece to search for.</param>\r\n * <returns type=\"object\">The target square.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isCastlingPossible\">\r\n * <description>Checks if castling is possible.</description>\r\n * <param name=\"castlingType\" type=\"string\">The type of castling (long or short).</param>\r\n * <param name=\"withWhite\" type=\"boolean\">True if checking for white's castling, false otherwise.</param>\r\n * <returns type=\"boolean\">True if castling is possible, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isPawnOnStartingSquare\">\r\n * <description>Checks if a pawn is on its starting square.</description>\r\n * <param name=\"pawn\" type=\"object\">The pawn to check.</param>\r\n * <returns type=\"boolean\">True if the pawn is on its starting square, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isPawnOnEnPassantSquare\">\r\n * <description>Checks if a pawn is on an en passant square.</description>\r\n * <param name=\"pawn\" type=\"object\">The pawn to check.</param>\r\n * <returns type=\"boolean\">True if the pawn is on an en passant square, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isSquareAvailable\">\r\n * <description>Checks if a square is available for a move.</description>\r\n * <param name=\"square\" type=\"object\">The square to check.</param>\r\n * <returns type=\"boolean\">True if the square is available, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"updateColumnOnARow\">\r\n * <description>Updates a column on a row with a new value.</description>\r\n * <param name=\"row\" type=\"Array\">The row to update.</param>\r\n * <param name=\"colIndex\" type=\"number\">The column index.</param>\r\n * <param name=\"newValue\" type=\"string\">The new value.</param>\r\n * <returns type=\"Array\">The updated row.</returns>\r\n * </function>\r\n * \r\n * <function name=\"handleSquareOnCurrentRow\">\r\n * <description>Removes the current square's piece.</description>\r\n * <param name=\"currentSquare\" type=\"object\">The current square.</param>\r\n * <param name=\"targetSquare\" type=\"object\">The target square.</param>\r\n * <param name=\"row\" type=\"Array\">The row to update.</param>\r\n * <returns type=\"Array\">The updated row.</returns>\r\n * </function>\r\n * \r\n * <function name=\"handleTargetSquareOnCurrentRow\">\r\n * <description>Updates the target square with the current square's piece.</description>\r\n * <param name=\"currentSquare\" type=\"object\">The current square.</param>\r\n * <param name=\"targetSquare\" type=\"object\">The target square.</param>\r\n * <param name=\"row\" type=\"Array\">The row to update.</param>\r\n * <returns type=\"Array\">The updated row.</returns>\r\n * </function>\r\n * \r\n * <function name=\"handleSquareAndTargetSquareOnTheSameRow\">\r\n * <description>Checks if we're making a move on the same row and performs castling if we want to castle.</description>\r\n * <param name=\"currentSquare\" type=\"object\">The current square.</param>\r\n * <param name=\"targetSquare\" type=\"object\">The target square.</param>\r\n * <param name=\"row\" type=\"Array\">The row to update.</param>\r\n * <returns type=\"Array\">The updated row.</returns>\r\n * </function>\r\n * \r\n * <function name=\"handleCastling\">\r\n * <description>Performs castling by swapping the rook and the king.</description>\r\n * <param name=\"square\" type=\"object\">The square to update.</param>\r\n * <param name=\"row\" type=\"Array\">The row to update.</param>\r\n * <returns type=\"Array\">The updated row.</returns>\r\n * </function>\r\n * \r\n * <function name=\"convertRowToFEN\">\r\n * <description>Converts a row of squares to its FEN representation.</description>\r\n * <param name=\"row\" type=\"Array\">The row to convert.</param>\r\n * <returns type=\"string\">The FEN representation of the row.</returns>\r\n * </function>\r\n * \r\n * <function name=\"getCastlingRules\">\r\n * <description>Gets the castling rules as a string.</description>\r\n * <returns type=\"string\">The castling rules.</returns>\r\n * </function>\r\n * \r\n * <function name=\"generateANewFen\">\r\n * <description>Generates a new FEN string based on the current board state.</description>\r\n * <returns type=\"string\">The new FEN string.</returns>\r\n * </function>\r\n * \r\n * <function name=\"updateCastlingRights\">\r\n * <description>Updates castling rights based on the given castling string.</description>\r\n * <param name=\"castling\" type=\"string\">The castling rights string (e.g., 'KQkq').</param>\r\n * </function>\r\n * \r\n * <function name=\"updateEnPassant\">\r\n * <description>Updates en passant status based on the given en passant string.</description>\r\n * <param name=\"enPassant\" type=\"string\">The en passant target square (e.g., 'e3') or '-' if not available.</param>\r\n * </function>\r\n * \r\n * <function name=\"fenParser\">\r\n * <description>Parses the FEN string to update the board state.</description>\r\n * <param name=\"fen\" type=\"string\">The FEN string representing the board state.</param>\r\n * <param name=\"isPossibleMove\" type=\"Array\">Array indicating possible moves.</param>\r\n * <param name=\"getPossibleMoves\" type=\"Function\">Function to get possible moves.</param>\r\n * <param name=\"movePiece\" type=\"Function\">Function to move a piece.</param>\r\n * <param name=\"resetPossibleMoves\" type=\"Function\">Function to reset possible moves.</param>\r\n * <param name=\"updateBoardPosition\" type=\"boolean\" default=\"true\">Whether to update the board position.</param>\r\n * <returns type=\"Array\">The generated square components.</returns>\r\n * </function>\r\n * \r\n * <function name=\"updateBoardPosition\">\r\n * <description>Updates the board position after making a move.</description>\r\n * <param name=\"currentSquare\" type=\"object\">The current square.</param>\r\n * <param name=\"targetSquare\" type=\"object\">The target square.</param>\r\n * <returns type=\"Array\">The updated board position.</returns>\r\n * </function>\r\n * \r\n * <function name=\"SidewaysCapture\">\r\n * <description>Modifies the row to capture pieces sideways.</description>\r\n * <param name=\"row\" type=\"Array\">The row to update.</param>\r\n * <param name=\"colIndex\" type=\"number\">The column index of the current square.</param>\r\n * <param name=\"targetColIndex\" type=\"number\">The column index of the target square.</param>\r\n * <param name=\"value\" type=\"string\">The piece value.</param>\r\n * <returns type=\"Array\">The updated row.</returns>\r\n * </function>\r\n * \r\n * <function name=\"ConvertPieceToFENPiece\">\r\n * <description>Converts the piece from {color-piece} format to FEN format (a single letter).</description>\r\n * <param name=\"value\" type=\"string\">The piece value.</param>\r\n * <returns type=\"string\">The FEN notation of the piece.</returns>\r\n * </function>\r\n * \r\n * <function name=\"generateSquareComponents\">\r\n * <description>Generates Square components for the given board state.</description>\r\n * <param name=\"boardSquares\" type=\"Array\">The 2D array representing the board squares.</param>\r\n * <param name=\"isPossibleMove\" type=\"Array\">The array of possible move states.</param>\r\n * <param name=\"getPossibleMoves\" type=\"Function\">The function to get possible moves.</param>\r\n * <param name=\"movePiece\" type=\"Function\">The function to move a piece.</param>\r\n * <param name=\"resetPossibleMoves\" type=\"Function\">The function to reset possible moves.</param>\r\n * <returns type=\"Array\">The array of Square components.</returns>\r\n * </function>\r\n * \r\n * <function name=\"convertCoordinatesToLocation\">\r\n * <description>Converts board coordinates to X and Y position on the board, e.g., a8 = 0, 0</description>\r\n * <param name=\"coordinates\" type=\"string\">The board coordinates to convert.</param>\r\n * <returns type=\"object\">Returns an object with x and y properties.</returns>\r\n * </function>\r\n * \r\n * <function name=\"convertLocationToCoordinates\">\r\n * <description>Converts a piece location to board coordinate, e.g., 0, 0 to a8</description>\r\n * <param name=\"x\" type=\"string\">The X position.</param>\r\n * <param name=\"y\" type=\"string\">The Y position.</param>\r\n * <returns type=\"string\">Returns a string containing the board coordinates.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isKingInCheck\">\r\n * <description>Determines if the king is in check.</description>\r\n * <param name=\"kingSquare\" type=\"object\">The square where the king is located.</param>\r\n * <param name=\"pseudo\" type=\"object\" optional=\"true\">The square where a piece is hypothetically moved.</param>\r\n * <param name=\"currentSquare\" type=\"object\" default=\"null\" optional=\"true\">The square of the piece being moved.</param>\r\n * <param name=\"color\" type=\"string\">The color of the king ('white' or 'black').</param>\r\n * <returns type=\"boolean\">True if the king is in check, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isWhiteInCheck\">\r\n * <description>Determines if the white king is in check.</description>\r\n * <param name=\"kingSquare\" type=\"object\">The square where the king is located.</param>\r\n * <param name=\"pseudo\" type=\"object\" optional=\"true\">The square where a piece is hypothetically moved.</param>\r\n * <param name=\"currentSquare\" type=\"object\" default=\"null\" optional=\"true\">The square of the piece being moved.</param>\r\n * <returns type=\"boolean\">True if the white king is in check, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isBlackInCheck\">\r\n * <description>Determines if the black king is in check.</description>\r\n * <param name=\"kingSquare\" type=\"object\">The square where the king is located.</param>\r\n * <param name=\"pseudo\" type=\"object\" optional=\"true\">The square where a piece is hypothetically moved.</param>\r\n * <param name=\"currentSquare\" type=\"object\" default=\"null\" optional=\"true\">The square of the piece being moved.</param>\r\n * <returns type=\"boolean\">True if the black king is in check, false otherwise.</returns>\r\n * </function>\r\n */\n\n/**\r\n * Checks if a character is Uppercase using the ASCII table.\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is uppercase, false otherwise.\r\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function IsUpperCase(value) {\n  return value.charCodeAt(0) >= 65 && value.charCodeAt(0) <= 90;\n}\n\n/**\r\n * Checks if a character is Lowercase using the ASCII table.\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is lowercase, false otherwise.\r\n */\n_c = IsUpperCase;\nexport function IsLowerCase(value) {\n  return value.charCodeAt(0) >= 97 && value.charCodeAt(0) <= 122;\n}\n\n/**\r\n * Checks if a character is a Digit using the ASCII table.\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is a digit, false otherwise.\r\n */\n_c2 = IsLowerCase;\nexport function IsDigit(value) {\n  return value.charCodeAt(0) >= 48 && value.charCodeAt(0) <= 57;\n}\n\n/**\r\n * Parses a FEN string and returns its components.\r\n * @param {string} fen - The FEN string to parse.\r\n * @returns {object} - An object containing the FEN components.\r\n */\n_c3 = IsDigit;\nexport function ParseFEN(fen) {\n  const fenParts = fen.split(' ');\n  if (fenParts.length !== 6) {\n    throw new Error('Invalid FEN');\n  }\n  const [fenBoard, fenTurn, fenCastling, fenEnPassant, fenHalfMoves, fenFullMoves] = fenParts;\n  return {\n    fenBoard,\n    fenTurn,\n    fenCastling,\n    fenEnPassant,\n    fenHalfMoves: Number(fenHalfMoves),\n    fenFullMoves: Number(fenFullMoves)\n  };\n}\n\n/**\r\n * Converts FEN piece notation to an actual piece.\r\n * @param {string} letter - The FEN notation of the piece.\r\n * @returns {string} - The actual piece.\r\n */\n_c4 = ParseFEN;\nexport function ConvertFENtoPiece(letter) {\n  const FEN_PIECE_MAP = {\n    [GlobalVariables.FEN_PIECES_BLACK.PAWN]: GlobalVariables.PIECES.PAWN,\n    [GlobalVariables.FEN_PIECES_BLACK.KNIGHT]: GlobalVariables.PIECES.KNIGHT,\n    [GlobalVariables.FEN_PIECES_BLACK.KING]: GlobalVariables.PIECES.KING,\n    [GlobalVariables.FEN_PIECES_BLACK.QUEEN]: GlobalVariables.PIECES.QUEEN,\n    [GlobalVariables.FEN_PIECES_BLACK.ROOK]: GlobalVariables.PIECES.ROOK,\n    [GlobalVariables.FEN_PIECES_BLACK.BISHOP]: GlobalVariables.PIECES.BISHOP\n  };\n  return FEN_PIECE_MAP[letter.toLowerCase()] || \"\";\n}\n\n/**\r\n * Converts the FEN piece notation to a piece that we can use in the square component.\r\n * @param {string} value - The FEN notation of the piece.\r\n * @returns {string} - The piece in {color-piece} format.\r\n */\n_c5 = ConvertFENtoPiece;\nexport function ConvertFENPieceToPiece(value) {\n  if (IsUpperCase(value)) {\n    return `${GlobalVariables.COLORS.WHITE}-${ConvertFENtoPiece(value)}`;\n  }\n  if (IsLowerCase(value)) {\n    return `${GlobalVariables.COLORS.BLACK}-${ConvertFENtoPiece(value)}`;\n  }\n  return \"\";\n}\n\n/**\r\n * Converts a string in FEN format to a normal string.\r\n * @param {string} value - The FEN string.\r\n * @returns {string} - The normal string.\r\n */\n_c6 = ConvertFENPieceToPiece;\nexport function ConvertFenToString(value) {\n  return value.split('').reduce((result, char) => {\n    if (IsDigit(char)) {\n      return result + GlobalVariables.EMPTY_SQUARE_PIECE.repeat(Number(char));\n    }\n    return result + char;\n  }, '');\n}\n\n/**\r\n * Checks if two squares are on the same row.\r\n * @param {object} square1 - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if the squares are on the same row, false otherwise.\r\n */\n_c7 = ConvertFenToString;\nexport function checkIfTwoSquaresAreOnTheSameRow(square1, square2) {\n  return square1.props.x === square2.props.x;\n}\n\n/**\r\n * Checks if the square is on the given row number.\r\n * @param {object} square - The square to check.\r\n * @param {number} rowNumber - The row number.\r\n * @returns {boolean} - True if the square is on the given row, false otherwise.\r\n */\nexport function isSquareOnRow(square, rowNumber) {\n  return square.props.x === rowNumber;\n}\n\n/**\r\n * Gets the piece from a square.\r\n * @param {object} square - The square to get the piece from.\r\n * @returns {string} - The piece.\r\n */\nexport function getPiece(square) {\n  return square.props.piece.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_PIECE_INDEX];\n}\n\n/**\r\n * Checks if a square has a specific piece.\r\n * @param {object} square - The square to check.\r\n * @param {string} piece - The piece to check for.\r\n * @returns {boolean} - True if the square has the piece, false otherwise.\r\n */\nexport function doesTheSquareHasThePiece(square, piece) {\n  return getPiece(square) === piece;\n}\n\n/**\r\n * Gets the piece color from a square.\r\n * @param {object} square - The square to get the piece color from.\r\n * @returns {string} - The piece color.\r\n */\nexport function getPieceColor(square) {\n  return square.props.piece.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_COLOR_INDEX];\n}\n\n/**\r\n * Checks if a color is white.\r\n * @param {string} color - The color to check.\r\n * @returns {boolean} - True if the color is white, false otherwise.\r\n */\nexport function isColorWhite(color) {\n  return color === GlobalVariables.COLORS.WHITE;\n}\n\n/**\r\n * Checks if a color is black.\r\n * @param {string} color - The color to check.\r\n * @returns {boolean} - True if the color is black, false otherwise.\r\n */\nexport function isColorBlack(color) {\n  return color === GlobalVariables.COLORS.BLACK;\n}\n\n/**\r\n * Checks if two pieces are of the same color.\r\n * @param {string} piece1 - The first piece.\r\n * @param {string} piece2 - The second piece.\r\n * @returns {boolean} - True if the pieces are of the same color, false otherwise.\r\n */\nexport function areSameColor(piece1, piece2) {\n  const color1 = piece1.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_COLOR_INDEX];\n  const color2 = piece2.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_COLOR_INDEX];\n  return color1 === color2;\n}\n\n/**\r\n * Checks if a move is equal to the current selected square.\r\n * @param {object} move - The move to check.\r\n * @returns {boolean} - True if the move is equal to the current selected square, false otherwise.\r\n */\nexport function checkIfAMoveIsEqualToTheCurrentSelectedSquare(move) {\n  return move.props.x === GlobalVariables.CurrentSquareSelection.x && move.props.y === GlobalVariables.CurrentSquareSelection.y;\n}\n\n/**\r\n * Compares if two squares are the same.\r\n * @param {object} square1 - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if the squares are the same, false otherwise.\r\n */\nexport function compareIfTwoSquaresAreTheSame(square1, square2) {\n  return square1.props.x === square2.props.x && square1.props.y === square2.props.y;\n}\n\n/**\r\n * Gets a target square by its location.\r\n * @param {number} x - The x coordinate of the target square.\r\n * @param {number} y - The y coordinate of the target square.\r\n * @returns {object} - The target square.\r\n */\nexport function getATargetSquareByLocation(x, y, squares) {\n  return GlobalVariables.BoardPosition[x][y];\n}\n\n/**\r\n * Gets a target square by its piece.\r\n * @param {string} piece - The piece to search for.\r\n * @returns {object} - The target square.\r\n */\nexport function getATargetSquareByPiece(piece) {\n  for (let row of GlobalVariables.BoardPosition) {\n    for (let square of row) {\n      if (square.props.piece === piece) {\n        return square;\n      }\n    }\n  }\n  return null;\n}\n\n/**\r\n * Checks if castling is possible.\r\n * @param {string} castlingType - The type of castling (long or short).\r\n * @param {boolean} [withWhite=true] - True if checking for white's castling, false otherwise.\r\n * @returns {boolean} - True if castling is possible, false otherwise.\r\n */\nexport function isCastlingPossible(castlingType, withWhite = true) {\n  const row = withWhite ? GlobalVariables.CASTLE_ROW_WHITE : GlobalVariables.CASTLE_ROW_BLACK;\n  const pieces = withWhite ? GlobalVariables.FEN_PIECES_WHITE : GlobalVariables.FEN_PIECES_BLACK;\n  const [rookCol, kingCol, pathCols] = castlingType === GlobalVariables.CASTLING_TYPES.LONG ? [GlobalVariables.CASTLE_ROOK_INITIAL_COL_LONG, GlobalVariables.CASTLE_KING_INITIAL_COL, GlobalVariables.CASTLE_PATH_COLS_LONG] : [GlobalVariables.CASTLE_ROOK_INITIAL_COL_SHORT, GlobalVariables.CASTLE_KING_INITIAL_COL, GlobalVariables.CASTLE_PATH_COLS_SHORT];\n  return GlobalVariables.BoardPosition[row][rookCol] === pieces.ROOK && GlobalVariables.BoardPosition[row][kingCol] === pieces.KING && pathCols.every(col => GlobalVariables.BoardPosition[row][col] === GlobalVariables.EMPTY_SQUARE_PIECE);\n}\n\n/**\r\n * Checks if a pawn is on its starting square.\r\n * @param {object} pawn - The pawn to check.\r\n * @returns {boolean} - True if the pawn is on its starting square, false otherwise.\r\n */\nexport function isPawnOnStartingSquare(pawn) {\n  const isWhite = isColorWhite(getPieceColor(pawn));\n  return isWhite ? pawn.props.x === GlobalVariables.WHITE_PAWN_STARTING_SQUARE : pawn.props.x === GlobalVariables.BLACK_PAWN_STARTING_SQUARE;\n}\n\n/**\r\n * Checks if a pawn is on an en passant square.\r\n * @param {object} pawn - The pawn to check.\r\n * @returns {boolean} - True if the pawn is on an en passant square, false otherwise.\r\n */\nexport function isPawnOnEnPassantSquare(pawn) {\n  const isWhite = isColorWhite(getPieceColor(pawn));\n  return isWhite ? pawn.props.x === GlobalVariables.WHITE_EN_PASSANT_SQUARE : pawn.props.x === GlobalVariables.BLACK_EN_PASSANT_SQUARE;\n}\n\n/**\r\n * Checks if a square is available for a move.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the square is available, false otherwise.\r\n */\nexport function isSquareAvailable(square) {\n  return !square.props.piece;\n}\n\n/**\r\n * Updates a column on a row with a new value.\r\n * @param {Array} row - The row to update.\r\n * @param {number} colIndex - The column index.\r\n * @param {string} newValue - The new value.\r\n * @returns {Array} - The updated row.\r\n */\nexport function updateColumnOnARow(row, colIndex, newValue) {\n  row[colIndex] = newValue;\n  return row;\n}\n\n/**\r\n * Removes the current square's piece.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\nexport function handleSquareOnCurrentRow(currentSquare, targetSquare, row) {\n  return checkIfTwoSquaresAreOnTheSameRow(currentSquare, targetSquare) ? handleSquareAndTargetSquareOnTheSameRow(currentSquare, targetSquare, row) : updateColumnOnARow(row, currentSquare.props.y, GlobalVariables.EMPTY_SQUARE_PIECE);\n}\n\n/**\r\n * Updates the target square with the current square's piece.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\nexport function handleTargetSquareOnCurrentRow(currentSquare, targetSquare, row) {\n  return updateColumnOnARow(row, targetSquare.props.y, ConvertPieceToFENPiece(currentSquare.props.piece));\n}\n\n/**\r\n * Checks if we're making a move on the same row and performs castling if we want to castle.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\nexport function handleSquareAndTargetSquareOnTheSameRow(currentSquare, targetSquare, row) {\n  if (doesTheSquareHasThePiece(currentSquare, GlobalVariables.PIECES.KING) && isCastlingPossible(currentSquare, targetSquare)) {\n    return handleCastling(currentSquare, row);\n  }\n  return SidewaysCapture(row, Number(currentSquare.props.y), Number(targetSquare.props.y), currentSquare.props.piece);\n}\n\n/**\r\n * Performs castling by swapping the rook and the king.\r\n * @param {object} square - The square to update.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\nexport function handleCastling(square, row) {\n  const color = getPieceColor(square);\n  const isWhite = isColorWhite(color);\n  const kingPiece = isWhite ? GlobalVariables.FEN_PIECES_WHITE.KING : GlobalVariables.FEN_PIECES_BLACK.KING;\n  const rookPiece = isWhite ? GlobalVariables.FEN_PIECES_WHITE.ROOK : GlobalVariables.FEN_PIECES_BLACK.ROOK;\n  Object.values(GlobalVariables.CASTLING_TYPES).forEach(type => {\n    if (isCastlingPossible(type, isWhite)) {\n      const [emptySquares, kingFinalCol, rookFinalCol] = type === GlobalVariables.CASTLING_TYPES.LONG ? [GlobalVariables.EMPTY_SQUARES_AFTER_LONG_CASTLE, GlobalVariables.CASTLE_KING_FINAL_COL_LONG, GlobalVariables.CASTLE_ROOK_FINAL_COL_LONG] : [GlobalVariables.EMPTY_SQUARES_AFTER_SHORT_CASTLE, GlobalVariables.CASTLE_KING_FINAL_COL_SHORT, GlobalVariables.CASTLE_ROOK_FINAL_COL_SHORT];\n      emptySquares.forEach(col => row[col] = GlobalVariables.EMPTY_SQUARE_PIECE);\n      row[kingFinalCol] = kingPiece;\n      row[rookFinalCol] = rookPiece;\n    }\n  });\n  return row;\n}\n\n/**\r\n * Converts a row of squares to its FEN representation.\r\n * @param {Array} row - The row to convert.\r\n * @returns {string} - The FEN representation of the row.\r\n */\nexport function convertRowToFEN(row) {\n  return row.reduce((acc, column) => {\n    if (column === EMPTY_SQUARE_PIECE) {\n      const lastChar = acc.slice(-1);\n      if (IsDigit(lastChar)) {\n        return acc.slice(0, -1) + (Number(lastChar) + 1);\n      } else {\n        return acc + '1';\n      }\n    } else {\n      return acc + column;\n    }\n  }, '');\n}\n\n/**\r\n * Gets the castling rules as a string.\r\n * @returns {string} - The castling rules.\r\n */\nexport function getCastlingRules() {\n  return Object.values(GlobalVariables.CastlingRights).map(right => right ? right : \"\").join(\"\") || \"-\";\n}\n\n/**\r\n * Generates a new FEN string based on the current board state.\r\n * @returns {string} - The new FEN string.\r\n */\nexport function generateANewFen() {\n  const fenRows = GlobalVariables.BoardPosition.map(row => convertRowToFEN(row)).join('/');\n  const turn = GlobalVariables.IsWhiteToMove ? 'w' : 'b';\n  const castling = getCastlingRules();\n  const enPassant = GlobalVariables.EnPassant.isPossible ? convertLocationToCoordinates(GlobalVariables.EnPassant.x, GlobalVariables.EnPassant.y) : '-';\n  const halfMoves = GlobalVariables.HalfMoves;\n  const fullMoves = GlobalVariables.FullMoves;\n  return `${fenRows} ${turn} ${castling} ${enPassant} ${halfMoves} ${fullMoves}`;\n}\n\n/**\r\n * Updates castling rights based on the given castling string.\r\n * @param {string} castling - The castling rights string (e.g., 'KQkq').\r\n */\nexport function updateCastlingRights(castling) {\n  const castlingMap = {\n    'K': 'whiteShortCastle',\n    'Q': 'whiteLongCastle',\n    'k': 'blackShortCastle',\n    'q': 'blackLongCastle'\n  };\n  Object.keys(castlingMap).forEach(key => {\n    GlobalVariables.CastlingRights[castlingMap[key]] = castling.includes(key);\n  });\n}\n\n/**\r\n * Updates en passant status based on the given en passant string.\r\n * @param {string} enPassant - The en passant target square (e.g., 'e3') or '-' if not available.\r\n */\nexport function updateEnPassant(enPassant) {\n  if (enPassant !== GlobalVariables.PIECE_DELIMITER) {\n    const {\n      x,\n      y\n    } = convertCoordinatesToLocation(enPassant);\n    Object.assign(GlobalVariables.EnPassant, {\n      isPossible: true,\n      x: x,\n      y: y\n    });\n  }\n}\n\n/**\r\n * Parses the FEN string to update the board state.\r\n * @param {string} fen - The FEN string representing the board state.\r\n * @param {Array} isPossibleMove - Array indicating possible moves.\r\n * @param {function} getPossibleMoves - Function to get possible moves.\r\n * @param {function} movePiece - Function to move a piece.\r\n * @param {function} resetPossibleMoves - Function to reset possible moves.\r\n * @param {boolean} [updateBoardPosition=true] - Whether to update the board position.\r\n * @returns {Array} - The generated square components.\r\n */\nexport function fenParser(fen, isPossibleMove, getPossibleMoves, movePiece, resetPossibleMoves, updateBoardPosition = true) {\n  const {\n    fenBoard,\n    fenTurn,\n    fenCastling,\n    fenEnPassant,\n    fenHalfMoves,\n    fenFullMoves\n  } = ParseFEN(fen);\n  const fenRows = fenBoard.split('/');\n  const boardArray = fenRows.map(row => ConvertFenToString(row).split(''));\n  const squares = generateSquareComponents(boardArray, isPossibleMove, getPossibleMoves, movePiece, resetPossibleMoves);\n  updateCastlingRights(fenCastling);\n  GlobalVariables.updateIsWhiteToMove(fenTurn === 'w');\n  GlobalVariables.updateHalfMoves(fenHalfMoves);\n  GlobalVariables.updateFullMoves(fenFullMoves);\n  if (updateBoardPosition) {\n    GlobalVariables.BoardPosition.splice(0, GlobalVariables.BoardPosition.length, ...boardArray);\n  }\n  updateEnPassant(fenEnPassant);\n  return squares;\n}\n\n/**\r\n * Updates the board position after making a move.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @returns {Array} - The updated board position.\r\n */\nexport function updateBoardPosition(currentSquare, targetSquare) {\n  return GlobalVariables.BoardPosition.map((row, rowIndex) => {\n    if (isSquareOnRow(currentSquare, rowIndex)) {\n      row = handleSquareOnCurrentRow(currentSquare, targetSquare, row);\n    }\n    if (isSquareOnRow(targetSquare, rowIndex)) {\n      row = handleTargetSquareOnCurrentRow(currentSquare, targetSquare, row);\n    }\n    return row;\n  });\n}\n\n/**\r\n * Modifies the row to capture pieces sideways.\r\n * @param {Array} row - The row to update.\r\n * @param {number} colIndex - The column index of the current square.\r\n * @param {number} targetColIndex - The column index of the target square.\r\n * @param {string} value - The piece value.\r\n * @returns {Array} - The updated row.\r\n */\nexport function SidewaysCapture(row, colIndex, targetColIndex, value) {\n  return row.map((col, index) => {\n    if (index === colIndex) return GlobalVariables.EMPTY_SQUARE_PIECE;\n    if (index === targetColIndex) return ConvertPieceToFENPiece(value);\n    return col;\n  });\n}\n\n/**\r\n * Converts the piece from {color-piece} format to FEN format (a single letter).\r\n * @param {string} value - The piece value.\r\n * @returns {string} - The FEN notation of the piece.\r\n */\n_c8 = SidewaysCapture;\nexport function ConvertPieceToFENPiece(value) {\n  const [color, piece] = value.split(GlobalVariables.PIECE_DELIMITER);\n  const pieceMapping = {\n    [GlobalVariables.PIECES.PAWN]: GlobalVariables.FEN_PIECES_BLACK.PAWN,\n    [GlobalVariables.PIECES.KNIGHT]: GlobalVariables.FEN_PIECES_BLACK.KNIGHT,\n    [GlobalVariables.PIECES.BISHOP]: GlobalVariables.FEN_PIECES_BLACK.BISHOP,\n    [GlobalVariables.PIECES.ROOK]: GlobalVariables.FEN_PIECES_BLACK.ROOK,\n    [GlobalVariables.PIECES.QUEEN]: GlobalVariables.FEN_PIECES_BLACK.QUEEN,\n    [GlobalVariables.PIECES.KING]: GlobalVariables.FEN_PIECES_BLACK.KING\n  };\n  const fenPiece = pieceMapping[piece];\n  return isColorWhite(color) ? fenPiece.toUpperCase() : fenPiece;\n}\n\n/**\r\n * Generates Square components for the given board state.\r\n * @param {Array} boardSquares - The 2D array representing the board squares.\r\n * @param {Array} isPossibleMove - The array of possible move states.\r\n * @param {Function} getPossibleMoves - The function to get possible moves.\r\n * @param {Function} movePiece - The function to move a piece.\r\n * @param {Function} resetPossibleMoves - The function to reset possible moves.\r\n * @returns {Array} - The array of Square components.\r\n */\n_c9 = ConvertPieceToFENPiece;\nexport function generateSquareComponents(boardSquares, isPossibleMove, getPossibleMoves, movePiece, resetPossibleMoves) {\n  let squareColorIsWhite = true;\n  const squares = boardSquares.flatMap((row, rowIndex) => {\n    const rowSquares = row.map((square, colIndex) => {\n      const color = squareColorIsWhite ? \"\" : \"dark\";\n      const possibleMoveStatus = isPossibleMove.find(item => item.key === `${rowIndex}-${colIndex}`);\n      const squareComponent = /*#__PURE__*/_jsxDEV(Square, {\n        x: rowIndex,\n        y: colIndex,\n        piece: ConvertFENPieceToPiece(square),\n        color: color,\n        getPossibleMoves: getPossibleMoves,\n        movePiece: movePiece,\n        isPossibleMove: possibleMoveStatus ? possibleMoveStatus.value : false,\n        resetPossibleMoves: resetPossibleMoves\n      }, `${rowIndex}-${colIndex}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 836,\n        columnNumber: 17\n      }, this);\n      squareColorIsWhite = !squareColorIsWhite;\n      return squareComponent;\n    });\n    squareColorIsWhite = !squareColorIsWhite; // Reset color for the next row\n    return rowSquares;\n  });\n  return squares;\n}\n\n/**\r\n * Converts board coordinates to X and Y position on the board, e.g., a8 = 0, 0\r\n * @param {string} coordinates - The board coordinates to convert.\r\n * @returns {object} - Returns an object with x and y properties.\r\n */\nexport function convertCoordinatesToLocation(coordinates) {\n  let tokens = coordinates.split('');\n\n  //skip invalid coordinates\n  if (tokens.length != 2) {\n    return;\n  }\n  let letter = tokens[0].toString().toUpperCase();\n  let number = tokens[1];\n\n  //65 is the ASCII code for capital A which will give us 0 if we have A as a coordinate; A-F will give us 0-7 for y (columns)\n  //reverse the numbers since we draw the board top down for x (rows)\n  return {\n    x: GlobalVariables.DIM - Number(number),\n    y: letter.charCodeAt(0) - 65\n  };\n}\n\n/**\r\n * Converts a piece location to board coordinate, e.g., 0, 0 to a8\r\n * @param {string} x - The X position.\r\n * @param {string} y - The Y position.\r\n * @returns {string} - Returns a string containing the board coordinates.\r\n */\nexport function convertLocationToCoordinates(x, y) {\n  //maps y (column) to the letter coordinate; add 65 (capital A code) to the ASCII code for the location we have and we get a letter between A and F\n  //reverses the x (rows) coordinate because we drop the board top down, while coordinates go down up\n  return `${String.fromCharCode(y + 65)}${GlobalVariables.DIM - x}`.toLowerCase();\n}\n\n/**\r\n * Determines if the king is in check.\r\n * @param {object} kingSquare - The square where the king is located.\r\n * @param {object} [pseudo] - The square where a piece is hypothetically moved.\r\n * @param {object} [currentSquare=null] - The square of the piece being moved.\r\n * @param {string} color - The color of the king ('white' or 'black').\r\n * @returns {boolean} - True if the king is in check, false otherwise.\r\n */\nexport function isKingInCheck(kingSquare, pseudo, currentSquare = null, color) {\n  const squares = boardSquaresRef.current;\n  const updatedSquares = squares.map(s => {\n    if (pseudo && s.props.x === pseudo.props.x && s.props.y === pseudo.props.y) {\n      return /*#__PURE__*/React.cloneElement(s, {\n        piece: pseudo.props.piece\n      });\n    } else if (currentSquare && s.props.x === currentSquare.props.x && s.props.y === currentSquare.props.y) {\n      return /*#__PURE__*/React.cloneElement(s, {\n        piece: ''\n      });\n    } else {\n      return s;\n    }\n  });\n  const checkDirections = directions => {\n    for (const [dx, dy] of directions) {\n      for (let i = 1; i < GlobalVariables.DIM; i++) {\n        const piece = updatedSquares.find(s => s.props.x === kingSquare.props.x + dx * i && s.props.y === kingSquare.props.y + dy * i);\n        if (!piece) break;\n        const [pieceColor, pieceType] = piece.props.piece.split(\"-\");\n        if (pieceColor !== color) {\n          if (pieceType === \"queen\" || pieceType === \"rook\" || pieceType === \"bishop\" || i === 1 && pieceType === \"pawn\" && (dx === -1 || dx === 1)) {\n            return true;\n          }\n          if (piece.props.piece) break;\n        } else {\n          break;\n        }\n      }\n    }\n    return false;\n  };\n  const linearDirections = [[1, 0], [-1, 0], [0, 1], [0, -1] // Right, Left, Up, Down\n  ];\n  const diagonalDirections = [[1, 1], [-1, -1], [1, -1], [-1, 1] // Diagonals\n  ];\n  if (checkDirections(linearDirections) || checkDirections(diagonalDirections)) {\n    return true;\n  }\n  const knightMoves = [[-2, -1], [-2, 1], [2, -1], [2, 1], [-1, 2], [1, 2], [-1, -2], [1, -2]];\n  for (const [dx, dy] of knightMoves) {\n    const piece = updatedSquares.find(s => s.props.x === kingSquare.props.x + dx && s.props.y === kingSquare.props.y + dy);\n    if (piece && piece.props.piece.split(\"-\")[0] !== color && piece.props.piece.split(\"-\")[1] === \"knight\") {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\r\n * Determines if the white king is in check.\r\n * @param {object} kingSquare - The square where the king is located.\r\n * @param {object} [pseudo] - The square where a piece is hypothetically moved.\r\n * @param {object} [currentSquare=null] - The square of the piece being moved.\r\n * @returns {boolean} - True if the white king is in check, false otherwise.\r\n */\nexport function isWhiteInCheck(kingSquare, pseudo, currentSquare = null) {\n  return isKingInCheck(kingSquare, pseudo, currentSquare, 'white');\n}\n\n/**\r\n * Determines if the black king is in check.\r\n * @param {object} kingSquare - The square where the king is located.\r\n * @param {object} [pseudo] - The square where a piece is hypothetically moved.\r\n * @param {object} [currentSquare=null] - The square of the piece being moved.\r\n * @returns {boolean} - True if the black king is in check, false otherwise.\r\n */\nexport function isBlackInCheck(kingSquare, pseudo, currentSquare = null) {\n  return isKingInCheck(kingSquare, pseudo, currentSquare, 'black');\n}\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9;\n$RefreshReg$(_c, \"IsUpperCase\");\n$RefreshReg$(_c2, \"IsLowerCase\");\n$RefreshReg$(_c3, \"IsDigit\");\n$RefreshReg$(_c4, \"ParseFEN\");\n$RefreshReg$(_c5, \"ConvertFENtoPiece\");\n$RefreshReg$(_c6, \"ConvertFENPieceToPiece\");\n$RefreshReg$(_c7, \"ConvertFenToString\");\n$RefreshReg$(_c8, \"SidewaysCapture\");\n$RefreshReg$(_c9, \"ConvertPieceToFENPiece\");","map":{"version":3,"names":["React","Square","GlobalVariables","jsxDEV","_jsxDEV","IsUpperCase","value","charCodeAt","_c","IsLowerCase","_c2","IsDigit","_c3","ParseFEN","fen","fenParts","split","length","Error","fenBoard","fenTurn","fenCastling","fenEnPassant","fenHalfMoves","fenFullMoves","Number","_c4","ConvertFENtoPiece","letter","FEN_PIECE_MAP","FEN_PIECES_BLACK","PAWN","PIECES","KNIGHT","KING","QUEEN","ROOK","BISHOP","toLowerCase","_c5","ConvertFENPieceToPiece","COLORS","WHITE","BLACK","_c6","ConvertFenToString","reduce","result","char","EMPTY_SQUARE_PIECE","repeat","_c7","checkIfTwoSquaresAreOnTheSameRow","square1","square2","props","x","isSquareOnRow","square","rowNumber","getPiece","piece","PIECE_DELIMITER","PIECE_PIECE_INDEX","doesTheSquareHasThePiece","getPieceColor","PIECE_COLOR_INDEX","isColorWhite","color","isColorBlack","areSameColor","piece1","piece2","color1","color2","checkIfAMoveIsEqualToTheCurrentSelectedSquare","move","CurrentSquareSelection","y","compareIfTwoSquaresAreTheSame","getATargetSquareByLocation","squares","BoardPosition","getATargetSquareByPiece","row","isCastlingPossible","castlingType","withWhite","CASTLE_ROW_WHITE","CASTLE_ROW_BLACK","pieces","FEN_PIECES_WHITE","rookCol","kingCol","pathCols","CASTLING_TYPES","LONG","CASTLE_ROOK_INITIAL_COL_LONG","CASTLE_KING_INITIAL_COL","CASTLE_PATH_COLS_LONG","CASTLE_ROOK_INITIAL_COL_SHORT","CASTLE_PATH_COLS_SHORT","every","col","isPawnOnStartingSquare","pawn","isWhite","WHITE_PAWN_STARTING_SQUARE","BLACK_PAWN_STARTING_SQUARE","isPawnOnEnPassantSquare","WHITE_EN_PASSANT_SQUARE","BLACK_EN_PASSANT_SQUARE","isSquareAvailable","updateColumnOnARow","colIndex","newValue","handleSquareOnCurrentRow","currentSquare","targetSquare","handleSquareAndTargetSquareOnTheSameRow","handleTargetSquareOnCurrentRow","ConvertPieceToFENPiece","handleCastling","SidewaysCapture","kingPiece","rookPiece","Object","values","forEach","type","emptySquares","kingFinalCol","rookFinalCol","EMPTY_SQUARES_AFTER_LONG_CASTLE","CASTLE_KING_FINAL_COL_LONG","CASTLE_ROOK_FINAL_COL_LONG","EMPTY_SQUARES_AFTER_SHORT_CASTLE","CASTLE_KING_FINAL_COL_SHORT","CASTLE_ROOK_FINAL_COL_SHORT","convertRowToFEN","acc","column","lastChar","slice","getCastlingRules","CastlingRights","map","right","join","generateANewFen","fenRows","turn","IsWhiteToMove","castling","enPassant","EnPassant","isPossible","convertLocationToCoordinates","halfMoves","HalfMoves","fullMoves","FullMoves","updateCastlingRights","castlingMap","keys","key","includes","updateEnPassant","convertCoordinatesToLocation","assign","fenParser","isPossibleMove","getPossibleMoves","movePiece","resetPossibleMoves","updateBoardPosition","boardArray","generateSquareComponents","updateIsWhiteToMove","updateHalfMoves","updateFullMoves","splice","rowIndex","targetColIndex","index","_c8","pieceMapping","fenPiece","toUpperCase","_c9","boardSquares","squareColorIsWhite","flatMap","rowSquares","possibleMoveStatus","find","item","squareComponent","fileName","_jsxFileName","lineNumber","columnNumber","coordinates","tokens","toString","number","DIM","String","fromCharCode","isKingInCheck","kingSquare","pseudo","boardSquaresRef","current","updatedSquares","s","cloneElement","checkDirections","directions","dx","dy","i","pieceColor","pieceType","linearDirections","diagonalDirections","knightMoves","isWhiteInCheck","isBlackInCheck","$RefreshReg$"],"sources":["C:/Users/Vladi Gotsin/Desktop/react/Chess-React.js-/src/HelperMethods.js"],"sourcesContent":["import React from 'react';\r\nimport Square from \"./Square.js\"\r\nimport * as GlobalVariables from './globalVariables';\r\n\r\n/**\r\n * <summary>\r\n * This module provides various helper functions for handling chess board state, \r\n * manipulating FEN strings, and generating square components for the chess board.\r\n * </summary>\r\n * \r\n * <function name=\"IsUpperCase\">\r\n * <description>Checks if a character is Uppercase using the ASCII table.</description>\r\n * <param name=\"value\" type=\"string\">The character to check.</param>\r\n * <returns type=\"boolean\">True if the character is uppercase, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"IsLowerCase\">\r\n * <description>Checks if a character is Lowercase using the ASCII table.</description>\r\n * <param name=\"value\" type=\"string\">The character to check.</param>\r\n * <returns type=\"boolean\">True if the character is lowercase, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"IsDigit\">\r\n * <description>Checks if a character is a Digit using the ASCII table.</description>\r\n * <param name=\"value\" type=\"string\">The character to check.</param>\r\n * <returns type=\"boolean\">True if the character is a digit, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"ParseFEN\">\r\n * <description>Parses a FEN string and returns its components.</description>\r\n * <param name=\"fen\" type=\"string\">The FEN string to parse.</param>\r\n * <returns type=\"object\">An object containing the FEN components.</returns>\r\n * </function>\r\n * \r\n * <function name=\"ConvertFENtoPiece\">\r\n * <description>Converts FEN piece notation to an actual piece.</description>\r\n * <param name=\"letter\" type=\"string\">The FEN notation of the piece.</param>\r\n * <returns type=\"string\">The actual piece.</returns>\r\n * </function>\r\n * \r\n * <function name=\"ConvertFENPieceToPiece\">\r\n * <description>Converts the FEN piece notation to a piece that can be used in the square component.</description>\r\n * <param name=\"value\" type=\"string\">The FEN notation of the piece.</param>\r\n * <returns type=\"string\">The piece in {color-piece} format.</returns>\r\n * </function>\r\n * \r\n * <function name=\"ConvertFenToString\">\r\n * <description>Converts a string in FEN format to a normal string.</description>\r\n * <param name=\"value\" type=\"string\">The FEN string.</param>\r\n * <returns type=\"string\">The normal string.</returns>\r\n * </function>\r\n * \r\n * <function name=\"checkIfTwoSquaresAreOnTheSameRow\">\r\n * <description>Checks if two squares are on the same row.</description>\r\n * <param name=\"square1\" type=\"object\">The first square.</param>\r\n * <param name=\"square2\" type=\"object\">The second square.</param>\r\n * <returns type=\"boolean\">True if the squares are on the same row, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isSquareOnRow\">\r\n * <description>Checks if the square is on the given row number.</description>\r\n * <param name=\"square\" type=\"object\">The square to check.</param>\r\n * <param name=\"rowNumber\" type=\"number\">The row number.</param>\r\n * <returns type=\"boolean\">True if the square is on the given row, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"getPiece\">\r\n * <description>Gets the piece from a square.</description>\r\n * <param name=\"square\" type=\"object\">The square to get the piece from.</param>\r\n * <returns type=\"string\">The piece.</returns>\r\n * </function>\r\n * \r\n * <function name=\"doesTheSquareHasThePiece\">\r\n * <description>Checks if a square has a specific piece.</description>\r\n * <param name=\"square\" type=\"object\">The square to check.</param>\r\n * <param name=\"piece\" type=\"string\">The piece to check for.</param>\r\n * <returns type=\"boolean\">True if the square has the piece, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"getPieceColor\">\r\n * <description>Gets the piece color from a square.</description>\r\n * <param name=\"square\" type=\"object\">The square to get the piece color from.</param>\r\n * <returns type=\"string\">The piece color.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isColorWhite\">\r\n * <description>Checks if a color is white.</description>\r\n * <param name=\"color\" type=\"string\">The color to check.</param>\r\n * <returns type=\"boolean\">True if the color is white, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isColorBlack\">\r\n * <description>Checks if a color is black.</description>\r\n * <param name=\"color\" type=\"string\">The color to check.</param>\r\n * <returns type=\"boolean\">True if the color is black, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"areSameColor\">\r\n * <description>Checks if two pieces are of the same color.</description>\r\n * <param name=\"piece1\" type=\"string\">The first piece.</param>\r\n * <param name=\"piece2\" type=\"string\">The second piece.</param>\r\n * <returns type=\"boolean\">True if the pieces are of the same color, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"checkIfAMoveIsEqualToTheCurrentSelectedSquare\">\r\n * <description>Checks if a move is equal to the current selected square.</description>\r\n * <param name=\"move\" type=\"object\">The move to check.</param>\r\n * <returns type=\"boolean\">True if the move is equal to the current selected square, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"compareIfTwoSquaresAreTheSame\">\r\n * <description>Compares if two squares are the same.</description>\r\n * <param name=\"square1\" type=\"object\">The first square.</param>\r\n * <param name=\"square2\" type=\"object\">The second square.</param>\r\n * <returns type=\"boolean\">True if the squares are the same, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"getATargetSquareByLocation\">\r\n * <description>Gets a target square by its location.</description>\r\n * <param name=\"x\" type=\"number\">The x coordinate of the target square.</param>\r\n * <param name=\"y\" type=\"number\">The y coordinate of the target square.</param>\r\n * <returns type=\"object\">The target square.</returns>\r\n * </function>\r\n * \r\n * <function name=\"getATargetSquareByPiece\">\r\n * <description>Gets a target square by its piece.</description>\r\n * <param name=\"piece\" type=\"string\">The piece to search for.</param>\r\n * <returns type=\"object\">The target square.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isCastlingPossible\">\r\n * <description>Checks if castling is possible.</description>\r\n * <param name=\"castlingType\" type=\"string\">The type of castling (long or short).</param>\r\n * <param name=\"withWhite\" type=\"boolean\">True if checking for white's castling, false otherwise.</param>\r\n * <returns type=\"boolean\">True if castling is possible, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isPawnOnStartingSquare\">\r\n * <description>Checks if a pawn is on its starting square.</description>\r\n * <param name=\"pawn\" type=\"object\">The pawn to check.</param>\r\n * <returns type=\"boolean\">True if the pawn is on its starting square, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isPawnOnEnPassantSquare\">\r\n * <description>Checks if a pawn is on an en passant square.</description>\r\n * <param name=\"pawn\" type=\"object\">The pawn to check.</param>\r\n * <returns type=\"boolean\">True if the pawn is on an en passant square, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isSquareAvailable\">\r\n * <description>Checks if a square is available for a move.</description>\r\n * <param name=\"square\" type=\"object\">The square to check.</param>\r\n * <returns type=\"boolean\">True if the square is available, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"updateColumnOnARow\">\r\n * <description>Updates a column on a row with a new value.</description>\r\n * <param name=\"row\" type=\"Array\">The row to update.</param>\r\n * <param name=\"colIndex\" type=\"number\">The column index.</param>\r\n * <param name=\"newValue\" type=\"string\">The new value.</param>\r\n * <returns type=\"Array\">The updated row.</returns>\r\n * </function>\r\n * \r\n * <function name=\"handleSquareOnCurrentRow\">\r\n * <description>Removes the current square's piece.</description>\r\n * <param name=\"currentSquare\" type=\"object\">The current square.</param>\r\n * <param name=\"targetSquare\" type=\"object\">The target square.</param>\r\n * <param name=\"row\" type=\"Array\">The row to update.</param>\r\n * <returns type=\"Array\">The updated row.</returns>\r\n * </function>\r\n * \r\n * <function name=\"handleTargetSquareOnCurrentRow\">\r\n * <description>Updates the target square with the current square's piece.</description>\r\n * <param name=\"currentSquare\" type=\"object\">The current square.</param>\r\n * <param name=\"targetSquare\" type=\"object\">The target square.</param>\r\n * <param name=\"row\" type=\"Array\">The row to update.</param>\r\n * <returns type=\"Array\">The updated row.</returns>\r\n * </function>\r\n * \r\n * <function name=\"handleSquareAndTargetSquareOnTheSameRow\">\r\n * <description>Checks if we're making a move on the same row and performs castling if we want to castle.</description>\r\n * <param name=\"currentSquare\" type=\"object\">The current square.</param>\r\n * <param name=\"targetSquare\" type=\"object\">The target square.</param>\r\n * <param name=\"row\" type=\"Array\">The row to update.</param>\r\n * <returns type=\"Array\">The updated row.</returns>\r\n * </function>\r\n * \r\n * <function name=\"handleCastling\">\r\n * <description>Performs castling by swapping the rook and the king.</description>\r\n * <param name=\"square\" type=\"object\">The square to update.</param>\r\n * <param name=\"row\" type=\"Array\">The row to update.</param>\r\n * <returns type=\"Array\">The updated row.</returns>\r\n * </function>\r\n * \r\n * <function name=\"convertRowToFEN\">\r\n * <description>Converts a row of squares to its FEN representation.</description>\r\n * <param name=\"row\" type=\"Array\">The row to convert.</param>\r\n * <returns type=\"string\">The FEN representation of the row.</returns>\r\n * </function>\r\n * \r\n * <function name=\"getCastlingRules\">\r\n * <description>Gets the castling rules as a string.</description>\r\n * <returns type=\"string\">The castling rules.</returns>\r\n * </function>\r\n * \r\n * <function name=\"generateANewFen\">\r\n * <description>Generates a new FEN string based on the current board state.</description>\r\n * <returns type=\"string\">The new FEN string.</returns>\r\n * </function>\r\n * \r\n * <function name=\"updateCastlingRights\">\r\n * <description>Updates castling rights based on the given castling string.</description>\r\n * <param name=\"castling\" type=\"string\">The castling rights string (e.g., 'KQkq').</param>\r\n * </function>\r\n * \r\n * <function name=\"updateEnPassant\">\r\n * <description>Updates en passant status based on the given en passant string.</description>\r\n * <param name=\"enPassant\" type=\"string\">The en passant target square (e.g., 'e3') or '-' if not available.</param>\r\n * </function>\r\n * \r\n * <function name=\"fenParser\">\r\n * <description>Parses the FEN string to update the board state.</description>\r\n * <param name=\"fen\" type=\"string\">The FEN string representing the board state.</param>\r\n * <param name=\"isPossibleMove\" type=\"Array\">Array indicating possible moves.</param>\r\n * <param name=\"getPossibleMoves\" type=\"Function\">Function to get possible moves.</param>\r\n * <param name=\"movePiece\" type=\"Function\">Function to move a piece.</param>\r\n * <param name=\"resetPossibleMoves\" type=\"Function\">Function to reset possible moves.</param>\r\n * <param name=\"updateBoardPosition\" type=\"boolean\" default=\"true\">Whether to update the board position.</param>\r\n * <returns type=\"Array\">The generated square components.</returns>\r\n * </function>\r\n * \r\n * <function name=\"updateBoardPosition\">\r\n * <description>Updates the board position after making a move.</description>\r\n * <param name=\"currentSquare\" type=\"object\">The current square.</param>\r\n * <param name=\"targetSquare\" type=\"object\">The target square.</param>\r\n * <returns type=\"Array\">The updated board position.</returns>\r\n * </function>\r\n * \r\n * <function name=\"SidewaysCapture\">\r\n * <description>Modifies the row to capture pieces sideways.</description>\r\n * <param name=\"row\" type=\"Array\">The row to update.</param>\r\n * <param name=\"colIndex\" type=\"number\">The column index of the current square.</param>\r\n * <param name=\"targetColIndex\" type=\"number\">The column index of the target square.</param>\r\n * <param name=\"value\" type=\"string\">The piece value.</param>\r\n * <returns type=\"Array\">The updated row.</returns>\r\n * </function>\r\n * \r\n * <function name=\"ConvertPieceToFENPiece\">\r\n * <description>Converts the piece from {color-piece} format to FEN format (a single letter).</description>\r\n * <param name=\"value\" type=\"string\">The piece value.</param>\r\n * <returns type=\"string\">The FEN notation of the piece.</returns>\r\n * </function>\r\n * \r\n * <function name=\"generateSquareComponents\">\r\n * <description>Generates Square components for the given board state.</description>\r\n * <param name=\"boardSquares\" type=\"Array\">The 2D array representing the board squares.</param>\r\n * <param name=\"isPossibleMove\" type=\"Array\">The array of possible move states.</param>\r\n * <param name=\"getPossibleMoves\" type=\"Function\">The function to get possible moves.</param>\r\n * <param name=\"movePiece\" type=\"Function\">The function to move a piece.</param>\r\n * <param name=\"resetPossibleMoves\" type=\"Function\">The function to reset possible moves.</param>\r\n * <returns type=\"Array\">The array of Square components.</returns>\r\n * </function>\r\n * \r\n * <function name=\"convertCoordinatesToLocation\">\r\n * <description>Converts board coordinates to X and Y position on the board, e.g., a8 = 0, 0</description>\r\n * <param name=\"coordinates\" type=\"string\">The board coordinates to convert.</param>\r\n * <returns type=\"object\">Returns an object with x and y properties.</returns>\r\n * </function>\r\n * \r\n * <function name=\"convertLocationToCoordinates\">\r\n * <description>Converts a piece location to board coordinate, e.g., 0, 0 to a8</description>\r\n * <param name=\"x\" type=\"string\">The X position.</param>\r\n * <param name=\"y\" type=\"string\">The Y position.</param>\r\n * <returns type=\"string\">Returns a string containing the board coordinates.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isKingInCheck\">\r\n * <description>Determines if the king is in check.</description>\r\n * <param name=\"kingSquare\" type=\"object\">The square where the king is located.</param>\r\n * <param name=\"pseudo\" type=\"object\" optional=\"true\">The square where a piece is hypothetically moved.</param>\r\n * <param name=\"currentSquare\" type=\"object\" default=\"null\" optional=\"true\">The square of the piece being moved.</param>\r\n * <param name=\"color\" type=\"string\">The color of the king ('white' or 'black').</param>\r\n * <returns type=\"boolean\">True if the king is in check, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isWhiteInCheck\">\r\n * <description>Determines if the white king is in check.</description>\r\n * <param name=\"kingSquare\" type=\"object\">The square where the king is located.</param>\r\n * <param name=\"pseudo\" type=\"object\" optional=\"true\">The square where a piece is hypothetically moved.</param>\r\n * <param name=\"currentSquare\" type=\"object\" default=\"null\" optional=\"true\">The square of the piece being moved.</param>\r\n * <returns type=\"boolean\">True if the white king is in check, false otherwise.</returns>\r\n * </function>\r\n * \r\n * <function name=\"isBlackInCheck\">\r\n * <description>Determines if the black king is in check.</description>\r\n * <param name=\"kingSquare\" type=\"object\">The square where the king is located.</param>\r\n * <param name=\"pseudo\" type=\"object\" optional=\"true\">The square where a piece is hypothetically moved.</param>\r\n * <param name=\"currentSquare\" type=\"object\" default=\"null\" optional=\"true\">The square of the piece being moved.</param>\r\n * <returns type=\"boolean\">True if the black king is in check, false otherwise.</returns>\r\n * </function>\r\n */\r\n\r\n/**\r\n * Checks if a character is Uppercase using the ASCII table.\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is uppercase, false otherwise.\r\n */\r\nexport function IsUpperCase(value) {\r\n    return value.charCodeAt(0) >= 65 && value.charCodeAt(0) <= 90;\r\n}\r\n\r\n/**\r\n * Checks if a character is Lowercase using the ASCII table.\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is lowercase, false otherwise.\r\n */\r\nexport function IsLowerCase(value) {\r\n    return value.charCodeAt(0) >= 97 && value.charCodeAt(0) <= 122;\r\n}\r\n\r\n/**\r\n * Checks if a character is a Digit using the ASCII table.\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is a digit, false otherwise.\r\n */\r\nexport function IsDigit(value) {\r\n    return value.charCodeAt(0) >= 48 && value.charCodeAt(0) <= 57;\r\n}\r\n\r\n/**\r\n * Parses a FEN string and returns its components.\r\n * @param {string} fen - The FEN string to parse.\r\n * @returns {object} - An object containing the FEN components.\r\n */\r\nexport function ParseFEN(fen) {\r\n    const fenParts = fen.split(' ');\r\n    if (fenParts.length !== 6) {\r\n        throw new Error('Invalid FEN');\r\n    }\r\n    const [fenBoard, fenTurn, fenCastling, fenEnPassant, fenHalfMoves, fenFullMoves] = fenParts;\r\n    return {\r\n        fenBoard,\r\n        fenTurn,\r\n        fenCastling,\r\n        fenEnPassant,\r\n        fenHalfMoves: Number(fenHalfMoves),\r\n        fenFullMoves: Number(fenFullMoves)\r\n    };\r\n}\r\n\r\n/**\r\n * Converts FEN piece notation to an actual piece.\r\n * @param {string} letter - The FEN notation of the piece.\r\n * @returns {string} - The actual piece.\r\n */\r\nexport function ConvertFENtoPiece(letter) {\r\n    const FEN_PIECE_MAP = {\r\n        [GlobalVariables.FEN_PIECES_BLACK.PAWN]: GlobalVariables.PIECES.PAWN,\r\n        [GlobalVariables.FEN_PIECES_BLACK.KNIGHT]: GlobalVariables.PIECES.KNIGHT,\r\n        [GlobalVariables.FEN_PIECES_BLACK.KING]: GlobalVariables.PIECES.KING,\r\n        [GlobalVariables.FEN_PIECES_BLACK.QUEEN]: GlobalVariables.PIECES.QUEEN,\r\n        [GlobalVariables.FEN_PIECES_BLACK.ROOK]: GlobalVariables.PIECES.ROOK,\r\n        [GlobalVariables.FEN_PIECES_BLACK.BISHOP]: GlobalVariables.PIECES.BISHOP,\r\n    };\r\n\r\n    return FEN_PIECE_MAP[letter.toLowerCase()] || \"\";\r\n}\r\n\r\n/**\r\n * Converts the FEN piece notation to a piece that we can use in the square component.\r\n * @param {string} value - The FEN notation of the piece.\r\n * @returns {string} - The piece in {color-piece} format.\r\n */\r\nexport function ConvertFENPieceToPiece(value) {\r\n    if (IsUpperCase(value)) {\r\n        return `${GlobalVariables.COLORS.WHITE}-${ConvertFENtoPiece(value)}`;\r\n    }\r\n\r\n    if (IsLowerCase(value)) {\r\n        return `${GlobalVariables.COLORS.BLACK}-${ConvertFENtoPiece(value)}`;\r\n    }\r\n\r\n    return \"\";\r\n}\r\n\r\n/**\r\n * Converts a string in FEN format to a normal string.\r\n * @param {string} value - The FEN string.\r\n * @returns {string} - The normal string.\r\n */\r\nexport function ConvertFenToString(value) {\r\n    return value.split('').reduce((result, char) => {\r\n        if (IsDigit(char)) {\r\n            return result + GlobalVariables.EMPTY_SQUARE_PIECE.repeat(Number(char));\r\n        }\r\n        return result + char;\r\n    }, '');\r\n}\r\n\r\n/**\r\n * Checks if two squares are on the same row.\r\n * @param {object} square1 - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if the squares are on the same row, false otherwise.\r\n */\r\nexport function checkIfTwoSquaresAreOnTheSameRow(square1, square2) {\r\n    return square1.props.x === square2.props.x;\r\n}\r\n\r\n/**\r\n * Checks if the square is on the given row number.\r\n * @param {object} square - The square to check.\r\n * @param {number} rowNumber - The row number.\r\n * @returns {boolean} - True if the square is on the given row, false otherwise.\r\n */\r\nexport function isSquareOnRow(square, rowNumber) {\r\n    return square.props.x === rowNumber;\r\n}\r\n\r\n/**\r\n * Gets the piece from a square.\r\n * @param {object} square - The square to get the piece from.\r\n * @returns {string} - The piece.\r\n */\r\nexport function getPiece(square) {\r\n    return square.props.piece.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_PIECE_INDEX];\r\n}\r\n\r\n/**\r\n * Checks if a square has a specific piece.\r\n * @param {object} square - The square to check.\r\n * @param {string} piece - The piece to check for.\r\n * @returns {boolean} - True if the square has the piece, false otherwise.\r\n */\r\nexport function doesTheSquareHasThePiece(square, piece) {\r\n    return getPiece(square) === piece;\r\n}\r\n\r\n/**\r\n * Gets the piece color from a square.\r\n * @param {object} square - The square to get the piece color from.\r\n * @returns {string} - The piece color.\r\n */\r\nexport function getPieceColor(square) {\r\n    return square.props.piece.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_COLOR_INDEX];\r\n}\r\n\r\n/**\r\n * Checks if a color is white.\r\n * @param {string} color - The color to check.\r\n * @returns {boolean} - True if the color is white, false otherwise.\r\n */\r\nexport function isColorWhite(color) {\r\n    return color === GlobalVariables.COLORS.WHITE;\r\n}\r\n\r\n/**\r\n * Checks if a color is black.\r\n * @param {string} color - The color to check.\r\n * @returns {boolean} - True if the color is black, false otherwise.\r\n */\r\nexport function isColorBlack(color) {\r\n    return color === GlobalVariables.COLORS.BLACK;\r\n}\r\n\r\n/**\r\n * Checks if two pieces are of the same color.\r\n * @param {string} piece1 - The first piece.\r\n * @param {string} piece2 - The second piece.\r\n * @returns {boolean} - True if the pieces are of the same color, false otherwise.\r\n */\r\nexport function areSameColor(piece1, piece2) {\r\n    const color1 = piece1.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_COLOR_INDEX];\r\n    const color2 = piece2.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_COLOR_INDEX];\r\n    return color1 === color2;\r\n}\r\n\r\n/**\r\n * Checks if a move is equal to the current selected square.\r\n * @param {object} move - The move to check.\r\n * @returns {boolean} - True if the move is equal to the current selected square, false otherwise.\r\n */\r\nexport function checkIfAMoveIsEqualToTheCurrentSelectedSquare(move) {\r\n    return move.props.x === GlobalVariables.CurrentSquareSelection.x && move.props.y === GlobalVariables.CurrentSquareSelection.y;\r\n}\r\n\r\n/**\r\n * Compares if two squares are the same.\r\n * @param {object} square1 - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if the squares are the same, false otherwise.\r\n */\r\nexport function compareIfTwoSquaresAreTheSame(square1, square2) {\r\n    return square1.props.x === square2.props.x && square1.props.y === square2.props.y;\r\n}\r\n\r\n/**\r\n * Gets a target square by its location.\r\n * @param {number} x - The x coordinate of the target square.\r\n * @param {number} y - The y coordinate of the target square.\r\n * @returns {object} - The target square.\r\n */\r\nexport function getATargetSquareByLocation(x, y, squares) {\r\n    return GlobalVariables.BoardPosition[x][y];\r\n}\r\n\r\n/**\r\n * Gets a target square by its piece.\r\n * @param {string} piece - The piece to search for.\r\n * @returns {object} - The target square.\r\n */\r\nexport function getATargetSquareByPiece(piece) {\r\n    for (let row of GlobalVariables.BoardPosition) {\r\n        for (let square of row) {\r\n            if (square.props.piece === piece) {\r\n                return square;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks if castling is possible.\r\n * @param {string} castlingType - The type of castling (long or short).\r\n * @param {boolean} [withWhite=true] - True if checking for white's castling, false otherwise.\r\n * @returns {boolean} - True if castling is possible, false otherwise.\r\n */\r\nexport function isCastlingPossible(castlingType, withWhite = true) {\r\n    const row = withWhite ? GlobalVariables.CASTLE_ROW_WHITE : GlobalVariables.CASTLE_ROW_BLACK;\r\n    const pieces = withWhite ? GlobalVariables.FEN_PIECES_WHITE : GlobalVariables.FEN_PIECES_BLACK;\r\n    const [rookCol, kingCol, pathCols] = castlingType === GlobalVariables.CASTLING_TYPES.LONG ?\r\n        [GlobalVariables.CASTLE_ROOK_INITIAL_COL_LONG, GlobalVariables.CASTLE_KING_INITIAL_COL, GlobalVariables.CASTLE_PATH_COLS_LONG] :\r\n        [GlobalVariables.CASTLE_ROOK_INITIAL_COL_SHORT, GlobalVariables.CASTLE_KING_INITIAL_COL, GlobalVariables.CASTLE_PATH_COLS_SHORT];\r\n\r\n    return GlobalVariables.BoardPosition[row][rookCol] === pieces.ROOK &&\r\n        GlobalVariables.BoardPosition[row][kingCol] === pieces.KING &&\r\n        pathCols.every(col => GlobalVariables.BoardPosition[row][col] === GlobalVariables.EMPTY_SQUARE_PIECE);\r\n}\r\n\r\n/**\r\n * Checks if a pawn is on its starting square.\r\n * @param {object} pawn - The pawn to check.\r\n * @returns {boolean} - True if the pawn is on its starting square, false otherwise.\r\n */\r\nexport function isPawnOnStartingSquare(pawn) {\r\n    const isWhite = isColorWhite(getPieceColor(pawn));\r\n    return isWhite ? pawn.props.x === GlobalVariables.WHITE_PAWN_STARTING_SQUARE : pawn.props.x === GlobalVariables.BLACK_PAWN_STARTING_SQUARE;\r\n}\r\n\r\n/**\r\n * Checks if a pawn is on an en passant square.\r\n * @param {object} pawn - The pawn to check.\r\n * @returns {boolean} - True if the pawn is on an en passant square, false otherwise.\r\n */\r\nexport function isPawnOnEnPassantSquare(pawn) {\r\n    const isWhite = isColorWhite(getPieceColor(pawn));\r\n    return isWhite ? pawn.props.x === GlobalVariables.WHITE_EN_PASSANT_SQUARE : pawn.props.x === GlobalVariables.BLACK_EN_PASSANT_SQUARE;\r\n}\r\n\r\n/**\r\n * Checks if a square is available for a move.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the square is available, false otherwise.\r\n */\r\nexport function isSquareAvailable(square) {\r\n    return !square.props.piece;\r\n}\r\n\r\n/**\r\n * Updates a column on a row with a new value.\r\n * @param {Array} row - The row to update.\r\n * @param {number} colIndex - The column index.\r\n * @param {string} newValue - The new value.\r\n * @returns {Array} - The updated row.\r\n */\r\nexport function updateColumnOnARow(row, colIndex, newValue) {\r\n    row[colIndex] = newValue;\r\n    return row;\r\n}\r\n\r\n/**\r\n * Removes the current square's piece.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\r\nexport function handleSquareOnCurrentRow(currentSquare, targetSquare, row) {\r\n    return checkIfTwoSquaresAreOnTheSameRow(currentSquare, targetSquare) ?\r\n        handleSquareAndTargetSquareOnTheSameRow(currentSquare, targetSquare, row) :\r\n        updateColumnOnARow(row, currentSquare.props.y, GlobalVariables.EMPTY_SQUARE_PIECE);\r\n}\r\n\r\n/**\r\n * Updates the target square with the current square's piece.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\r\nexport function handleTargetSquareOnCurrentRow(currentSquare, targetSquare, row) {\r\n    return updateColumnOnARow(row, targetSquare.props.y, ConvertPieceToFENPiece(currentSquare.props.piece));\r\n}\r\n\r\n/**\r\n * Checks if we're making a move on the same row and performs castling if we want to castle.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\r\nexport function handleSquareAndTargetSquareOnTheSameRow(currentSquare, targetSquare, row) {\r\n    if (doesTheSquareHasThePiece(currentSquare, GlobalVariables.PIECES.KING) && isCastlingPossible(currentSquare, targetSquare)) {\r\n        return handleCastling(currentSquare, row);\r\n    }\r\n    return SidewaysCapture(row, Number(currentSquare.props.y), Number(targetSquare.props.y), currentSquare.props.piece);\r\n}\r\n\r\n/**\r\n * Performs castling by swapping the rook and the king.\r\n * @param {object} square - The square to update.\r\n * @param {Array} row - The row to update.\r\n * @returns {Array} - The updated row.\r\n */\r\nexport function handleCastling(square, row) {\r\n    const color = getPieceColor(square);\r\n    const isWhite = isColorWhite(color);\r\n    const kingPiece = isWhite ? GlobalVariables.FEN_PIECES_WHITE.KING : GlobalVariables.FEN_PIECES_BLACK.KING;\r\n    const rookPiece = isWhite ? GlobalVariables.FEN_PIECES_WHITE.ROOK : GlobalVariables.FEN_PIECES_BLACK.ROOK;\r\n\r\n    Object.values(GlobalVariables.CASTLING_TYPES).forEach(type => {\r\n        if (isCastlingPossible(type, isWhite)) {\r\n            const [emptySquares, kingFinalCol, rookFinalCol] = type === GlobalVariables.CASTLING_TYPES.LONG ?\r\n                [GlobalVariables.EMPTY_SQUARES_AFTER_LONG_CASTLE, GlobalVariables.CASTLE_KING_FINAL_COL_LONG, GlobalVariables.CASTLE_ROOK_FINAL_COL_LONG] :\r\n                [GlobalVariables.EMPTY_SQUARES_AFTER_SHORT_CASTLE, GlobalVariables.CASTLE_KING_FINAL_COL_SHORT, GlobalVariables.CASTLE_ROOK_FINAL_COL_SHORT];\r\n            emptySquares.forEach(col => row[col] = GlobalVariables.EMPTY_SQUARE_PIECE);\r\n            row[kingFinalCol] = kingPiece;\r\n            row[rookFinalCol] = rookPiece;\r\n        }\r\n    });\r\n\r\n    return row;\r\n}\r\n\r\n/**\r\n * Converts a row of squares to its FEN representation.\r\n * @param {Array} row - The row to convert.\r\n * @returns {string} - The FEN representation of the row.\r\n */\r\nexport function convertRowToFEN(row) {\r\n    return row.reduce((acc, column) => {\r\n        if (column === EMPTY_SQUARE_PIECE) {\r\n            const lastChar = acc.slice(-1);\r\n            if (IsDigit(lastChar)) {\r\n                return acc.slice(0, -1) + (Number(lastChar) + 1);\r\n            } else {\r\n                return acc + '1';\r\n            }\r\n        } else {\r\n            return acc + column;\r\n        }\r\n    }, '');\r\n}\r\n\r\n/**\r\n * Gets the castling rules as a string.\r\n * @returns {string} - The castling rules.\r\n */\r\nexport function getCastlingRules() {\r\n    return Object.values(GlobalVariables.CastlingRights)\r\n        .map(right => (right ? right : \"\"))\r\n        .join(\"\") || \"-\";\r\n}\r\n\r\n/**\r\n * Generates a new FEN string based on the current board state.\r\n * @returns {string} - The new FEN string.\r\n */\r\nexport function generateANewFen() {\r\n    const fenRows = GlobalVariables.BoardPosition.map(row => convertRowToFEN(row)).join('/');\r\n    const turn = GlobalVariables.IsWhiteToMove ? 'w' : 'b';\r\n    const castling = getCastlingRules();\r\n    const enPassant = GlobalVariables.EnPassant.isPossible\r\n        ? convertLocationToCoordinates(GlobalVariables.EnPassant.x, GlobalVariables.EnPassant.y)\r\n        : '-';\r\n    const halfMoves = GlobalVariables.HalfMoves;\r\n    const fullMoves = GlobalVariables.FullMoves;\r\n\r\n    return `${fenRows} ${turn} ${castling} ${enPassant} ${halfMoves} ${fullMoves}`;\r\n}\r\n\r\n/**\r\n * Updates castling rights based on the given castling string.\r\n * @param {string} castling - The castling rights string (e.g., 'KQkq').\r\n */\r\nexport function updateCastlingRights(castling) {\r\n    const castlingMap = {\r\n        'K': 'whiteShortCastle',\r\n        'Q': 'whiteLongCastle',\r\n        'k': 'blackShortCastle',\r\n        'q': 'blackLongCastle'\r\n    };\r\n\r\n    Object.keys(castlingMap).forEach(key => {\r\n        GlobalVariables.CastlingRights[castlingMap[key]] = castling.includes(key);\r\n    });\r\n}\r\n\r\n/**\r\n * Updates en passant status based on the given en passant string.\r\n * @param {string} enPassant - The en passant target square (e.g., 'e3') or '-' if not available.\r\n */\r\nexport function updateEnPassant(enPassant) {\r\n    if (enPassant !== GlobalVariables.PIECE_DELIMITER) {\r\n        const { x, y } = convertCoordinatesToLocation(enPassant);\r\n        Object.assign(GlobalVariables.EnPassant, {\r\n            isPossible: true,\r\n            x: x,\r\n            y: y\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Parses the FEN string to update the board state.\r\n * @param {string} fen - The FEN string representing the board state.\r\n * @param {Array} isPossibleMove - Array indicating possible moves.\r\n * @param {function} getPossibleMoves - Function to get possible moves.\r\n * @param {function} movePiece - Function to move a piece.\r\n * @param {function} resetPossibleMoves - Function to reset possible moves.\r\n * @param {boolean} [updateBoardPosition=true] - Whether to update the board position.\r\n * @returns {Array} - The generated square components.\r\n */\r\nexport function fenParser(fen, isPossibleMove, getPossibleMoves, movePiece, resetPossibleMoves, updateBoardPosition = true) {\r\n    const {\r\n        fenBoard,\r\n        fenTurn,\r\n        fenCastling,\r\n        fenEnPassant,\r\n        fenHalfMoves,\r\n        fenFullMoves\r\n    } = ParseFEN(fen);\r\n\r\n    const fenRows = fenBoard.split('/');\r\n    const boardArray = fenRows.map(row => ConvertFenToString(row).split(''));\r\n\r\n    const squares = generateSquareComponents(boardArray, isPossibleMove, getPossibleMoves, movePiece, resetPossibleMoves);\r\n\r\n    updateCastlingRights(fenCastling);\r\n\r\n    GlobalVariables.updateIsWhiteToMove(fenTurn === 'w');\r\n    GlobalVariables.updateHalfMoves(fenHalfMoves);\r\n    GlobalVariables.updateFullMoves(fenFullMoves);\r\n\r\n    if (updateBoardPosition) {\r\n        GlobalVariables.BoardPosition.splice(0, GlobalVariables.BoardPosition.length, ...boardArray);\r\n    }\r\n\r\n    updateEnPassant(fenEnPassant);\r\n\r\n    return squares;\r\n}\r\n\r\n/**\r\n * Updates the board position after making a move.\r\n * @param {object} currentSquare - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @returns {Array} - The updated board position.\r\n */\r\nexport function updateBoardPosition(currentSquare, targetSquare) {\r\n    return GlobalVariables.BoardPosition.map((row, rowIndex) => {\r\n        if (isSquareOnRow(currentSquare, rowIndex)) {\r\n            row = handleSquareOnCurrentRow(currentSquare, targetSquare, row);\r\n        }\r\n        if (isSquareOnRow(targetSquare, rowIndex)) {\r\n            row = handleTargetSquareOnCurrentRow(currentSquare, targetSquare, row);\r\n        }\r\n        return row;\r\n    });\r\n}\r\n\r\n/**\r\n * Modifies the row to capture pieces sideways.\r\n * @param {Array} row - The row to update.\r\n * @param {number} colIndex - The column index of the current square.\r\n * @param {number} targetColIndex - The column index of the target square.\r\n * @param {string} value - The piece value.\r\n * @returns {Array} - The updated row.\r\n */\r\nexport function SidewaysCapture(row, colIndex, targetColIndex, value) {\r\n    return row.map((col, index) => {\r\n        if (index === colIndex) return GlobalVariables.EMPTY_SQUARE_PIECE;\r\n        if (index === targetColIndex) return ConvertPieceToFENPiece(value);\r\n        return col;\r\n    });\r\n}\r\n\r\n/**\r\n * Converts the piece from {color-piece} format to FEN format (a single letter).\r\n * @param {string} value - The piece value.\r\n * @returns {string} - The FEN notation of the piece.\r\n */\r\nexport function ConvertPieceToFENPiece(value) {\r\n    const [color, piece] = value.split(GlobalVariables.PIECE_DELIMITER);\r\n    const pieceMapping = {\r\n        [GlobalVariables.PIECES.PAWN]: GlobalVariables.FEN_PIECES_BLACK.PAWN,\r\n        [GlobalVariables.PIECES.KNIGHT]: GlobalVariables.FEN_PIECES_BLACK.KNIGHT,\r\n        [GlobalVariables.PIECES.BISHOP]: GlobalVariables.FEN_PIECES_BLACK.BISHOP,\r\n        [GlobalVariables.PIECES.ROOK]: GlobalVariables.FEN_PIECES_BLACK.ROOK,\r\n        [GlobalVariables.PIECES.QUEEN]: GlobalVariables.FEN_PIECES_BLACK.QUEEN,\r\n        [GlobalVariables.PIECES.KING]: GlobalVariables.FEN_PIECES_BLACK.KING,\r\n    };\r\n\r\n    const fenPiece = pieceMapping[piece];\r\n    return isColorWhite(color) ? fenPiece.toUpperCase() : fenPiece;\r\n}\r\n\r\n/**\r\n * Generates Square components for the given board state.\r\n * @param {Array} boardSquares - The 2D array representing the board squares.\r\n * @param {Array} isPossibleMove - The array of possible move states.\r\n * @param {Function} getPossibleMoves - The function to get possible moves.\r\n * @param {Function} movePiece - The function to move a piece.\r\n * @param {Function} resetPossibleMoves - The function to reset possible moves.\r\n * @returns {Array} - The array of Square components.\r\n */\r\nexport function generateSquareComponents(boardSquares, isPossibleMove, getPossibleMoves, movePiece, resetPossibleMoves) {\r\n    let squareColorIsWhite = true;\r\n\r\n    const squares = boardSquares.flatMap((row, rowIndex) => {\r\n        const rowSquares = row.map((square, colIndex) => {\r\n            const color = squareColorIsWhite ? \"\" : \"dark\";\r\n            const possibleMoveStatus = isPossibleMove.find(item => item.key === `${rowIndex}-${colIndex}`);\r\n            const squareComponent = (\r\n                <Square\r\n                    key={`${rowIndex}-${colIndex}`}\r\n                    x={rowIndex}\r\n                    y={colIndex}\r\n                    piece={ConvertFENPieceToPiece(square)}\r\n                    color={color}\r\n                    getPossibleMoves={getPossibleMoves}\r\n                    movePiece={movePiece}\r\n                    isPossibleMove={possibleMoveStatus ? possibleMoveStatus.value : false}\r\n                    resetPossibleMoves={resetPossibleMoves}\r\n                />\r\n            );\r\n            squareColorIsWhite = !squareColorIsWhite;\r\n            return squareComponent;\r\n        });\r\n        squareColorIsWhite = !squareColorIsWhite; // Reset color for the next row\r\n        return rowSquares;\r\n    });\r\n\r\n    return squares;\r\n}\r\n\r\n/**\r\n * Converts board coordinates to X and Y position on the board, e.g., a8 = 0, 0\r\n * @param {string} coordinates - The board coordinates to convert.\r\n * @returns {object} - Returns an object with x and y properties.\r\n */\r\nexport function convertCoordinatesToLocation(coordinates) {\r\n    let tokens = coordinates.split('')\r\n\r\n    //skip invalid coordinates\r\n    if (tokens.length != 2) {\r\n        return\r\n    }\r\n\r\n    let letter = tokens[0].toString().toUpperCase()\r\n    let number = tokens[1]\r\n\r\n    //65 is the ASCII code for capital A which will give us 0 if we have A as a coordinate; A-F will give us 0-7 for y (columns)\r\n    //reverse the numbers since we draw the board top down for x (rows)\r\n    return { x: GlobalVariables.DIM - Number(number), y: letter.charCodeAt(0) - 65 }\r\n}\r\n\r\n/**\r\n * Converts a piece location to board coordinate, e.g., 0, 0 to a8\r\n * @param {string} x - The X position.\r\n * @param {string} y - The Y position.\r\n * @returns {string} - Returns a string containing the board coordinates.\r\n */\r\nexport function convertLocationToCoordinates(x, y) {\r\n    //maps y (column) to the letter coordinate; add 65 (capital A code) to the ASCII code for the location we have and we get a letter between A and F\r\n    //reverses the x (rows) coordinate because we drop the board top down, while coordinates go down up\r\n    return `${String.fromCharCode(y + 65)}${GlobalVariables.DIM - x}`.toLowerCase()\r\n}\r\n\r\n/**\r\n * Determines if the king is in check.\r\n * @param {object} kingSquare - The square where the king is located.\r\n * @param {object} [pseudo] - The square where a piece is hypothetically moved.\r\n * @param {object} [currentSquare=null] - The square of the piece being moved.\r\n * @param {string} color - The color of the king ('white' or 'black').\r\n * @returns {boolean} - True if the king is in check, false otherwise.\r\n */\r\nexport function isKingInCheck(kingSquare, pseudo, currentSquare = null, color) {\r\n    const squares = boardSquaresRef.current;\r\n\r\n    const updatedSquares = squares.map(s => {\r\n        if (pseudo && s.props.x === pseudo.props.x && s.props.y === pseudo.props.y) {\r\n            return React.cloneElement(s, { piece: pseudo.props.piece });\r\n        } else if (currentSquare && s.props.x === currentSquare.props.x && s.props.y === currentSquare.props.y) {\r\n            return React.cloneElement(s, { piece: '' });\r\n        } else {\r\n            return s;\r\n        }\r\n    });\r\n\r\n    const checkDirections = (directions) => {\r\n        for (const [dx, dy] of directions) {\r\n            for (let i = 1; i < GlobalVariables.DIM; i++) {\r\n                const piece = updatedSquares.find(s => s.props.x === kingSquare.props.x + dx * i && s.props.y === kingSquare.props.y + dy * i);\r\n                if (!piece) break;\r\n                const [pieceColor, pieceType] = piece.props.piece.split(\"-\");\r\n                if (pieceColor !== color) {\r\n                    if (pieceType === \"queen\" || pieceType === \"rook\" || pieceType === \"bishop\" || (i === 1 && pieceType === \"pawn\" && (dx === -1 || dx === 1))) {\r\n                        return true;\r\n                    }\r\n                    if (piece.props.piece) break;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n    const linearDirections = [\r\n        [1, 0], [-1, 0], [0, 1], [0, -1]  // Right, Left, Up, Down\r\n    ];\r\n\r\n    const diagonalDirections = [\r\n        [1, 1], [-1, -1], [1, -1], [-1, 1]  // Diagonals\r\n    ];\r\n\r\n    if (checkDirections(linearDirections) || checkDirections(diagonalDirections)) {\r\n        return true;\r\n    }\r\n\r\n    const knightMoves = [\r\n        [-2, -1], [-2, 1], [2, -1], [2, 1],\r\n        [-1, 2], [1, 2], [-1, -2], [1, -2]\r\n    ];\r\n\r\n    for (const [dx, dy] of knightMoves) {\r\n        const piece = updatedSquares.find(s => s.props.x === kingSquare.props.x + dx && s.props.y === kingSquare.props.y + dy);\r\n        if (piece && piece.props.piece.split(\"-\")[0] !== color && piece.props.piece.split(\"-\")[1] === \"knight\") {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Determines if the white king is in check.\r\n * @param {object} kingSquare - The square where the king is located.\r\n * @param {object} [pseudo] - The square where a piece is hypothetically moved.\r\n * @param {object} [currentSquare=null] - The square of the piece being moved.\r\n * @returns {boolean} - True if the white king is in check, false otherwise.\r\n */\r\nexport function isWhiteInCheck(kingSquare, pseudo, currentSquare = null) {\r\n    return isKingInCheck(kingSquare, pseudo, currentSquare, 'white');\r\n}\r\n\r\n/**\r\n * Determines if the black king is in check.\r\n * @param {object} kingSquare - The square where the king is located.\r\n * @param {object} [pseudo] - The square where a piece is hypothetically moved.\r\n * @param {object} [currentSquare=null] - The square of the piece being moved.\r\n * @returns {boolean} - True if the black king is in check, false otherwise.\r\n */\r\nexport function isBlackInCheck(kingSquare, pseudo, currentSquare = null) {\r\n    return isKingInCheck(kingSquare, pseudo, currentSquare, 'black');\r\n}"],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,MAAM,MAAM,aAAa;AAChC,OAAO,KAAKC,eAAe,MAAM,mBAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAJA,SAAAC,MAAA,IAAAC,OAAA;AAKA,OAAO,SAASC,WAAWA,CAACC,KAAK,EAAE;EAC/B,OAAOA,KAAK,CAACC,UAAU,CAAC,CAAC,CAAC,IAAI,EAAE,IAAID,KAAK,CAACC,UAAU,CAAC,CAAC,CAAC,IAAI,EAAE;AACjE;;AAEA;AACA;AACA;AACA;AACA;AAJAC,EAAA,GAJgBH,WAAW;AAS3B,OAAO,SAASI,WAAWA,CAACH,KAAK,EAAE;EAC/B,OAAOA,KAAK,CAACC,UAAU,CAAC,CAAC,CAAC,IAAI,EAAE,IAAID,KAAK,CAACC,UAAU,CAAC,CAAC,CAAC,IAAI,GAAG;AAClE;;AAEA;AACA;AACA;AACA;AACA;AAJAG,GAAA,GAJgBD,WAAW;AAS3B,OAAO,SAASE,OAAOA,CAACL,KAAK,EAAE;EAC3B,OAAOA,KAAK,CAACC,UAAU,CAAC,CAAC,CAAC,IAAI,EAAE,IAAID,KAAK,CAACC,UAAU,CAAC,CAAC,CAAC,IAAI,EAAE;AACjE;;AAEA;AACA;AACA;AACA;AACA;AAJAK,GAAA,GAJgBD,OAAO;AASvB,OAAO,SAASE,QAAQA,CAACC,GAAG,EAAE;EAC1B,MAAMC,QAAQ,GAAGD,GAAG,CAACE,KAAK,CAAC,GAAG,CAAC;EAC/B,IAAID,QAAQ,CAACE,MAAM,KAAK,CAAC,EAAE;IACvB,MAAM,IAAIC,KAAK,CAAC,aAAa,CAAC;EAClC;EACA,MAAM,CA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}