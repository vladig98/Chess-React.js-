{"ast":null,"code":"import { PIECES, FEN_PIECES_BLACK, COLORS, CASTLE_ROW_WHITE, CASTLE_ROW_BLACK, CASTLE_KING_INITIAL_COL, CASTLE_ROOK_INITIAL_COL_LONG, CASTLE_ROOK_INITIAL_COL_SHORT, CASTLE_PATH_COLS_LONG, CASTLE_PATH_COLS_SHORT, PIECE_COLOR_INDEX, PIECE_PIECE_INDEX, FEN_PIECES_WHITE, EMPTY_SQUARE_PIECE, CASTLE_ROOK_FINAL_COL_LONG, CASTLE_ROOK_FINAL_COL_SHORT, CASTLE_KING_FINAL_COL_LONG, CASTLE_KING_FINAL_COL_SHORT, EMPTY_SQUARES_AFTER_LONG_CASTLE, EMPTY_SQUARES_AFTER_SHORT_CASTLE, BoardPosition, PIECE_DELIMITER, CASTLING_TYPES } from './globalVariables';\n\n//Checks if a character is Uppercase using the ASCII table; 65 (A); 90 (Z)\nexport function IsUpperCase(value) {\n  return value.charCodeAt(0) >= 65 && value.charCodeAt(0) <= 90;\n}\n\n//Checks if a character is Lowercase using the ASCII table; 97 (a); 122 (z)\n_c = IsUpperCase;\nexport function IsLowerCase(value) {\n  return value.charCodeAt(0) >= 97 && value.charCodeAt(0) <= 122;\n}\n\n//Checks if a character is a Digit using the ASCII table; 48 (0); 57 (9)\n_c2 = IsLowerCase;\nexport function IsDigit(value) {\n  return value.charCodeAt(0) >= 48 && value.charCodeAt(0) <= 57;\n}\n\n//splits the FEN string to each individual part that makes it\n_c3 = IsDigit;\nexport function ParseFEN(fen) {\n  const fenParts = fen.split(EMPTY_SQUARE_PIECE);\n  if (fenParts.length !== 6) {\n    throw new Error('Invalid FEN');\n  }\n  const [fenBoard, fenTurn, fenCastling, fenEnPassant, fenHalfMoves, fenFullMoves] = fenParts;\n  return {\n    fenBoard,\n    fenTurn,\n    fenCastling,\n    fenEnPassant,\n    fenHalfMoves: Number(fenHalfMoves),\n    fenFullMoves: Number(fenFullMoves)\n  };\n}\n\n//converts FEN piece notation to an actual piece\n_c4 = ParseFEN;\nexport function ConvertFENtoPiece(letter) {\n  const FEN_PIECE_MAP = {\n    [FEN_PIECES_BLACK.PAWN]: PIECES.PAWN,\n    [FEN_PIECES_BLACK.KNIGHT]: PIECES.KNIGHT,\n    [FEN_PIECES_BLACK.KING]: PIECES.KING,\n    [FEN_PIECES_BLACK.QUEEN]: PIECES.QUEEN,\n    [FEN_PIECES_BLACK.ROOK]: PIECES.ROOK,\n    [FEN_PIECES_BLACK.BISHOP]: PIECES.BISHOP\n  };\n  return FEN_PIECE_MAP[letter.toLowerCase()] || \"\";\n}\n\n//converts the FEN piece notation to a piece that we can use in the square component\n_c5 = ConvertFENtoPiece;\nexport function ConvertFENPieceToPiece(value) {\n  if (IsUpperCase(value)) {\n    return `${COLORS.WHITE}-${ConvertFENtoPiece(value)}`;\n  }\n  if (IsLowerCase(value)) {\n    return `${COLORS.BLACK}-${ConvertFENtoPiece(value)}`;\n  }\n  return \"\";\n}\n_c6 = ConvertFENPieceToPiece;\nexport function ConvertFenToString(value) {\n  return value.split('').reduce((result, char) => {\n    if (IsDigit(char)) {\n      return result + EMPTY_SQUARE_PIECE.repeat(Number(char));\n    }\n    return result + char;\n  }, '');\n}\n_c7 = ConvertFenToString;\nfunction checkIfTwoSquaresAreOnTheSameRow(square1, square2) {\n  return square1.props.x == square2.props.x;\n}\nfunction isSquareOnRow(square, rowNumber) {\n  return square.props.x == rowNumber;\n}\n\n//gets the piece\nexport function getPiece(square) {\n  return square.props.piece.split(PIECE_DELIMITER)[PIECE_PIECE_INDEX];\n}\n\n//checks if piece is positioned on a certain square\nexport function doesTheSquareHasThePiece(square, piece) {\n  let p = getPiece(square);\n  return p == piece;\n}\n\n//gets the piece color\nexport function getPieceColor(square) {\n  return square.props.piece.split(PIECE_DELIMITER)[PIECE_COLOR_INDEX];\n}\n\n//checks if a color is white\nexport function isColorWhite(color) {\n  return color == COLORS.WHITE;\n}\nfunction areWeCastling(castlingType, withWhite = true) {\n  const row = withWhite ? CASTLE_ROW_WHITE : CASTLE_ROW_BLACK;\n  const pieces = withWhite ? FEN_PIECES_WHITE : FEN_PIECES_BLACK;\n  const [rookCol, kingCol, pathCols] = castlingType === CASTLING_TYPES.LONG ? [CASTLE_ROOK_INITIAL_COL_LONG, CASTLE_KING_INITIAL_COL, CASTLE_PATH_COLS_LONG] : [CASTLE_ROOK_INITIAL_COL_SHORT, CASTLE_KING_INITIAL_COL, CASTLE_PATH_COLS_SHORT];\n  return BoardPosition[row][rookCol] === pieces.ROOK && BoardPosition[row][kingCol] === pieces.KING && pathCols.every(col => BoardPosition[row][col] === EMPTY_SQUARE_PIECE);\n}\nfunction updateColumnOnARow(row, colIndex, newValue) {\n  row[colIndex] = newValue;\n  return row;\n}\n\n//removes the current square's piece\nfunction handleSquareOnCurrentRow(square, targetSquare, row) {\n  return checkIfTwoSquaresAreOnTheSameRow(square, targetSquare) ? handleSquareAndTargetSquareOnTheSameRow(square, targetSquare, row) : updateColumnOnARow(row, square.props.y, EMPTY_SQUARE_PIECE);\n}\n\n//updates the targetSquare with the current's square's piece\nfunction handleTargetSquareOnCurrentRow(square, targetSquare, row) {\n  return updateColumnOnARow(row, targetSquare.props.y, ConvertPieceToFENPiece(square.props.piece));\n}\n\n//checks if we're making a move on the same row and performs castling if we want to castle\nfunction handleSquareAndTargetSquareOnTheSameRow(square, targetSquare, row) {\n  if (doesTheSquareHasThePiece(square, PIECES.KING) && areWeCastling(square, targetSquare)) {\n    return handleCastling(square, row);\n  }\n  return SidewaysCapture(row, Number(square.props.y), Number(targetSquare.props.y), square.props.piece);\n}\n\n//performs castling, swaps the rook and the king\nfunction handleCastling(square, row) {\n  const color = getPieceColor(square);\n  const isWhite = isColorWhite(color);\n  const kingPiece = isWhite ? FEN_PIECES_WHITE.KING : FEN_PIECES_BLACK.KING;\n  const rookPiece = isWhite ? FEN_PIECES_WHITE.ROOK : FEN_PIECES_BLACK.ROOK;\n  Object.values(CASTLING_TYPES).forEach(type => {\n    if (areWeCastling(type, isWhite)) {\n      const [emptySquares, kingFinalCol, rookFinalCol] = type === CASTLING_TYPES.LONG ? [EMPTY_SQUARES_AFTER_LONG_CASTLE, CASTLE_KING_FINAL_COL_LONG, CASTLE_ROOK_FINAL_COL_LONG] : [EMPTY_SQUARES_AFTER_SHORT_CASTLE, CASTLE_KING_FINAL_COL_SHORT, CASTLE_ROOK_FINAL_COL_SHORT];\n      emptySquares.forEach(col => row[col] = EMPTY_SQUARE_PIECE);\n      row[kingFinalCol] = kingPiece;\n      row[rookFinalCol] = rookPiece;\n    }\n  });\n  return row;\n}\n\n//updates the current position to a new position after making the move\n//provide the current square, the targetSquare (where you want to move to) and the current position\nexport function UpdatePosition(square, targetSquare, position) {\n  return position.map((row, rowIndex) => {\n    if (isSquareOnRow(square, rowIndex)) {\n      row = handleSquareOnCurrentRow(square, targetSquare, row);\n    }\n    if (isSquareOnRow(targetSquare, rowIndex)) {\n      row = handleTargetSquareOnCurrentRow(square, targetSquare, row);\n    }\n    return row;\n  });\n}\n\n//modifies the row to capture pieces sideways (square and targetSquare are on the same row)\n_c8 = UpdatePosition;\nfunction SidewaysCapture(row, colIndex, targetColIndex, value) {\n  return row.map((col, index) => {\n    if (index === colIndex) return EMPTY_SQUARE_PIECE;\n    if (index === targetColIndex) return ConvertPieceToFENPiece(value);\n    return col;\n  });\n}\n\n//converts the piece from format {color-piece} to FEN format (a single letter)\n_c9 = SidewaysCapture;\nfunction ConvertPieceToFENPiece(value) {\n  const [color, piece] = value.split(PIECE_DELIMITER);\n  const pieceMapping = {\n    [PIECES.PAWN]: FEN_PIECES_BLACK.PAWN,\n    [PIECES.KNIGHT]: FEN_PIECES_BLACK.KNIGHT,\n    [PIECES.BISHOP]: FEN_PIECES_BLACK.BISHOP,\n    [PIECES.ROOK]: FEN_PIECES_BLACK.ROOK,\n    [PIECES.QUEEN]: FEN_PIECES_BLACK.QUEEN,\n    [PIECES.KING]: FEN_PIECES_BLACK.KING\n  };\n  const fenPiece = pieceMapping[piece];\n  return isColorWhite(color) ? fenPiece.toUpperCase() : fenPiece;\n}\n_c10 = ConvertPieceToFENPiece;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10;\n$RefreshReg$(_c, \"IsUpperCase\");\n$RefreshReg$(_c2, \"IsLowerCase\");\n$RefreshReg$(_c3, \"IsDigit\");\n$RefreshReg$(_c4, \"ParseFEN\");\n$RefreshReg$(_c5, \"ConvertFENtoPiece\");\n$RefreshReg$(_c6, \"ConvertFENPieceToPiece\");\n$RefreshReg$(_c7, \"ConvertFenToString\");\n$RefreshReg$(_c8, \"UpdatePosition\");\n$RefreshReg$(_c9, \"SidewaysCapture\");\n$RefreshReg$(_c10, \"ConvertPieceToFENPiece\");","map":{"version":3,"names":["PIECES","FEN_PIECES_BLACK","COLORS","CASTLE_ROW_WHITE","CASTLE_ROW_BLACK","CASTLE_KING_INITIAL_COL","CASTLE_ROOK_INITIAL_COL_LONG","CASTLE_ROOK_INITIAL_COL_SHORT","CASTLE_PATH_COLS_LONG","CASTLE_PATH_COLS_SHORT","PIECE_COLOR_INDEX","PIECE_PIECE_INDEX","FEN_PIECES_WHITE","EMPTY_SQUARE_PIECE","CASTLE_ROOK_FINAL_COL_LONG","CASTLE_ROOK_FINAL_COL_SHORT","CASTLE_KING_FINAL_COL_LONG","CASTLE_KING_FINAL_COL_SHORT","EMPTY_SQUARES_AFTER_LONG_CASTLE","EMPTY_SQUARES_AFTER_SHORT_CASTLE","BoardPosition","PIECE_DELIMITER","CASTLING_TYPES","IsUpperCase","value","charCodeAt","_c","IsLowerCase","_c2","IsDigit","_c3","ParseFEN","fen","fenParts","split","length","Error","fenBoard","fenTurn","fenCastling","fenEnPassant","fenHalfMoves","fenFullMoves","Number","_c4","ConvertFENtoPiece","letter","FEN_PIECE_MAP","PAWN","KNIGHT","KING","QUEEN","ROOK","BISHOP","toLowerCase","_c5","ConvertFENPieceToPiece","WHITE","BLACK","_c6","ConvertFenToString","reduce","result","char","repeat","_c7","checkIfTwoSquaresAreOnTheSameRow","square1","square2","props","x","isSquareOnRow","square","rowNumber","getPiece","piece","doesTheSquareHasThePiece","p","getPieceColor","isColorWhite","color","areWeCastling","castlingType","withWhite","row","pieces","rookCol","kingCol","pathCols","LONG","every","col","updateColumnOnARow","colIndex","newValue","handleSquareOnCurrentRow","targetSquare","handleSquareAndTargetSquareOnTheSameRow","y","handleTargetSquareOnCurrentRow","ConvertPieceToFENPiece","handleCastling","SidewaysCapture","isWhite","kingPiece","rookPiece","Object","values","forEach","type","emptySquares","kingFinalCol","rookFinalCol","UpdatePosition","position","map","rowIndex","_c8","targetColIndex","index","_c9","pieceMapping","fenPiece","toUpperCase","_c10","$RefreshReg$"],"sources":["C:/Users/Vladi Gotsin/Desktop/react/Chess-React.js-/src/HelperMethods.js"],"sourcesContent":["import {\r\n    PIECES, FEN_PIECES_BLACK, COLORS, CASTLE_ROW_WHITE, CASTLE_ROW_BLACK, CASTLE_KING_INITIAL_COL, CASTLE_ROOK_INITIAL_COL_LONG, CASTLE_ROOK_INITIAL_COL_SHORT,\r\n    CASTLE_PATH_COLS_LONG, CASTLE_PATH_COLS_SHORT, PIECE_COLOR_INDEX, PIECE_PIECE_INDEX, FEN_PIECES_WHITE, EMPTY_SQUARE_PIECE, CASTLE_ROOK_FINAL_COL_LONG,\r\n    CASTLE_ROOK_FINAL_COL_SHORT, CASTLE_KING_FINAL_COL_LONG, CASTLE_KING_FINAL_COL_SHORT, EMPTY_SQUARES_AFTER_LONG_CASTLE, EMPTY_SQUARES_AFTER_SHORT_CASTLE,\r\n    BoardPosition, PIECE_DELIMITER, CASTLING_TYPES\r\n} from './globalVariables'\r\n\r\n//Checks if a character is Uppercase using the ASCII table; 65 (A); 90 (Z)\r\nexport function IsUpperCase(value) {\r\n    return value.charCodeAt(0) >= 65 && value.charCodeAt(0) <= 90\r\n}\r\n\r\n//Checks if a character is Lowercase using the ASCII table; 97 (a); 122 (z)\r\nexport function IsLowerCase(value) {\r\n    return value.charCodeAt(0) >= 97 && value.charCodeAt(0) <= 122\r\n}\r\n\r\n//Checks if a character is a Digit using the ASCII table; 48 (0); 57 (9)\r\nexport function IsDigit(value) {\r\n    return value.charCodeAt(0) >= 48 && value.charCodeAt(0) <= 57\r\n}\r\n\r\n//splits the FEN string to each individual part that makes it\r\nexport function ParseFEN(fen) {\r\n    const fenParts = fen.split(EMPTY_SQUARE_PIECE);\r\n    if (fenParts.length !== 6) {\r\n        throw new Error('Invalid FEN');\r\n    }\r\n    const [fenBoard, fenTurn, fenCastling, fenEnPassant, fenHalfMoves, fenFullMoves] = fenParts;\r\n    return {\r\n        fenBoard,\r\n        fenTurn,\r\n        fenCastling,\r\n        fenEnPassant,\r\n        fenHalfMoves: Number(fenHalfMoves),\r\n        fenFullMoves: Number(fenFullMoves)\r\n    };\r\n}\r\n\r\n//converts FEN piece notation to an actual piece\r\nexport function ConvertFENtoPiece(letter) {\r\n    const FEN_PIECE_MAP = {\r\n        [FEN_PIECES_BLACK.PAWN]: PIECES.PAWN,\r\n        [FEN_PIECES_BLACK.KNIGHT]: PIECES.KNIGHT,\r\n        [FEN_PIECES_BLACK.KING]: PIECES.KING,\r\n        [FEN_PIECES_BLACK.QUEEN]: PIECES.QUEEN,\r\n        [FEN_PIECES_BLACK.ROOK]: PIECES.ROOK,\r\n        [FEN_PIECES_BLACK.BISHOP]: PIECES.BISHOP,\r\n    };\r\n\r\n    return FEN_PIECE_MAP[letter.toLowerCase()] || \"\";\r\n}\r\n\r\n//converts the FEN piece notation to a piece that we can use in the square component\r\nexport function ConvertFENPieceToPiece(value) {\r\n    if (IsUpperCase(value)) {\r\n        return `${COLORS.WHITE}-${ConvertFENtoPiece(value)}`;\r\n    }\r\n\r\n    if (IsLowerCase(value)) {\r\n        return `${COLORS.BLACK}-${ConvertFENtoPiece(value)}`;\r\n    }\r\n\r\n    return \"\";\r\n}\r\n\r\nexport function ConvertFenToString(value) {\r\n    return value.split('').reduce((result, char) => {\r\n        if (IsDigit(char)) {\r\n            return result + EMPTY_SQUARE_PIECE.repeat(Number(char));\r\n        }\r\n        return result + char;\r\n    }, '');\r\n}\r\n\r\nfunction checkIfTwoSquaresAreOnTheSameRow(square1, square2) {\r\n    return square1.props.x == square2.props.x\r\n}\r\n\r\nfunction isSquareOnRow(square, rowNumber) {\r\n    return square.props.x == rowNumber\r\n}\r\n\r\n//gets the piece\r\nexport function getPiece(square) {\r\n    return square.props.piece.split(PIECE_DELIMITER)[PIECE_PIECE_INDEX]\r\n}\r\n\r\n//checks if piece is positioned on a certain square\r\nexport function doesTheSquareHasThePiece(square, piece) {\r\n    let p = getPiece(square)\r\n\r\n    return p == piece\r\n}\r\n\r\n//gets the piece color\r\nexport function getPieceColor(square) {\r\n    return square.props.piece.split(PIECE_DELIMITER)[PIECE_COLOR_INDEX]\r\n}\r\n\r\n//checks if a color is white\r\nexport function isColorWhite(color) {\r\n    return color == COLORS.WHITE\r\n}\r\n\r\nfunction areWeCastling(castlingType, withWhite = true) {\r\n    const row = withWhite ? CASTLE_ROW_WHITE : CASTLE_ROW_BLACK;\r\n    const pieces = withWhite ? FEN_PIECES_WHITE : FEN_PIECES_BLACK;\r\n    const [rookCol, kingCol, pathCols] = castlingType === CASTLING_TYPES.LONG ?\r\n        [CASTLE_ROOK_INITIAL_COL_LONG, CASTLE_KING_INITIAL_COL, CASTLE_PATH_COLS_LONG] :\r\n        [CASTLE_ROOK_INITIAL_COL_SHORT, CASTLE_KING_INITIAL_COL, CASTLE_PATH_COLS_SHORT];\r\n\r\n    return BoardPosition[row][rookCol] === pieces.ROOK &&\r\n        BoardPosition[row][kingCol] === pieces.KING &&\r\n        pathCols.every(col => BoardPosition[row][col] === EMPTY_SQUARE_PIECE);\r\n}\r\n\r\nfunction updateColumnOnARow(row, colIndex, newValue) {\r\n    row[colIndex] = newValue\r\n    return row\r\n}\r\n\r\n//removes the current square's piece\r\nfunction handleSquareOnCurrentRow(square, targetSquare, row) {\r\n    return checkIfTwoSquaresAreOnTheSameRow(square, targetSquare) ?\r\n        handleSquareAndTargetSquareOnTheSameRow(square, targetSquare, row) :\r\n        updateColumnOnARow(row, square.props.y, EMPTY_SQUARE_PIECE);\r\n}\r\n\r\n//updates the targetSquare with the current's square's piece\r\nfunction handleTargetSquareOnCurrentRow(square, targetSquare, row) {\r\n    return updateColumnOnARow(row, targetSquare.props.y, ConvertPieceToFENPiece(square.props.piece))\r\n}\r\n\r\n//checks if we're making a move on the same row and performs castling if we want to castle\r\nfunction handleSquareAndTargetSquareOnTheSameRow(square, targetSquare, row) {\r\n    if (doesTheSquareHasThePiece(square, PIECES.KING) && areWeCastling(square, targetSquare)) {\r\n        return handleCastling(square, row)\r\n    }\r\n\r\n    return SidewaysCapture(row, Number(square.props.y), Number(targetSquare.props.y), square.props.piece)\r\n}\r\n\r\n//performs castling, swaps the rook and the king\r\nfunction handleCastling(square, row) {\r\n    const color = getPieceColor(square);\r\n    const isWhite = isColorWhite(color);\r\n    const kingPiece = isWhite ? FEN_PIECES_WHITE.KING : FEN_PIECES_BLACK.KING;\r\n    const rookPiece = isWhite ? FEN_PIECES_WHITE.ROOK : FEN_PIECES_BLACK.ROOK;\r\n\r\n    Object.values(CASTLING_TYPES).forEach(type => {\r\n        if (areWeCastling(type, isWhite)) {\r\n            const [emptySquares, kingFinalCol, rookFinalCol] = type === CASTLING_TYPES.LONG ?\r\n                [EMPTY_SQUARES_AFTER_LONG_CASTLE, CASTLE_KING_FINAL_COL_LONG, CASTLE_ROOK_FINAL_COL_LONG] :\r\n                [EMPTY_SQUARES_AFTER_SHORT_CASTLE, CASTLE_KING_FINAL_COL_SHORT, CASTLE_ROOK_FINAL_COL_SHORT];\r\n            emptySquares.forEach(col => row[col] = EMPTY_SQUARE_PIECE);\r\n            row[kingFinalCol] = kingPiece;\r\n            row[rookFinalCol] = rookPiece;\r\n        }\r\n    });\r\n\r\n    return row;\r\n}\r\n\r\n//updates the current position to a new position after making the move\r\n//provide the current square, the targetSquare (where you want to move to) and the current position\r\nexport function UpdatePosition(square, targetSquare, position) {\r\n    return position.map((row, rowIndex) => {\r\n        if (isSquareOnRow(square, rowIndex)) {\r\n            row = handleSquareOnCurrentRow(square, targetSquare, row);\r\n        }\r\n        if (isSquareOnRow(targetSquare, rowIndex)) {\r\n            row = handleTargetSquareOnCurrentRow(square, targetSquare, row);\r\n        }\r\n        return row;\r\n    });\r\n}\r\n\r\n//modifies the row to capture pieces sideways (square and targetSquare are on the same row)\r\nfunction SidewaysCapture(row, colIndex, targetColIndex, value) {\r\n    return row.map((col, index) => {\r\n        if (index === colIndex) return EMPTY_SQUARE_PIECE;\r\n        if (index === targetColIndex) return ConvertPieceToFENPiece(value);\r\n        return col;\r\n    });\r\n}\r\n\r\n//converts the piece from format {color-piece} to FEN format (a single letter)\r\nfunction ConvertPieceToFENPiece(value) {\r\n    const [color, piece] = value.split(PIECE_DELIMITER);\r\n    const pieceMapping = {\r\n        [PIECES.PAWN]: FEN_PIECES_BLACK.PAWN,\r\n        [PIECES.KNIGHT]: FEN_PIECES_BLACK.KNIGHT,\r\n        [PIECES.BISHOP]: FEN_PIECES_BLACK.BISHOP,\r\n        [PIECES.ROOK]: FEN_PIECES_BLACK.ROOK,\r\n        [PIECES.QUEEN]: FEN_PIECES_BLACK.QUEEN,\r\n        [PIECES.KING]: FEN_PIECES_BLACK.KING,\r\n    };\r\n\r\n    const fenPiece = pieceMapping[piece];\r\n    return isColorWhite(color) ? fenPiece.toUpperCase() : fenPiece;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}