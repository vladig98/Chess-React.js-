{"ast":null,"code":"import * as GlobalVariables from './globalVariables';\n\n/**\r\n * Checks if a character is Uppercase using the ASCII table; 65 (A) to 90 (Z)\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is uppercase, false otherwise.\r\n */\nexport function IsUpperCase(value) {\n  return value.charCodeAt(0) >= 65 && value.charCodeAt(0) <= 90;\n}\n\n/**\r\n * Checks if a character is Lowercase using the ASCII table; 97 (a) to 122 (z)\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is lowercase, false otherwise.\r\n */\n_c = IsUpperCase;\nexport function IsLowerCase(value) {\n  return value.charCodeAt(0) >= 97 && value.charCodeAt(0) <= 122;\n}\n\n/**\r\n * Checks if a character is a Digit using the ASCII table; 48 (0) to 57 (9)\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is a digit, false otherwise.\r\n */\n_c2 = IsLowerCase;\nexport function IsDigit(value) {\n  return value.charCodeAt(0) >= 48 && value.charCodeAt(0) <= 57;\n}\n\n/**\r\n * Splits the FEN string into its individual components.\r\n * @param {string} fen - The FEN string.\r\n * @returns {object} - An object containing the parts of the FEN string.\r\n * @throws {Error} - Throws an error if the FEN string is invalid.\r\n */\n_c3 = IsDigit;\nexport function ParseFEN(fen) {\n  const fenParts = fen.split(GlobalVariables.EMPTY_SQUARE_PIECE);\n  if (fenParts.length !== 6) {\n    throw new Error('Invalid FEN');\n  }\n  const [fenBoard, fenTurn, fenCastling, fenEnPassant, fenHalfMoves, fenFullMoves] = fenParts;\n  return {\n    fenBoard,\n    fenTurn,\n    fenCastling,\n    fenEnPassant,\n    fenHalfMoves: Number(fenHalfMoves),\n    fenFullMoves: Number(fenFullMoves)\n  };\n}\n\n/**\r\n * Converts FEN piece notation to an actual piece.\r\n * @param {string} letter - The FEN piece notation.\r\n * @returns {string} - The corresponding piece.\r\n */\n_c4 = ParseFEN;\nexport function ConvertFENtoPiece(letter) {\n  const FEN_PIECE_MAP = {\n    [GlobalVariables.FEN_PIECES_BLACK.PAWN]: GlobalVariables.PIECES.PAWN,\n    [GlobalVariables.FEN_PIECES_BLACK.KNIGHT]: GlobalVariables.PIECES.KNIGHT,\n    [GlobalVariables.FEN_PIECES_BLACK.KING]: GlobalVariables.PIECES.KING,\n    [GlobalVariables.FEN_PIECES_BLACK.QUEEN]: GlobalVariables.PIECES.QUEEN,\n    [GlobalVariables.FEN_PIECES_BLACK.ROOK]: GlobalVariables.PIECES.ROOK,\n    [GlobalVariables.FEN_PIECES_BLACK.BISHOP]: GlobalVariables.PIECES.BISHOP\n  };\n  return FEN_PIECE_MAP[letter.toLowerCase()] || \"\";\n}\n\n/**\r\n * Checks if a pawn is on its starting square and allows a 2-squares move\r\n * @param {object} pawn - The pawn to check.\r\n * @returns {boolean} - True if the pawn is on its starting square, false otherwise.\r\n */\n_c5 = ConvertFENtoPiece;\nexport function isPawnOnStartingSquare(pawn) {\n  return isColorWhite(getPieceColor(pawn)) ? pawn.props.x == GlobalVariables.WHITE_PAWN_STARTING_SQUARE : pawn.props.x == GlobalVariables.BLACK_PAWN_STARTING_SQUARE;\n}\n\n/**\r\n * Checks if a pawn is on an En Passant square.\r\n * @param {object} pawn - The pawn to check.\r\n * @returns {boolean} - True if the pawn is on an En Passant square, false otherwise.\r\n */\nexport function isPawnOnEnPassantSquare(pawn) {\n  return isColorWhite(getPieceColor(pawn)) ? pawn.props.x == GlobalVariables.WHITE_EN_PASSANT_SQUARE : pawn.props.x == GlobalVariables.BLACK_EN_PASSANT_SQUARE;\n}\n\n/**\r\n * Checks if two squares have the same x and y location.\r\n * @param {object} square1 - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if the the squares have the same location, false otherwise.\r\n */\nexport function compareIfTwoSquaresAreTheSame(square1, square2) {\n  if (!square1 || !square2) {\n    return false;\n  }\n  return square1.props.x == square2.props.x && square1.props.y == square2.props.y;\n}\n\n/**\r\n * Checks if a certain moves's location matches the currently selected piece\r\n * @param {object} move - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if the the squares have the same location, false otherwise.\r\n */\nexport function checkIfAMoveIsEqualToTheCurrentSelectedSquare(move) {\n  return move.props.x == CurrentSquareSelection.x && move.props.y == CurrentSquareSelection.y;\n}\n\n/**\r\n * Converts the FEN piece notation to a piece that we can use in the square component.\r\n * @param {string} value - The FEN piece notation.\r\n * @returns {string} - The piece with color information.\r\n */\nexport function ConvertFENPieceToPiece(value) {\n  if (IsUpperCase(value)) {\n    return `${GlobalVariables.COLORS.WHITE}-${ConvertFENtoPiece(value)}`;\n  }\n  if (IsLowerCase(value)) {\n    return `${GlobalVariables.COLORS.BLACK}-${ConvertFENtoPiece(value)}`;\n  }\n  return \"\";\n}\n\n/**\r\n * Converts a string in FEN format to a normal string, e.g., 'p6p' => 'p      p'\r\n * @param {string} value - The FEN string.\r\n * @returns {string} - The converted string.\r\n */\n_c6 = ConvertFENPieceToPiece;\nexport function ConvertFenToString(value) {\n  return value.split('').reduce((result, char) => {\n    if (IsDigit(char)) {\n      return result + GlobalVariables.EMPTY_SQUARE_PIECE.repeat(Number(char));\n    }\n    return result + char;\n  }, '');\n}\n\n/**\r\n * Checks if two squares are on the same row.\r\n * @param {object} square1 - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if both squares are on the same row, false otherwise.\r\n */\n_c7 = ConvertFenToString;\nfunction checkIfTwoSquaresAreOnTheSameRow(square1, square2) {\n  return square1.props.x == square2.props.x;\n}\n\n/**\r\n * Checks if the square is on the given row number.\r\n * @param {object} square - The square to check.\r\n * @param {number} rowNumber - The row number to check against.\r\n * @returns {boolean} - True if the square is on the given row, false otherwise.\r\n */\nfunction isSquareOnRow(square, rowNumber) {\n  return square.props.x == rowNumber;\n}\n\n/**\r\n * Gets the piece from a square.\r\n * @param {object} square - The square to get the piece from.\r\n * @returns {string} - The piece on the square.\r\n */\nexport function getPiece(square) {\n  return square.props.piece.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_PIECE_INDEX];\n}\n\n/**\r\n * Checks if the given square has the specified piece.\r\n * @param {object} square - The square to check.\r\n * @param {string} piece - The piece to check for.\r\n * @returns {boolean} - True if the square has the specified piece, false otherwise.\r\n */\nexport function doesTheSquareHasThePiece(square, piece) {\n  return getPiece(square) == piece;\n}\n\n/**\r\n * Gets the color of the piece on a square.\r\n * @param {object} square - The square to get the piece color from.\r\n * @returns {string} - The color of the piece.\r\n */\nexport function getPieceColor(square) {\n  return square.props.piece.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_COLOR_INDEX];\n}\n\n/**\r\n * Checks if the given color is white.\r\n * @param {string} color - The color to check.\r\n * @returns {boolean} - True if the color is white, false otherwise.\r\n */\nexport function isColorWhite(color) {\n  return color == GlobalVariables.COLORS.WHITE;\n}\n\n/**\r\n * Checks if the given color is black.\r\n * @param {string} color - The color to check.\r\n * @returns {boolean} - True if the color is black, false otherwise.\r\n */\nexport function isColorBlack(color) {\n  return color == GlobalVariables.COLORS.BLACK;\n}\n\n/**\r\n * Checks if two squares have a pice with the same color.\r\n * @param {object} square1 - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if the pieces color is the same, false otherwise.\r\n */\nexport function areSameColor(square1, square2) {\n  if (!square1 || !square2) {\n    return false;\n  }\n  return getPieceColor(square1) == getPieceColor(square2);\n}\n\n/**\r\n * Checks if a square has a piece on it or if it's free to move to.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the square is free, false otherwise.\r\n */\nexport function isSquareAvailable(square) {\n  return square && !square.props.piece;\n}\n\n/**\r\n * Converts board coordinates to X and Y position on the board, e.g., a8 = 0, 0\r\n * @param {string} coordinates - The board coordinates to convert.\r\n * @returns {object} - Returns an object with x and y properties.\r\n */\nexport function convertCoordinatesToLocation(coordinates) {\n  let tokens = coordinates.split('');\n\n  //skip invalid coordinates\n  if (tokens.length != 2) {\n    return;\n  }\n  let letter = tokens[0].toString().toUpperCase();\n  let number = tokens[1];\n\n  //65 is the ASCII code for capital A which will give us 0 if we have A as a coordinate; A-F will give us 0-7 for y (columns)\n  //reverse the numbers since we draw the board top down for x (rows)\n  return {\n    x: DIM - Number(number),\n    y: letter.charCodeAt(0) - 65\n  };\n}\n\n/**\r\n * Converts a piece location to board coordinate, e.g., 0, 0 to a8\r\n * @param {string} x - The X position.\r\n * @param {string} y - The Y position.\r\n * @returns {string} - Returns a string containing the board coordinates.\r\n */\nexport function convertLocationToCoordinates(x, y) {\n  //maps y (column) to the letter coordinate; add 65 (capital A code) to the ASCII code for the location we have and we get a letter between A and F\n  //reverses the x (rows) coordinate because we drop the board top down, while coordinates go down up\n  return `${String.fromCharCode(y + 65)}${DIM - x}`.toLowerCase();\n}\n\n/**\r\n * Retrieves a specific square from the board using x and y coordinates (location)\r\n * @param {string} x - The X position.\r\n * @param {string} y - The Y position.\r\n * @param {array} boardSquares - The board array.\r\n * @returns {object} - Returns the square.\r\n */\nexport function getATargetSquareByLocation(x, y, boardSquares) {\n  return boardSquares.find(s => s.props.x === x && s.props.y === y);\n}\n\n/**\r\n * Retrieves a specific square from the board that has a certain piece\r\n * @param {string} piece - The piece to check if it's on the square.\r\n * @param {array} boardSquares - The board array.\r\n * @returns {object} - Returns the square.\r\n */\nexport function getATargetSquareByPiece(piece, boardSquares) {\n  return boardSquares.find(s => s.props.piece == piece);\n}\n\n/**\r\n * Determines if castling is possible.\r\n * @param {string} castlingType - The type of castling (long or short).\r\n * @param {boolean} [withWhite=true] - True if checking for white's castling, false otherwise.\r\n * @returns {boolean} - True if castling is possible, false otherwise.\r\n */\nfunction areWeCastling(castlingType, withWhite = true) {\n  const row = withWhite ? GlobalVariables.CASTLE_ROW_WHITE : GlobalVariables.CASTLE_ROW_BLACK;\n  const pieces = withWhite ? GlobalVariables.FEN_PIECES_WHITE : GlobalVariables.FEN_PIECES_BLACK;\n  const [rookCol, kingCol, pathCols] = castlingType === GlobalVariables.CASTLING_TYPES.LONG ? [GlobalVariables.CASTLE_ROOK_INITIAL_COL_LONG, GlobalVariables.CASTLE_KING_INITIAL_COL, GlobalVariables.CASTLE_PATH_COLS_LONG] : [GlobalVariables.CASTLE_ROOK_INITIAL_COL_SHORT, GlobalVariables.CASTLE_KING_INITIAL_COL, GlobalVariables.CASTLE_PATH_COLS_SHORT];\n  return BoardPosition[row][rookCol] === pieces.ROOK && BoardPosition[row][kingCol] === pieces.KING && pathCols.every(col => BoardPosition[row][col] === GlobalVariables.EMPTY_SQUARE_PIECE);\n}\n\n/**\r\n * Updates a column on a row with a new value.\r\n * @param {array} row - The row to update.\r\n * @param {number} colIndex - The column index to update.\r\n * @param {string} newValue - The new value to set.\r\n * @returns {array} - The updated row.\r\n */\nfunction updateColumnOnARow(row, colIndex, newValue) {\n  row[colIndex] = newValue;\n  return row;\n}\n\n/**\r\n * Removes the current square's piece and handles castling if applicable.\r\n * @param {object} square - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {array} row - The row to update.\r\n * @returns {array} - The updated row.\r\n */\nfunction handleSquareOnCurrentRow(square, targetSquare, row) {\n  return checkIfTwoSquaresAreOnTheSameRow(square, targetSquare) ? handleSquareAndTargetSquareOnTheSameRow(square, targetSquare, row) : updateColumnOnARow(row, square.props.y, GlobalVariables.EMPTY_SQUARE_PIECE);\n}\n\n/**\r\n * Updates the target square with the current square's piece.\r\n * @param {object} square - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {array} row - The row to update.\r\n * @returns {array} - The updated row.\r\n */\nfunction handleTargetSquareOnCurrentRow(square, targetSquare, row) {\n  return updateColumnOnARow(row, targetSquare.props.y, ConvertPieceToFENPiece(square.props.piece));\n}\n\n/**\r\n * Handles the scenario where the current square and target square are on the same row.\r\n * @param {object} square - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {array} row - The row to update.\r\n * @returns {array} - The updated row.\r\n */\nfunction handleSquareAndTargetSquareOnTheSameRow(square, targetSquare, row) {\n  if (doesTheSquareHasThePiece(square, GlobalVariables.PIECES.KING) && areWeCastling(square, targetSquare)) {\n    return handleCastling(square, row);\n  }\n  return SidewaysCapture(row, Number(square.props.y), Number(targetSquare.props.y), square.props.piece);\n}\n\n/**\r\n * Performs castling, swapping the rook and the king.\r\n * @param {object} square - The current square.\r\n * @param {array} row - The row to update.\r\n * @returns {array} - The updated row.\r\n */\nfunction handleCastling(square, row) {\n  const color = getPieceColor(square);\n  const isWhite = isColorWhite(color);\n  const kingPiece = isWhite ? GlobalVariables.FEN_PIECES_WHITE.KING : GlobalVariables.FEN_PIECES_BLACK.KING;\n  const rookPiece = isWhite ? GlobalVariables.FEN_PIECES_WHITE.ROOK : GlobalVariables.FEN_PIECES_BLACK.ROOK;\n  Object.values(CASTLING_TYPES).forEach(type => {\n    if (areWeCastling(type, isWhite)) {\n      const [emptySquares, kingFinalCol, rookFinalCol] = type === GlobalVariables.CASTLING_TYPES.LONG ? [GlobalVariables.EMPTY_SQUARES_AFTER_LONG_CASTLE, GlobalVariables.CASTLE_KING_FINAL_COL_LONG, GlobalVariables.CASTLE_ROOK_FINAL_COL_LONG] : [GlobalVariables.EMPTY_SQUARES_AFTER_SHORT_CASTLE, GlobalVariables.CASTLE_KING_FINAL_COL_SHORT, GlobalVariables.CASTLE_ROOK_FINAL_COL_SHORT];\n      emptySquares.forEach(col => row[col] = GlobalVariables.EMPTY_SQUARE_PIECE);\n      row[kingFinalCol] = kingPiece;\n      row[rookFinalCol] = rookPiece;\n    }\n  });\n  return row;\n}\n\n/**\r\n * Updates the current position to a new position after making the move.\r\n * @param {object} square - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {array} position - The current position.\r\n * @returns {array} - The updated position.\r\n */\nexport function UpdatePosition(square, targetSquare, position) {\n  return position.map((row, rowIndex) => {\n    if (isSquareOnRow(square, rowIndex)) {\n      row = handleSquareOnCurrentRow(square, targetSquare, row);\n    }\n    if (isSquareOnRow(targetSquare, rowIndex)) {\n      row = handleTargetSquareOnCurrentRow(square, targetSquare, row);\n    }\n    return row;\n  });\n}\n\n/**\r\n * Modifies the row to capture pieces sideways (square and target square are on the same row).\r\n * @param {array} row - The row to update.\r\n * @param {number} colIndex - The column index of the square.\r\n * @param {number} targetColIndex - The column index of the target square.\r\n * @param {string} value - The value to place at the target column index.\r\n * @returns {array} - The updated row.\r\n */\n_c8 = UpdatePosition;\nfunction SidewaysCapture(row, colIndex, targetColIndex, value) {\n  return row.map((col, index) => {\n    if (index === colIndex) return GlobalVariables.EMPTY_SQUARE_PIECE;\n    if (index === targetColIndex) return ConvertPieceToFENPiece(value);\n    return col;\n  });\n}\n\n/**\r\n * Converts the piece from format {color-piece} to FEN format (a single letter).\r\n * @param {string} value - The piece in {color-piece} format.\r\n * @returns {string} - The piece in FEN format.\r\n */\n_c9 = SidewaysCapture;\nfunction ConvertPieceToFENPiece(value) {\n  const [color, piece] = value.split(GlobalVariables.PIECE_DELIMITER);\n  const pieceMapping = {\n    [GlobalVariables.PIECES.PAWN]: GlobalVariables.FEN_PIECES_BLACK.PAWN,\n    [GlobalVariables.PIECES.KNIGHT]: GlobalVariables.FEN_PIECES_BLACK.KNIGHT,\n    [GlobalVariables.PIECES.BISHOP]: GlobalVariables.FEN_PIECES_BLACK.BISHOP,\n    [GlobalVariables.PIECES.ROOK]: GlobalVariables.FEN_PIECES_BLACK.ROOK,\n    [GlobalVariables.PIECES.QUEEN]: GlobalVariables.FEN_PIECES_BLACK.QUEEN,\n    [GlobalVariables.PIECES.KING]: GlobalVariables.FEN_PIECES_BLACK.KING\n  };\n  const fenPiece = pieceMapping[piece];\n  return isColorWhite(color) ? fenPiece.toUpperCase() : fenPiece;\n}\n_c10 = ConvertPieceToFENPiece;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10;\n$RefreshReg$(_c, \"IsUpperCase\");\n$RefreshReg$(_c2, \"IsLowerCase\");\n$RefreshReg$(_c3, \"IsDigit\");\n$RefreshReg$(_c4, \"ParseFEN\");\n$RefreshReg$(_c5, \"ConvertFENtoPiece\");\n$RefreshReg$(_c6, \"ConvertFENPieceToPiece\");\n$RefreshReg$(_c7, \"ConvertFenToString\");\n$RefreshReg$(_c8, \"UpdatePosition\");\n$RefreshReg$(_c9, \"SidewaysCapture\");\n$RefreshReg$(_c10, \"ConvertPieceToFENPiece\");","map":{"version":3,"names":["GlobalVariables","IsUpperCase","value","charCodeAt","_c","IsLowerCase","_c2","IsDigit","_c3","ParseFEN","fen","fenParts","split","EMPTY_SQUARE_PIECE","length","Error","fenBoard","fenTurn","fenCastling","fenEnPassant","fenHalfMoves","fenFullMoves","Number","_c4","ConvertFENtoPiece","letter","FEN_PIECE_MAP","FEN_PIECES_BLACK","PAWN","PIECES","KNIGHT","KING","QUEEN","ROOK","BISHOP","toLowerCase","_c5","isPawnOnStartingSquare","pawn","isColorWhite","getPieceColor","props","x","WHITE_PAWN_STARTING_SQUARE","BLACK_PAWN_STARTING_SQUARE","isPawnOnEnPassantSquare","WHITE_EN_PASSANT_SQUARE","BLACK_EN_PASSANT_SQUARE","compareIfTwoSquaresAreTheSame","square1","square2","y","checkIfAMoveIsEqualToTheCurrentSelectedSquare","move","CurrentSquareSelection","ConvertFENPieceToPiece","COLORS","WHITE","BLACK","_c6","ConvertFenToString","reduce","result","char","repeat","_c7","checkIfTwoSquaresAreOnTheSameRow","isSquareOnRow","square","rowNumber","getPiece","piece","PIECE_DELIMITER","PIECE_PIECE_INDEX","doesTheSquareHasThePiece","PIECE_COLOR_INDEX","color","isColorBlack","areSameColor","isSquareAvailable","convertCoordinatesToLocation","coordinates","tokens","toString","toUpperCase","number","DIM","convertLocationToCoordinates","String","fromCharCode","getATargetSquareByLocation","boardSquares","find","s","getATargetSquareByPiece","areWeCastling","castlingType","withWhite","row","CASTLE_ROW_WHITE","CASTLE_ROW_BLACK","pieces","FEN_PIECES_WHITE","rookCol","kingCol","pathCols","CASTLING_TYPES","LONG","CASTLE_ROOK_INITIAL_COL_LONG","CASTLE_KING_INITIAL_COL","CASTLE_PATH_COLS_LONG","CASTLE_ROOK_INITIAL_COL_SHORT","CASTLE_PATH_COLS_SHORT","BoardPosition","every","col","updateColumnOnARow","colIndex","newValue","handleSquareOnCurrentRow","targetSquare","handleSquareAndTargetSquareOnTheSameRow","handleTargetSquareOnCurrentRow","ConvertPieceToFENPiece","handleCastling","SidewaysCapture","isWhite","kingPiece","rookPiece","Object","values","forEach","type","emptySquares","kingFinalCol","rookFinalCol","EMPTY_SQUARES_AFTER_LONG_CASTLE","CASTLE_KING_FINAL_COL_LONG","CASTLE_ROOK_FINAL_COL_LONG","EMPTY_SQUARES_AFTER_SHORT_CASTLE","CASTLE_KING_FINAL_COL_SHORT","CASTLE_ROOK_FINAL_COL_SHORT","UpdatePosition","position","map","rowIndex","_c8","targetColIndex","index","_c9","pieceMapping","fenPiece","_c10","$RefreshReg$"],"sources":["C:/Users/Vladi Gotsin/Desktop/react/Chess-React.js-/src/HelperMethods.js"],"sourcesContent":["import * as GlobalVariables from './globalVariables';\r\n\r\n/**\r\n * Checks if a character is Uppercase using the ASCII table; 65 (A) to 90 (Z)\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is uppercase, false otherwise.\r\n */\r\nexport function IsUpperCase(value) {\r\n    return value.charCodeAt(0) >= 65 && value.charCodeAt(0) <= 90;\r\n}\r\n\r\n/**\r\n * Checks if a character is Lowercase using the ASCII table; 97 (a) to 122 (z)\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is lowercase, false otherwise.\r\n */\r\nexport function IsLowerCase(value) {\r\n    return value.charCodeAt(0) >= 97 && value.charCodeAt(0) <= 122;\r\n}\r\n\r\n/**\r\n * Checks if a character is a Digit using the ASCII table; 48 (0) to 57 (9)\r\n * @param {string} value - The character to check.\r\n * @returns {boolean} - True if the character is a digit, false otherwise.\r\n */\r\nexport function IsDigit(value) {\r\n    return value.charCodeAt(0) >= 48 && value.charCodeAt(0) <= 57;\r\n}\r\n\r\n/**\r\n * Splits the FEN string into its individual components.\r\n * @param {string} fen - The FEN string.\r\n * @returns {object} - An object containing the parts of the FEN string.\r\n * @throws {Error} - Throws an error if the FEN string is invalid.\r\n */\r\nexport function ParseFEN(fen) {\r\n    const fenParts = fen.split(GlobalVariables.EMPTY_SQUARE_PIECE);\r\n    if (fenParts.length !== 6) {\r\n        throw new Error('Invalid FEN');\r\n    }\r\n    const [fenBoard, fenTurn, fenCastling, fenEnPassant, fenHalfMoves, fenFullMoves] = fenParts;\r\n    return {\r\n        fenBoard,\r\n        fenTurn,\r\n        fenCastling,\r\n        fenEnPassant,\r\n        fenHalfMoves: Number(fenHalfMoves),\r\n        fenFullMoves: Number(fenFullMoves)\r\n    };\r\n}\r\n\r\n/**\r\n * Converts FEN piece notation to an actual piece.\r\n * @param {string} letter - The FEN piece notation.\r\n * @returns {string} - The corresponding piece.\r\n */\r\nexport function ConvertFENtoPiece(letter) {\r\n    const FEN_PIECE_MAP = {\r\n        [GlobalVariables.FEN_PIECES_BLACK.PAWN]: GlobalVariables.PIECES.PAWN,\r\n        [GlobalVariables.FEN_PIECES_BLACK.KNIGHT]: GlobalVariables.PIECES.KNIGHT,\r\n        [GlobalVariables.FEN_PIECES_BLACK.KING]: GlobalVariables.PIECES.KING,\r\n        [GlobalVariables.FEN_PIECES_BLACK.QUEEN]: GlobalVariables.PIECES.QUEEN,\r\n        [GlobalVariables.FEN_PIECES_BLACK.ROOK]: GlobalVariables.PIECES.ROOK,\r\n        [GlobalVariables.FEN_PIECES_BLACK.BISHOP]: GlobalVariables.PIECES.BISHOP,\r\n    };\r\n\r\n    return FEN_PIECE_MAP[letter.toLowerCase()] || \"\";\r\n}\r\n\r\n/**\r\n * Checks if a pawn is on its starting square and allows a 2-squares move\r\n * @param {object} pawn - The pawn to check.\r\n * @returns {boolean} - True if the pawn is on its starting square, false otherwise.\r\n */\r\nexport function isPawnOnStartingSquare(pawn) {\r\n    return isColorWhite(getPieceColor(pawn)) ? pawn.props.x == GlobalVariables.WHITE_PAWN_STARTING_SQUARE : pawn.props.x == GlobalVariables.BLACK_PAWN_STARTING_SQUARE\r\n}\r\n\r\n/**\r\n * Checks if a pawn is on an En Passant square.\r\n * @param {object} pawn - The pawn to check.\r\n * @returns {boolean} - True if the pawn is on an En Passant square, false otherwise.\r\n */\r\nexport function isPawnOnEnPassantSquare(pawn) {\r\n    return isColorWhite(getPieceColor(pawn)) ? pawn.props.x == GlobalVariables.WHITE_EN_PASSANT_SQUARE : pawn.props.x == GlobalVariables.BLACK_EN_PASSANT_SQUARE\r\n}\r\n\r\n/**\r\n * Checks if two squares have the same x and y location.\r\n * @param {object} square1 - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if the the squares have the same location, false otherwise.\r\n */\r\nexport function compareIfTwoSquaresAreTheSame(square1, square2) {\r\n    if (!square1 || !square2) {\r\n        return false\r\n    }\r\n\r\n    return square1.props.x == square2.props.x && square1.props.y == square2.props.y\r\n}\r\n\r\n/**\r\n * Checks if a certain moves's location matches the currently selected piece\r\n * @param {object} move - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if the the squares have the same location, false otherwise.\r\n */\r\nexport function checkIfAMoveIsEqualToTheCurrentSelectedSquare(move) {\r\n    return move.props.x == CurrentSquareSelection.x && move.props.y == CurrentSquareSelection.y\r\n}\r\n\r\n/**\r\n * Converts the FEN piece notation to a piece that we can use in the square component.\r\n * @param {string} value - The FEN piece notation.\r\n * @returns {string} - The piece with color information.\r\n */\r\nexport function ConvertFENPieceToPiece(value) {\r\n    if (IsUpperCase(value)) {\r\n        return `${GlobalVariables.COLORS.WHITE}-${ConvertFENtoPiece(value)}`;\r\n    }\r\n\r\n    if (IsLowerCase(value)) {\r\n        return `${GlobalVariables.COLORS.BLACK}-${ConvertFENtoPiece(value)}`;\r\n    }\r\n\r\n    return \"\";\r\n}\r\n\r\n/**\r\n * Converts a string in FEN format to a normal string, e.g., 'p6p' => 'p      p'\r\n * @param {string} value - The FEN string.\r\n * @returns {string} - The converted string.\r\n */\r\nexport function ConvertFenToString(value) {\r\n    return value.split('').reduce((result, char) => {\r\n        if (IsDigit(char)) {\r\n            return result + GlobalVariables.EMPTY_SQUARE_PIECE.repeat(Number(char));\r\n        }\r\n        return result + char;\r\n    }, '');\r\n}\r\n\r\n/**\r\n * Checks if two squares are on the same row.\r\n * @param {object} square1 - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if both squares are on the same row, false otherwise.\r\n */\r\nfunction checkIfTwoSquaresAreOnTheSameRow(square1, square2) {\r\n    return square1.props.x == square2.props.x;\r\n}\r\n\r\n/**\r\n * Checks if the square is on the given row number.\r\n * @param {object} square - The square to check.\r\n * @param {number} rowNumber - The row number to check against.\r\n * @returns {boolean} - True if the square is on the given row, false otherwise.\r\n */\r\nfunction isSquareOnRow(square, rowNumber) {\r\n    return square.props.x == rowNumber;\r\n}\r\n\r\n/**\r\n * Gets the piece from a square.\r\n * @param {object} square - The square to get the piece from.\r\n * @returns {string} - The piece on the square.\r\n */\r\nexport function getPiece(square) {\r\n    return square.props.piece.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_PIECE_INDEX];\r\n}\r\n\r\n/**\r\n * Checks if the given square has the specified piece.\r\n * @param {object} square - The square to check.\r\n * @param {string} piece - The piece to check for.\r\n * @returns {boolean} - True if the square has the specified piece, false otherwise.\r\n */\r\nexport function doesTheSquareHasThePiece(square, piece) {\r\n    return getPiece(square) == piece;\r\n}\r\n\r\n/**\r\n * Gets the color of the piece on a square.\r\n * @param {object} square - The square to get the piece color from.\r\n * @returns {string} - The color of the piece.\r\n */\r\nexport function getPieceColor(square) {\r\n    return square.props.piece.split(GlobalVariables.PIECE_DELIMITER)[GlobalVariables.PIECE_COLOR_INDEX];\r\n}\r\n\r\n/**\r\n * Checks if the given color is white.\r\n * @param {string} color - The color to check.\r\n * @returns {boolean} - True if the color is white, false otherwise.\r\n */\r\nexport function isColorWhite(color) {\r\n    return color == GlobalVariables.COLORS.WHITE;\r\n}\r\n\r\n/**\r\n * Checks if the given color is black.\r\n * @param {string} color - The color to check.\r\n * @returns {boolean} - True if the color is black, false otherwise.\r\n */\r\nexport function isColorBlack(color) {\r\n    return color == GlobalVariables.COLORS.BLACK\r\n}\r\n\r\n/**\r\n * Checks if two squares have a pice with the same color.\r\n * @param {object} square1 - The first square.\r\n * @param {object} square2 - The second square.\r\n * @returns {boolean} - True if the pieces color is the same, false otherwise.\r\n */\r\nexport function areSameColor(square1, square2) {\r\n    if (!square1 || !square2) {\r\n        return false\r\n    }\r\n\r\n    return getPieceColor(square1) == getPieceColor(square2)\r\n}\r\n\r\n/**\r\n * Checks if a square has a piece on it or if it's free to move to.\r\n * @param {object} square - The square to check.\r\n * @returns {boolean} - True if the square is free, false otherwise.\r\n */\r\nexport function isSquareAvailable(square) {\r\n    return square && !square.props.piece\r\n}\r\n\r\n/**\r\n * Converts board coordinates to X and Y position on the board, e.g., a8 = 0, 0\r\n * @param {string} coordinates - The board coordinates to convert.\r\n * @returns {object} - Returns an object with x and y properties.\r\n */\r\nexport function convertCoordinatesToLocation(coordinates) {\r\n    let tokens = coordinates.split('')\r\n\r\n    //skip invalid coordinates\r\n    if (tokens.length != 2) {\r\n        return\r\n    }\r\n\r\n    let letter = tokens[0].toString().toUpperCase()\r\n    let number = tokens[1]\r\n\r\n    //65 is the ASCII code for capital A which will give us 0 if we have A as a coordinate; A-F will give us 0-7 for y (columns)\r\n    //reverse the numbers since we draw the board top down for x (rows)\r\n    return { x: DIM - Number(number), y: letter.charCodeAt(0) - 65 }\r\n}\r\n\r\n/**\r\n * Converts a piece location to board coordinate, e.g., 0, 0 to a8\r\n * @param {string} x - The X position.\r\n * @param {string} y - The Y position.\r\n * @returns {string} - Returns a string containing the board coordinates.\r\n */\r\nexport function convertLocationToCoordinates(x, y) {\r\n    //maps y (column) to the letter coordinate; add 65 (capital A code) to the ASCII code for the location we have and we get a letter between A and F\r\n    //reverses the x (rows) coordinate because we drop the board top down, while coordinates go down up\r\n    return `${String.fromCharCode(y + 65)}${DIM - x}`.toLowerCase()\r\n}\r\n\r\n/**\r\n * Retrieves a specific square from the board using x and y coordinates (location)\r\n * @param {string} x - The X position.\r\n * @param {string} y - The Y position.\r\n * @param {array} boardSquares - The board array.\r\n * @returns {object} - Returns the square.\r\n */\r\nexport function getATargetSquareByLocation(x, y, boardSquares) {\r\n    return boardSquares.find(s => s.props.x === x && s.props.y === y);\r\n}\r\n\r\n/**\r\n * Retrieves a specific square from the board that has a certain piece\r\n * @param {string} piece - The piece to check if it's on the square.\r\n * @param {array} boardSquares - The board array.\r\n * @returns {object} - Returns the square.\r\n */\r\nexport function getATargetSquareByPiece(piece, boardSquares) {\r\n    return boardSquares.find(s => s.props.piece == piece);\r\n}\r\n\r\n/**\r\n * Determines if castling is possible.\r\n * @param {string} castlingType - The type of castling (long or short).\r\n * @param {boolean} [withWhite=true] - True if checking for white's castling, false otherwise.\r\n * @returns {boolean} - True if castling is possible, false otherwise.\r\n */\r\nfunction areWeCastling(castlingType, withWhite = true) {\r\n    const row = withWhite ? GlobalVariables.CASTLE_ROW_WHITE : GlobalVariables.CASTLE_ROW_BLACK;\r\n    const pieces = withWhite ? GlobalVariables.FEN_PIECES_WHITE : GlobalVariables.FEN_PIECES_BLACK;\r\n    const [rookCol, kingCol, pathCols] = castlingType === GlobalVariables.CASTLING_TYPES.LONG ?\r\n        [GlobalVariables.CASTLE_ROOK_INITIAL_COL_LONG, GlobalVariables.CASTLE_KING_INITIAL_COL, GlobalVariables.CASTLE_PATH_COLS_LONG] :\r\n        [GlobalVariables.CASTLE_ROOK_INITIAL_COL_SHORT, GlobalVariables.CASTLE_KING_INITIAL_COL, GlobalVariables.CASTLE_PATH_COLS_SHORT];\r\n\r\n    return BoardPosition[row][rookCol] === pieces.ROOK &&\r\n        BoardPosition[row][kingCol] === pieces.KING &&\r\n        pathCols.every(col => BoardPosition[row][col] === GlobalVariables.EMPTY_SQUARE_PIECE);\r\n}\r\n\r\n/**\r\n * Updates a column on a row with a new value.\r\n * @param {array} row - The row to update.\r\n * @param {number} colIndex - The column index to update.\r\n * @param {string} newValue - The new value to set.\r\n * @returns {array} - The updated row.\r\n */\r\nfunction updateColumnOnARow(row, colIndex, newValue) {\r\n    row[colIndex] = newValue;\r\n    return row;\r\n}\r\n\r\n/**\r\n * Removes the current square's piece and handles castling if applicable.\r\n * @param {object} square - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {array} row - The row to update.\r\n * @returns {array} - The updated row.\r\n */\r\nfunction handleSquareOnCurrentRow(square, targetSquare, row) {\r\n    return checkIfTwoSquaresAreOnTheSameRow(square, targetSquare) ?\r\n        handleSquareAndTargetSquareOnTheSameRow(square, targetSquare, row) :\r\n        updateColumnOnARow(row, square.props.y, GlobalVariables.EMPTY_SQUARE_PIECE);\r\n}\r\n\r\n/**\r\n * Updates the target square with the current square's piece.\r\n * @param {object} square - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {array} row - The row to update.\r\n * @returns {array} - The updated row.\r\n */\r\nfunction handleTargetSquareOnCurrentRow(square, targetSquare, row) {\r\n    return updateColumnOnARow(row, targetSquare.props.y, ConvertPieceToFENPiece(square.props.piece));\r\n}\r\n\r\n/**\r\n * Handles the scenario where the current square and target square are on the same row.\r\n * @param {object} square - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {array} row - The row to update.\r\n * @returns {array} - The updated row.\r\n */\r\nfunction handleSquareAndTargetSquareOnTheSameRow(square, targetSquare, row) {\r\n    if (doesTheSquareHasThePiece(square, GlobalVariables.PIECES.KING) && areWeCastling(square, targetSquare)) {\r\n        return handleCastling(square, row);\r\n    }\r\n    return SidewaysCapture(row, Number(square.props.y), Number(targetSquare.props.y), square.props.piece);\r\n}\r\n\r\n/**\r\n * Performs castling, swapping the rook and the king.\r\n * @param {object} square - The current square.\r\n * @param {array} row - The row to update.\r\n * @returns {array} - The updated row.\r\n */\r\nfunction handleCastling(square, row) {\r\n    const color = getPieceColor(square);\r\n    const isWhite = isColorWhite(color);\r\n    const kingPiece = isWhite ? GlobalVariables.FEN_PIECES_WHITE.KING : GlobalVariables.FEN_PIECES_BLACK.KING;\r\n    const rookPiece = isWhite ? GlobalVariables.FEN_PIECES_WHITE.ROOK : GlobalVariables.FEN_PIECES_BLACK.ROOK;\r\n\r\n    Object.values(CASTLING_TYPES).forEach(type => {\r\n        if (areWeCastling(type, isWhite)) {\r\n            const [emptySquares, kingFinalCol, rookFinalCol] = type === GlobalVariables.CASTLING_TYPES.LONG ?\r\n                [GlobalVariables.EMPTY_SQUARES_AFTER_LONG_CASTLE, GlobalVariables.CASTLE_KING_FINAL_COL_LONG, GlobalVariables.CASTLE_ROOK_FINAL_COL_LONG] :\r\n                [GlobalVariables.EMPTY_SQUARES_AFTER_SHORT_CASTLE, GlobalVariables.CASTLE_KING_FINAL_COL_SHORT, GlobalVariables.CASTLE_ROOK_FINAL_COL_SHORT];\r\n            emptySquares.forEach(col => row[col] = GlobalVariables.EMPTY_SQUARE_PIECE);\r\n            row[kingFinalCol] = kingPiece;\r\n            row[rookFinalCol] = rookPiece;\r\n        }\r\n    });\r\n\r\n    return row;\r\n}\r\n\r\n/**\r\n * Updates the current position to a new position after making the move.\r\n * @param {object} square - The current square.\r\n * @param {object} targetSquare - The target square.\r\n * @param {array} position - The current position.\r\n * @returns {array} - The updated position.\r\n */\r\nexport function UpdatePosition(square, targetSquare, position) {\r\n    return position.map((row, rowIndex) => {\r\n        if (isSquareOnRow(square, rowIndex)) {\r\n            row = handleSquareOnCurrentRow(square, targetSquare, row);\r\n        }\r\n        if (isSquareOnRow(targetSquare, rowIndex)) {\r\n            row = handleTargetSquareOnCurrentRow(square, targetSquare, row);\r\n        }\r\n        return row;\r\n    });\r\n}\r\n\r\n/**\r\n * Modifies the row to capture pieces sideways (square and target square are on the same row).\r\n * @param {array} row - The row to update.\r\n * @param {number} colIndex - The column index of the square.\r\n * @param {number} targetColIndex - The column index of the target square.\r\n * @param {string} value - The value to place at the target column index.\r\n * @returns {array} - The updated row.\r\n */\r\nfunction SidewaysCapture(row, colIndex, targetColIndex, value) {\r\n    return row.map((col, index) => {\r\n        if (index === colIndex) return GlobalVariables.EMPTY_SQUARE_PIECE;\r\n        if (index === targetColIndex) return ConvertPieceToFENPiece(value);\r\n        return col;\r\n    });\r\n}\r\n\r\n/**\r\n * Converts the piece from format {color-piece} to FEN format (a single letter).\r\n * @param {string} value - The piece in {color-piece} format.\r\n * @returns {string} - The piece in FEN format.\r\n */\r\nfunction ConvertPieceToFENPiece(value) {\r\n    const [color, piece] = value.split(GlobalVariables.PIECE_DELIMITER);\r\n    const pieceMapping = {\r\n        [GlobalVariables.PIECES.PAWN]: GlobalVariables.FEN_PIECES_BLACK.PAWN,\r\n        [GlobalVariables.PIECES.KNIGHT]: GlobalVariables.FEN_PIECES_BLACK.KNIGHT,\r\n        [GlobalVariables.PIECES.BISHOP]: GlobalVariables.FEN_PIECES_BLACK.BISHOP,\r\n        [GlobalVariables.PIECES.ROOK]: GlobalVariables.FEN_PIECES_BLACK.ROOK,\r\n        [GlobalVariables.PIECES.QUEEN]: GlobalVariables.FEN_PIECES_BLACK.QUEEN,\r\n        [GlobalVariables.PIECES.KING]: GlobalVariables.FEN_PIECES_BLACK.KING,\r\n    };\r\n\r\n    const fenPiece = pieceMapping[piece];\r\n    return isColorWhite(color) ? fenPiece.toUpperCase() : fenPiece;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}