{"ast":null,"code":"import * as GlobalVariables from './globalVariables';\nimport * as HelperMethods from './HelperMethods';\n\n/**\r\n * Returns all possible moves for a given square based on the piece type.\r\n * @param {object} square - The square containing the piece.\r\n * @param {Array} boardSquares - The current state of the board.\r\n * @returns {Array} - The possible moves for the piece on the given square.\r\n */\nexport function getAllPossibleMoves(square, boardSquares) {\n  const pieceColor = HelperMethods.getPieceColor(square);\n  const pieceType = HelperMethods.getPiece(square);\n  const moveHandlers = {\n    [GlobalVariables.PIECES.PAWN]: getPawnMoves,\n    [GlobalVariables.PIECES.ROOK]: getRookMoves,\n    [GlobalVariables.PIECES.KNIGHT]: getKnightMoves,\n    [GlobalVariables.PIECES.BISHOP]: getBishopMoves,\n    [GlobalVariables.PIECES.QUEEN]: getQueenMoves,\n    [GlobalVariables.PIECES.KING]: getKingMoves\n  };\n  const moveHandler = moveHandlers[pieceType];\n  return moveHandler ? [moveHandler(square, boardSquares, pieceColor)] : [];\n}\n\n/**\r\n * Gets possible moves for a piece based on specified offsets.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {Array} offsets - An array of [dx, dy] offsets to check for possible moves.\r\n * @returns {Array} - The possible moves array.\r\n */\nfunction getMovesForOffsets(square, boardSquares, offsets) {\n  const moves = [];\n  offsets.forEach(([dx, dy]) => {\n    const targetX = square.props.x + dx;\n    const targetY = square.props.y + dy;\n    const target = HelperMethods.getATargetSquareByLocation(targetX, targetY, boardSquares);\n    if (target) {\n      if (HelperMethods.isKing(square) && checkIfTargetHasKingAsNeighbor(target, boardSquares)) {\n        return;\n      }\n      if (HelperMethods.isSquareAvailable(target)) {\n        moves.push(target);\n      } else if (!HelperMethods.areSameColor(square, target)) {\n        moves.push(target);\n      }\n    }\n  });\n  return moves;\n}\nfunction checkIfTargetHasKingAsNeighbor(target, boardSquares) {\n  const directions = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]];\n  for (const [dx, dy] of directions) {\n    const neighborX = target.props.x + dx;\n    const neighborY = target.props.y + dy;\n    const neighbor = HelperMethods.getATargetSquareByLocation(neighborX, neighborY, boardSquares);\n    if (neighbor && !HelperMethods.isKing(neighbor) && !HelperMethods.areSameColor(target, neighbor)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\r\n * Gets all possible moves in a given direction for a piece.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {Array} direction - The direction to move in [xIncrement, yIncrement].\r\n * @returns {Array} - The possible moves array in the given direction.\r\n */\nfunction getMovesInDirection(square, boardSquares, [xIncrement, yIncrement]) {\n  const moves = [];\n  let x = square.props.x + xIncrement;\n  let y = square.props.y + yIncrement;\n  while (HelperMethods.areCoordinatesInBounds(x, y)) {\n    const targetSquare = HelperMethods.getATargetSquareByLocation(x, y, boardSquares);\n    if (HelperMethods.isSquareAvailable(targetSquare)) {\n      moves.push(targetSquare);\n    } else {\n      if (!HelperMethods.areSameColor(square, targetSquare)) {\n        moves.push(targetSquare);\n      }\n      break;\n    }\n    x += xIncrement;\n    y += yIncrement;\n  }\n  return moves;\n}\n\n/**\r\n * Gets possible moves for a pawn.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible moves array.\r\n */\nfunction getPawnMoves(square, boardSquares) {\n  const moves = [];\n  const pieceColor = HelperMethods.getPieceColor(square);\n  const isWhite = HelperMethods.isColorWhite(pieceColor);\n  const direction = isWhite ? -1 : 1;\n\n  // Forward move offsets\n  const forwardOne = direction;\n  const forwardTwo = direction * 2;\n\n  // Helper function to get target square\n  const getTargetSquare = (x, y) => HelperMethods.getATargetSquareByLocation(x, y, boardSquares);\n\n  // Calculate potential forward moves\n  const addForwardMoves = () => {\n    const target1X = square.props.x + forwardOne;\n    const target2X = square.props.x + forwardTwo;\n    const target1 = getTargetSquare(target1X, square.props.y);\n    const target2 = getTargetSquare(target2X, square.props.y);\n    if (HelperMethods.isSquareAvailable(target1)) {\n      moves.push(target1);\n      if (HelperMethods.isSquareAvailable(target2) && HelperMethods.isPawnOnStartingSquare(square)) {\n        moves.push(target2);\n      }\n    }\n  };\n\n  // Calculate potential capture moves\n  const addCaptureMoves = () => {\n    const captureOffsets = [[forwardOne, 1], [forwardOne, -1]];\n    captureOffsets.forEach(([xOffset, yOffset]) => {\n      const targetX = square.props.x + xOffset;\n      const targetY = square.props.y + yOffset;\n      const targetSquare = getTargetSquare(targetX, targetY);\n      if (targetSquare && !HelperMethods.isSquareAvailable(targetSquare) && !HelperMethods.areSameColor(targetSquare, square)) {\n        moves.push(targetSquare);\n      }\n    });\n  };\n\n  // Check for en passant capture\n  const addEnPassantMove = () => {\n    if (!GlobalVariables.EnPassant.isPossible) return;\n    const enPassantSquare = getTargetSquare(GlobalVariables.EnPassant.x, GlobalVariables.EnPassant.y);\n    const validEnPassantOffsets = [[square.props.x + forwardOne, square.props.y + 1], [square.props.x + forwardOne, square.props.y - 1]];\n    if (enPassantSquare && validEnPassantOffsets.some(([x, y]) => HelperMethods.areCoordinatesInBounds(x, y) && HelperMethods.compareIfTwoSquaresAreTheSame(enPassantSquare, getTargetSquare(x, y)))) {\n      moves.push(enPassantSquare);\n    }\n  };\n\n  // Add all possible moves\n  addForwardMoves();\n  addCaptureMoves();\n  addEnPassantMove();\n  return {\n    piece: square,\n    moves: moves\n  };\n}\n\n/**\r\n * Gets possible moves for a rook.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible moves array.\r\n */\nfunction getRookMoves(square, boardSquares) {\n  const directions = [[1, 0],\n  // Right\n  [-1, 0],\n  // Left\n  [0, 1],\n  // Up\n  [0, -1] // Down\n  ];\n  const moves = directions.flatMap(direction => getMovesInDirection(square, boardSquares, direction));\n  return {\n    piece: square,\n    moves\n  };\n}\n\n/**\r\n * Gets possible moves for a knight.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible moves array.\r\n */\nfunction getKnightMoves(square, boardSquares) {\n  const knightMoves = [[2, 1], [1, 2], [-1, 2], [-2, 1], [-2, -1], [-1, -2], [1, -2], [2, -1]];\n  const moves = getMovesForOffsets(square, boardSquares, knightMoves);\n  return {\n    piece: square,\n    moves\n  };\n}\n\n/**\r\n * Gets possible moves for a bishop.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible moves array.\r\n */\nfunction getBishopMoves(square, boardSquares) {\n  const directions = [[-1, -1],\n  // Top-left diagonal\n  [-1, 1],\n  // Bottom-left diagonal\n  [1, 1],\n  // Bottom-right diagonal\n  [1, -1] // Top-right diagonal\n  ];\n  const moves = directions.flatMap(direction => getMovesInDirection(square, boardSquares, direction));\n  return {\n    piece: square,\n    moves\n  };\n}\n\n/**\r\n * Gets possible moves for a queen.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible moves array.\r\n */\nfunction getQueenMoves(square, boardSquares) {\n  const directions = [[1, 0], [-1, 0], [0, 1], [0, -1],\n  // Rook directions\n  [1, 1], [1, -1], [-1, 1], [-1, -1] // Bishop directions\n  ];\n  const moves = directions.flatMap(direction => getMovesInDirection(square, boardSquares, direction));\n  return {\n    piece: square,\n    moves\n  };\n}\n\n/**\r\n * Gets possible moves for a king.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible moves array.\r\n */\nfunction getKingMoves(square, boardSquares) {\n  const directions = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]];\n  const moves = getMovesForOffsets(square, boardSquares, directions);\n  const color = HelperMethods.getPieceColor(square);\n\n  // Castling logic\n  const castlingMoves = getCastlingMoves(square, color, boardSquares);\n  moves.push(...castlingMoves);\n  return {\n    piece: square,\n    moves\n  };\n}\n\n/**\r\n * Gets castling moves for a king.\r\n * @param {object} square - The current square.\r\n * @param {string} color - The color of the piece.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible castling moves array.\r\n */\nfunction getCastlingMoves(square, color, boardSquares) {\n  const moves = [];\n  const longCastleSquare = HelperMethods.getATargetSquareByLocation(square.props.x, square.props.y - 2, boardSquares);\n  const shortCastleSquare = HelperMethods.getATargetSquareByLocation(square.props.x, square.props.y + 2, boardSquares);\n  const isWhite = HelperMethods.isColorWhite(color);\n\n  // Check and add long castling move\n  if (HelperMethods.isCastlingPossible(GlobalVariables.CASTLING_TYPES.LONG, isWhite)) {\n    moves.push(longCastleSquare);\n  }\n\n  // Check and add short castling move\n  if (HelperMethods.isCastlingPossible(GlobalVariables.CASTLING_TYPES.SHORT, isWhite)) {\n    moves.push(shortCastleSquare);\n  }\n  return moves;\n}\n\n/**\r\n * Filters out moves that do not deal with a check.\r\n * @param {Array} possibleMoves - The array of possible moves.\r\n * @param {Array} boardSquares - The board squares array.\r\n * @returns {Array} - The filtered array of possible moves.\r\n */\nexport function filterMovesIfInCheck(possibleMoves, boardSquares) {\n  const blackKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.BLACK_KING, boardSquares);\n  const whiteKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.WHITE_KING, boardSquares);\n  const king = GlobalVariables.IsWhiteToMove ? whiteKing : blackKing;\n  const filterMoves = (moves, piece) => {\n    return moves.filter(move => {\n      return HelperMethods.isMoveLegal(king, boardSquares, piece, move);\n    });\n  };\n  return possibleMoves.map(moveSet => {\n    const filteredMoves = filterMoves(moveSet.moves, moveSet.piece);\n    return {\n      ...moveSet,\n      moves: filteredMoves\n    };\n  });\n}\n\n/**\r\n * Filters out moves that allow illegal castling (castling through check).\r\n * @param {Array} possibleMoves - The array of possible moves.\r\n * @param {Array} boardSquares - The board squares array.\r\n * @returns {Array} - The filtered array of possible moves.\r\n */\nexport function filterMovesThatAllowIllegalCastling(possibleMoves, boardSquares) {\n  const blackKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.BLACK_KING, boardSquares);\n  const whiteKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.WHITE_KING, boardSquares);\n  const king = GlobalVariables.IsWhiteToMove ? whiteKing : blackKing;\n  const castleRow = GlobalVariables.IsWhiteToMove ? GlobalVariables.CASTLE_ROW_WHITE : GlobalVariables.CASTLE_ROW_BLACK;\n  const removeCastlingMove = (moves, x, y) => {\n    //get the index of the move\n    const index = moves.findIndex(m => HelperMethods.isSquareOnRow(m, x) && HelperMethods.isSquareOnColumn(m, y));\n\n    //remove the move if it exists\n    if (index !== -1) {\n      moves.splice(index, 1);\n    }\n  };\n  const isIllegalCastling = (king, shortCastle, longCastle, acrossShort, acrossLong) => {\n    if (king && (shortCastle || longCastle)) {\n      if (shortCastle && acrossShort && acrossShort.props.piece) {\n        removeCastlingMove(king.moves, shortCastle.props.x, shortCastle.props.y);\n      }\n      if (longCastle && acrossLong && acrossLong.props.piece) {\n        removeCastlingMove(king.moves, longCastle.props.x, longCastle.props.y);\n      }\n    }\n  };\n  return possibleMoves.map(moveSet => {\n    const piece = moveSet.piece;\n    const moves = moveSet.moves;\n\n    //get the squares where the king will end up after castling\n    const shortCastle = HelperMethods.getATargetSquareByLocation(castleRow, GlobalVariables.CASTLE_KING_FINAL_COL_SHORT, moves);\n    const longCastle = HelperMethods.getATargetSquareByLocation(castleRow, GlobalVariables.CASTLE_KING_FINAL_COL_LONG, moves);\n    if (HelperMethods.compareIfTwoSquaresAreTheSame(piece, king)) {\n      if (HelperMethods.isKingInCheck(king, boardSquares)) {\n        removeCastlingMove(moves, castleRow, GlobalVariables.CASTLE_KING_FINAL_COL_SHORT);\n        removeCastlingMove(moves, castleRow, GlobalVariables.CASTLE_KING_FINAL_COL_LONG);\n      }\n      const acrossShort = HelperMethods.getATargetSquareByLocation(castleRow, GlobalVariables.CASTLE_ROOK_FINAL_COL_SHORT, moves);\n      const acrossLong = HelperMethods.getATargetSquareByLocation(castleRow, GlobalVariables.CASTLE_ROOK_FINAL_COL_LONG, moves);\n      isIllegalCastling(moveSet, shortCastle, longCastle, acrossShort, acrossLong);\n    }\n    return moveSet;\n  });\n}\n\n/**\r\n * Removes empty or undefined moves from the possible moves array.\r\n * @param {Array} possibleMoves - The array of possible moves.\r\n * @returns {Array} - The cleaned array of possible moves.\r\n */\nexport function removeEmptyMoves(possibleMoves) {\n  return possibleMoves.filter(moveSet => moveSet && moveSet.moves && moveSet.moves.length > 0).map(moveSet => ({\n    ...moveSet,\n    moves: moveSet.moves.filter(move => move)\n  }));\n}\n\n/**\r\n * Determines if a move is allowed based on the current player's turn.\r\n * @param {string} color - The color of the piece.\r\n * @returns {boolean} - True if the move is allowed, false otherwise.\r\n */\nexport function isMoveAllowed(color) {\n  return HelperMethods.isColorWhite(color) && GlobalVariables.IsWhiteToMove || HelperMethods.isColorBlack(color) && !GlobalVariables.IsWhiteToMove;\n}\n\n/**\r\n * Collects possible moves for a given square.\r\n * @param {object} square - The square to collect moves for.\r\n * @param {Array} squares - The current board squares.\r\n * @returns {Array} - The possible moves for the piece on the square.\r\n */\nexport function collectPossibleMoves(square, squares) {\n  let possiblePieceMoves = getAllPossibleMoves(square, squares);\n  possiblePieceMoves = removeEmptyMoves(possiblePieceMoves);\n  possiblePieceMoves = filterMovesIfInCheck(possiblePieceMoves, squares);\n  possiblePieceMoves = filterMovesThatAllowIllegalCastling(possiblePieceMoves, squares);\n  return possiblePieceMoves;\n}\n\n/**\r\n * Updates the global possible moves array.\r\n * @param {Array} possiblePieceMoves - The possible moves to update.\r\n */\nexport function updatePossibleMoves(possiblePieceMoves) {\n  GlobalVariables.PossibleMoves.splice(0, GlobalVariables.PossibleMoves.length, ...possiblePieceMoves);\n}","map":{"version":3,"names":["GlobalVariables","HelperMethods","getAllPossibleMoves","square","boardSquares","pieceColor","getPieceColor","pieceType","getPiece","moveHandlers","PIECES","PAWN","getPawnMoves","ROOK","getRookMoves","KNIGHT","getKnightMoves","BISHOP","getBishopMoves","QUEEN","getQueenMoves","KING","getKingMoves","moveHandler","getMovesForOffsets","offsets","moves","forEach","dx","dy","targetX","props","x","targetY","y","target","getATargetSquareByLocation","isKing","checkIfTargetHasKingAsNeighbor","isSquareAvailable","push","areSameColor","directions","neighborX","neighborY","neighbor","getMovesInDirection","xIncrement","yIncrement","areCoordinatesInBounds","targetSquare","isWhite","isColorWhite","direction","forwardOne","forwardTwo","getTargetSquare","addForwardMoves","target1X","target2X","target1","target2","isPawnOnStartingSquare","addCaptureMoves","captureOffsets","xOffset","yOffset","addEnPassantMove","EnPassant","isPossible","enPassantSquare","validEnPassantOffsets","some","compareIfTwoSquaresAreTheSame","piece","flatMap","knightMoves","color","castlingMoves","getCastlingMoves","longCastleSquare","shortCastleSquare","isCastlingPossible","CASTLING_TYPES","LONG","SHORT","filterMovesIfInCheck","possibleMoves","blackKing","getATargetSquareByPiece","KINGS","BLACK_KING","whiteKing","WHITE_KING","king","IsWhiteToMove","filterMoves","filter","move","isMoveLegal","map","moveSet","filteredMoves","filterMovesThatAllowIllegalCastling","castleRow","CASTLE_ROW_WHITE","CASTLE_ROW_BLACK","removeCastlingMove","index","findIndex","m","isSquareOnRow","isSquareOnColumn","splice","isIllegalCastling","shortCastle","longCastle","acrossShort","acrossLong","CASTLE_KING_FINAL_COL_SHORT","CASTLE_KING_FINAL_COL_LONG","isKingInCheck","CASTLE_ROOK_FINAL_COL_SHORT","CASTLE_ROOK_FINAL_COL_LONG","removeEmptyMoves","length","isMoveAllowed","isColorBlack","collectPossibleMoves","squares","possiblePieceMoves","updatePossibleMoves","PossibleMoves"],"sources":["C:/Users/Vladi Gotsin/Desktop/react/Chess-React.js-/src/MoveHandler.js"],"sourcesContent":["import * as GlobalVariables from './globalVariables';\r\nimport * as HelperMethods from './HelperMethods';\r\n\r\n/**\r\n * Returns all possible moves for a given square based on the piece type.\r\n * @param {object} square - The square containing the piece.\r\n * @param {Array} boardSquares - The current state of the board.\r\n * @returns {Array} - The possible moves for the piece on the given square.\r\n */\r\nexport function getAllPossibleMoves(square, boardSquares) {\r\n    const pieceColor = HelperMethods.getPieceColor(square);\r\n    const pieceType = HelperMethods.getPiece(square);\r\n    const moveHandlers = {\r\n        [GlobalVariables.PIECES.PAWN]: getPawnMoves,\r\n        [GlobalVariables.PIECES.ROOK]: getRookMoves,\r\n        [GlobalVariables.PIECES.KNIGHT]: getKnightMoves,\r\n        [GlobalVariables.PIECES.BISHOP]: getBishopMoves,\r\n        [GlobalVariables.PIECES.QUEEN]: getQueenMoves,\r\n        [GlobalVariables.PIECES.KING]: getKingMoves,\r\n    };\r\n\r\n    const moveHandler = moveHandlers[pieceType];\r\n    return moveHandler ? [moveHandler(square, boardSquares, pieceColor)] : [];\r\n}\r\n\r\n/**\r\n * Gets possible moves for a piece based on specified offsets.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {Array} offsets - An array of [dx, dy] offsets to check for possible moves.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nfunction getMovesForOffsets(square, boardSquares, offsets) {\r\n    const moves = [];\r\n    offsets.forEach(([dx, dy]) => {\r\n        const targetX = square.props.x + dx;\r\n        const targetY = square.props.y + dy;\r\n        const target = HelperMethods.getATargetSquareByLocation(targetX, targetY, boardSquares);\r\n\r\n        if (target) {\r\n            if (HelperMethods.isKing(square) && checkIfTargetHasKingAsNeighbor(target, boardSquares)) {\r\n                return\r\n            }\r\n            if (HelperMethods.isSquareAvailable(target)) {\r\n                moves.push(target);\r\n            } else if (!HelperMethods.areSameColor(square, target)) {\r\n                moves.push(target);\r\n            }\r\n        }\r\n    });\r\n    return moves;\r\n}\r\n\r\nfunction checkIfTargetHasKingAsNeighbor(target, boardSquares) {\r\n    const directions = [\r\n        [1, 0], [-1, 0], [0, 1], [0, -1],\r\n        [1, 1], [1, -1], [-1, 1], [-1, -1]\r\n    ];\r\n\r\n    for (const [dx, dy] of directions) {\r\n        const neighborX = target.props.x + dx;\r\n        const neighborY = target.props.y + dy;\r\n        const neighbor = HelperMethods.getATargetSquareByLocation(neighborX, neighborY, boardSquares);\r\n\r\n        if (neighbor && !HelperMethods.isKing(neighbor) && !HelperMethods.areSameColor(target, neighbor)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Gets all possible moves in a given direction for a piece.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @param {Array} direction - The direction to move in [xIncrement, yIncrement].\r\n * @returns {Array} - The possible moves array in the given direction.\r\n */\r\nfunction getMovesInDirection(square, boardSquares, [xIncrement, yIncrement]) {\r\n    const moves = [];\r\n    let x = square.props.x + xIncrement;\r\n    let y = square.props.y + yIncrement;\r\n    while (HelperMethods.areCoordinatesInBounds(x, y)) {\r\n        const targetSquare = HelperMethods.getATargetSquareByLocation(x, y, boardSquares);\r\n        if (HelperMethods.isSquareAvailable(targetSquare)) {\r\n            moves.push(targetSquare);\r\n        } else {\r\n            if (!HelperMethods.areSameColor(square, targetSquare)) {\r\n                moves.push(targetSquare);\r\n            }\r\n            break;\r\n        }\r\n        x += xIncrement;\r\n        y += yIncrement;\r\n    }\r\n    return moves;\r\n}\r\n\r\n/**\r\n * Gets possible moves for a pawn.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nfunction getPawnMoves(square, boardSquares) {\r\n    const moves = []\r\n    const pieceColor = HelperMethods.getPieceColor(square)\r\n    const isWhite = HelperMethods.isColorWhite(pieceColor);\r\n    const direction = isWhite ? -1 : 1;\r\n\r\n    // Forward move offsets\r\n    const forwardOne = direction;\r\n    const forwardTwo = direction * 2;\r\n\r\n    // Helper function to get target square\r\n    const getTargetSquare = (x, y) => HelperMethods.getATargetSquareByLocation(x, y, boardSquares);\r\n\r\n    // Calculate potential forward moves\r\n    const addForwardMoves = () => {\r\n        const target1X = square.props.x + forwardOne;\r\n        const target2X = square.props.x + forwardTwo;\r\n\r\n        const target1 = getTargetSquare(target1X, square.props.y);\r\n        const target2 = getTargetSquare(target2X, square.props.y);\r\n\r\n        if (HelperMethods.isSquareAvailable(target1)) {\r\n            moves.push(target1);\r\n            if (HelperMethods.isSquareAvailable(target2) && HelperMethods.isPawnOnStartingSquare(square)) {\r\n                moves.push(target2);\r\n            }\r\n        }\r\n    };\r\n\r\n    // Calculate potential capture moves\r\n    const addCaptureMoves = () => {\r\n        const captureOffsets = [\r\n            [forwardOne, 1],\r\n            [forwardOne, -1]\r\n        ];\r\n\r\n        captureOffsets.forEach(([xOffset, yOffset]) => {\r\n            const targetX = square.props.x + xOffset;\r\n            const targetY = square.props.y + yOffset;\r\n            const targetSquare = getTargetSquare(targetX, targetY);\r\n\r\n            if (targetSquare && !HelperMethods.isSquareAvailable(targetSquare) && !HelperMethods.areSameColor(targetSquare, square)) {\r\n                moves.push(targetSquare);\r\n            }\r\n        });\r\n    };\r\n\r\n    // Check for en passant capture\r\n    const addEnPassantMove = () => {\r\n        if (!GlobalVariables.EnPassant.isPossible) return;\r\n        const enPassantSquare = getTargetSquare(GlobalVariables.EnPassant.x, GlobalVariables.EnPassant.y);\r\n        const validEnPassantOffsets = [\r\n            [square.props.x + forwardOne, square.props.y + 1],\r\n            [square.props.x + forwardOne, square.props.y - 1]\r\n        ];\r\n\r\n        if (enPassantSquare && validEnPassantOffsets.some(([x, y]) => HelperMethods.areCoordinatesInBounds(x, y) &&\r\n            HelperMethods.compareIfTwoSquaresAreTheSame(enPassantSquare, getTargetSquare(x, y)))) {\r\n            moves.push(enPassantSquare);\r\n        }\r\n    };\r\n\r\n    // Add all possible moves\r\n    addForwardMoves();\r\n    addCaptureMoves();\r\n    addEnPassantMove();\r\n\r\n    return { piece: square, moves: moves }\r\n}\r\n\r\n/**\r\n * Gets possible moves for a rook.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nfunction getRookMoves(square, boardSquares) {\r\n    const directions = [\r\n        [1, 0],  // Right\r\n        [-1, 0], // Left\r\n        [0, 1],  // Up\r\n        [0, -1]  // Down\r\n    ];\r\n\r\n    const moves = directions.flatMap(direction => getMovesInDirection(square, boardSquares, direction));\r\n\r\n    return { piece: square, moves };\r\n}\r\n\r\n/**\r\n * Gets possible moves for a knight.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nfunction getKnightMoves(square, boardSquares) {\r\n    const knightMoves = [\r\n        [2, 1], [1, 2], [-1, 2], [-2, 1],\r\n        [-2, -1], [-1, -2], [1, -2], [2, -1]\r\n    ];\r\n\r\n    const moves = getMovesForOffsets(square, boardSquares, knightMoves);\r\n    return { piece: square, moves };\r\n}\r\n\r\n/**\r\n * Gets possible moves for a bishop.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nfunction getBishopMoves(square, boardSquares) {\r\n    const directions = [\r\n        [-1, -1], // Top-left diagonal\r\n        [-1, 1],  // Bottom-left diagonal\r\n        [1, 1],   // Bottom-right diagonal\r\n        [1, -1]   // Top-right diagonal\r\n    ];\r\n\r\n    const moves = directions.flatMap(direction => getMovesInDirection(square, boardSquares, direction));\r\n\r\n    return { piece: square, moves };\r\n}\r\n\r\n/**\r\n * Gets possible moves for a queen.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nfunction getQueenMoves(square, boardSquares) {\r\n    const directions = [\r\n        [1, 0], [-1, 0], [0, 1], [0, -1], // Rook directions\r\n        [1, 1], [1, -1], [-1, 1], [-1, -1] // Bishop directions\r\n    ];\r\n\r\n    const moves = directions.flatMap(direction => getMovesInDirection(square, boardSquares, direction));\r\n\r\n    return { piece: square, moves };\r\n}\r\n\r\n/**\r\n * Gets possible moves for a king.\r\n * @param {object} square - The current square.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible moves array.\r\n */\r\nfunction getKingMoves(square, boardSquares) {\r\n    const directions = [\r\n        [1, 0], [-1, 0], [0, 1], [0, -1],\r\n        [1, 1], [1, -1], [-1, 1], [-1, -1]\r\n    ];\r\n\r\n    const moves = getMovesForOffsets(square, boardSquares, directions);\r\n\r\n    const color = HelperMethods.getPieceColor(square);\r\n\r\n    // Castling logic\r\n    const castlingMoves = getCastlingMoves(square, color, boardSquares);\r\n    moves.push(...castlingMoves);\r\n\r\n    return { piece: square, moves };\r\n}\r\n\r\n/**\r\n * Gets castling moves for a king.\r\n * @param {object} square - The current square.\r\n * @param {string} color - The color of the piece.\r\n * @param {Array} boardSquares - The current board squares.\r\n * @returns {Array} - The possible castling moves array.\r\n */\r\nfunction getCastlingMoves(square, color, boardSquares) {\r\n    const moves = [];\r\n\r\n    const longCastleSquare = HelperMethods.getATargetSquareByLocation(square.props.x, square.props.y - 2, boardSquares);\r\n    const shortCastleSquare = HelperMethods.getATargetSquareByLocation(square.props.x, square.props.y + 2, boardSquares);\r\n\r\n    const isWhite = HelperMethods.isColorWhite(color);\r\n\r\n    // Check and add long castling move\r\n    if (HelperMethods.isCastlingPossible(GlobalVariables.CASTLING_TYPES.LONG, isWhite)) {\r\n        moves.push(longCastleSquare);\r\n    }\r\n\r\n    // Check and add short castling move\r\n    if (HelperMethods.isCastlingPossible(GlobalVariables.CASTLING_TYPES.SHORT, isWhite)) {\r\n        moves.push(shortCastleSquare);\r\n    }\r\n\r\n    return moves;\r\n}\r\n\r\n/**\r\n * Filters out moves that do not deal with a check.\r\n * @param {Array} possibleMoves - The array of possible moves.\r\n * @param {Array} boardSquares - The board squares array.\r\n * @returns {Array} - The filtered array of possible moves.\r\n */\r\nexport function filterMovesIfInCheck(possibleMoves, boardSquares) {\r\n    const blackKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.BLACK_KING, boardSquares);\r\n    const whiteKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.WHITE_KING, boardSquares);\r\n    const king = GlobalVariables.IsWhiteToMove ? whiteKing : blackKing\r\n\r\n    const filterMoves = (moves, piece) => {\r\n        return moves.filter(move => {\r\n            return HelperMethods.isMoveLegal(king, boardSquares, piece, move)\r\n        });\r\n    };\r\n\r\n    return possibleMoves.map(moveSet => {\r\n        const filteredMoves = filterMoves(moveSet.moves, moveSet.piece);\r\n        return { ...moveSet, moves: filteredMoves };\r\n    });\r\n}\r\n\r\n/**\r\n * Filters out moves that allow illegal castling (castling through check).\r\n * @param {Array} possibleMoves - The array of possible moves.\r\n * @param {Array} boardSquares - The board squares array.\r\n * @returns {Array} - The filtered array of possible moves.\r\n */\r\nexport function filterMovesThatAllowIllegalCastling(possibleMoves, boardSquares) {\r\n    const blackKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.BLACK_KING, boardSquares);\r\n    const whiteKing = HelperMethods.getATargetSquareByPiece(GlobalVariables.KINGS.WHITE_KING, boardSquares);\r\n    const king = GlobalVariables.IsWhiteToMove ? whiteKing : blackKing\r\n    const castleRow = GlobalVariables.IsWhiteToMove ? GlobalVariables.CASTLE_ROW_WHITE : GlobalVariables.CASTLE_ROW_BLACK\r\n\r\n    const removeCastlingMove = (moves, x, y) => {\r\n        //get the index of the move\r\n        const index = moves.findIndex(m => HelperMethods.isSquareOnRow(m, x) && HelperMethods.isSquareOnColumn(m, y));\r\n\r\n        //remove the move if it exists\r\n        if (index !== -1) {\r\n            moves.splice(index, 1);\r\n        }\r\n    };\r\n\r\n    const isIllegalCastling = (king, shortCastle, longCastle, acrossShort, acrossLong) => {\r\n        if (king && (shortCastle || longCastle)) {\r\n            if (shortCastle && acrossShort && acrossShort.props.piece) {\r\n                removeCastlingMove(king.moves, shortCastle.props.x, shortCastle.props.y);\r\n            }\r\n            if (longCastle && acrossLong && acrossLong.props.piece) {\r\n                removeCastlingMove(king.moves, longCastle.props.x, longCastle.props.y);\r\n            }\r\n        }\r\n    };\r\n\r\n    return possibleMoves.map(moveSet => {\r\n        const piece = moveSet.piece;\r\n        const moves = moveSet.moves;\r\n\r\n        //get the squares where the king will end up after castling\r\n        const shortCastle = HelperMethods.getATargetSquareByLocation(castleRow, GlobalVariables.CASTLE_KING_FINAL_COL_SHORT, moves)\r\n        const longCastle = HelperMethods.getATargetSquareByLocation(castleRow, GlobalVariables.CASTLE_KING_FINAL_COL_LONG, moves)\r\n\r\n        if (HelperMethods.compareIfTwoSquaresAreTheSame(piece, king)) {\r\n            if (HelperMethods.isKingInCheck(king, boardSquares)) {\r\n                removeCastlingMove(moves, castleRow, GlobalVariables.CASTLE_KING_FINAL_COL_SHORT);\r\n                removeCastlingMove(moves, castleRow, GlobalVariables.CASTLE_KING_FINAL_COL_LONG);\r\n            }\r\n\r\n            const acrossShort = HelperMethods.getATargetSquareByLocation(castleRow, GlobalVariables.CASTLE_ROOK_FINAL_COL_SHORT, moves)\r\n            const acrossLong = HelperMethods.getATargetSquareByLocation(castleRow, GlobalVariables.CASTLE_ROOK_FINAL_COL_LONG, moves)\r\n\r\n            isIllegalCastling(moveSet, shortCastle, longCastle, acrossShort, acrossLong);\r\n        }\r\n\r\n        return moveSet;\r\n    });\r\n}\r\n\r\n/**\r\n * Removes empty or undefined moves from the possible moves array.\r\n * @param {Array} possibleMoves - The array of possible moves.\r\n * @returns {Array} - The cleaned array of possible moves.\r\n */\r\nexport function removeEmptyMoves(possibleMoves) {\r\n    return possibleMoves.filter(moveSet =>\r\n        moveSet && moveSet.moves && moveSet.moves.length > 0\r\n    ).map(moveSet => ({\r\n        ...moveSet,\r\n        moves: moveSet.moves.filter(move => move)\r\n    }));\r\n}\r\n\r\n/**\r\n * Determines if a move is allowed based on the current player's turn.\r\n * @param {string} color - The color of the piece.\r\n * @returns {boolean} - True if the move is allowed, false otherwise.\r\n */\r\nexport function isMoveAllowed(color) {\r\n    return (HelperMethods.isColorWhite(color) && GlobalVariables.IsWhiteToMove) ||\r\n        (HelperMethods.isColorBlack(color) && !GlobalVariables.IsWhiteToMove);\r\n}\r\n\r\n/**\r\n * Collects possible moves for a given square.\r\n * @param {object} square - The square to collect moves for.\r\n * @param {Array} squares - The current board squares.\r\n * @returns {Array} - The possible moves for the piece on the square.\r\n */\r\nexport function collectPossibleMoves(square, squares) {\r\n    let possiblePieceMoves = getAllPossibleMoves(square, squares);\r\n    possiblePieceMoves = removeEmptyMoves(possiblePieceMoves);\r\n    possiblePieceMoves = filterMovesIfInCheck(possiblePieceMoves, squares);\r\n    possiblePieceMoves = filterMovesThatAllowIllegalCastling(possiblePieceMoves, squares);\r\n    return possiblePieceMoves;\r\n}\r\n\r\n/**\r\n * Updates the global possible moves array.\r\n * @param {Array} possiblePieceMoves - The possible moves to update.\r\n */\r\nexport function updatePossibleMoves(possiblePieceMoves) {\r\n    GlobalVariables.PossibleMoves.splice(0, GlobalVariables.PossibleMoves.length, ...possiblePieceMoves);\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}